#include "AstCppGen.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			using namespace collections;
			using namespace stream;

/***********************************************************************
Utility
***********************************************************************/

			void WriteFileComment(const WString& name, stream::StreamWriter& writer)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"This file is generated by: Vczh Parser Generator");
				writer.WriteLine(L"From parser definition:" + name);
				writer.WriteLine(L"Licensed under https://github.com/vczh-libraries/License");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
			}

			WString WriteFileBegin(AstDefFile* file, const WString& includeFile, stream::StreamWriter& writer)
			{
				for (auto include : file->includes)
				{
					writer.WriteLine(L"#include \"" + include + L"\"");
				}
				if (includeFile != L"")
				{
					writer.WriteLine(L"#include \"" + file->filePrefix + includeFile + L".h\"");
				}
				writer.WriteLine(L"");
				WString prefix;
				for (auto ns : file->cppNss)
				{
					writer.WriteLine(prefix + L"namespace " + ns);
					writer.WriteLine(prefix + L"{");
					prefix += L"\t";
				}
				return prefix;
			}

			void WriteFileEnd(AstDefFile* file, stream::StreamWriter& writer)
			{
				vint counter = file->cppNss.Count();
				for (auto ns : file->cppNss)
				{
					counter--;
					for (vint i = 0; i < counter; i++) writer.WriteChar(L'\t');
					writer.WriteLine(L"}");
				}
			}

/***********************************************************************
Forward Declarations
***********************************************************************/

			extern void		WriteTypeForwardDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteVisitorImpl(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeReflectionDeclaration(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeReflectionImplementation(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);

/***********************************************************************
WriteAstHeaderFile
***********************************************************************/

			void WriteAstHeaderFile(AstDefFile* file, stream::StreamWriter& writer)
			{
				WriteFileComment(file->Name(), writer);
				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#ifndef ");
					writer.WriteLine(file->headerGuard + L"_AST");
					writer.WriteString(L"#define ");
					writer.WriteLine(file->headerGuard + L"_AST");
				}
				else
				{
					writer.WriteLine(L"#pragma once");
				}
				writer.WriteLine(L"");
				WString prefix = WriteFileBegin(file, L"", writer);

				WriteTypeForwardDefinitions(file, prefix, writer);
				WriteTypeDefinitions(file, prefix, writer);

				WriteFileEnd(file, writer);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				WriteTypeReflectionDeclaration(file, L"\t\t\t", writer);
				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");

				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#endif");
				}
			}

/***********************************************************************
WriteAstCppFile
***********************************************************************/

			void WriteAstCppFile(AstDefFile* file, stream::StreamWriter& writer)
			{
				WriteFileComment(file->Name(), writer);
				WString prefix = WriteFileBegin(file, file->Name(), writer);

				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Visitor Pattern Implementation");
				writer.WriteLine(L"***********************************************************************/");
				WriteVisitorImpl(file, prefix, writer);

				WriteFileEnd(file, writer);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				WriteTypeReflectionImplementation(file, L"\t\t\t", writer);
				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");
			}

/***********************************************************************
WriteVisitorHeaderFile
***********************************************************************/

			void WriteVisitorHeaderFile(AstDefFile* file, const WString& visitorName, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteFileComment(file->Name(), writer);
				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#ifndef ");
					writer.WriteLine(file->headerGuard + L"_AST_" + wupper(visitorName) + L"VISITOR");
					writer.WriteString(L"#define ");
					writer.WriteLine(file->headerGuard + L"_AST_" + wupper(visitorName) + L"VISITOR");
				}
				else
				{
					writer.WriteLine(L"#pragma once");
				}
				writer.WriteLine(L"");
				WString prefix = WriteFileBegin(file, file->Name(), writer);
				writer.WriteLine(prefix + L"namespace " + wlower(visitorName) + L"_visitor");
				writer.WriteLine(prefix + L"{");
				prefix += L"\t";

				callback(prefix);

				prefix = prefix.Left(prefix.Length() - 1);
				writer.WriteLine(prefix + L"}");
				WriteFileEnd(file, writer);

				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#endif");
				}
			}

/***********************************************************************
WriteVisitorCppFile
***********************************************************************/

			void WriteVisitorCppFile(AstDefFile* file, const WString& visitorName, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteFileComment(file->Name(), writer);
				WString prefix = WriteFileBegin(file, file->Name() + L"_" + visitorName, writer);
				writer.WriteLine(prefix + L"namespace " + wlower(visitorName) + L"_visitor");
				writer.WriteLine(prefix + L"{");
				prefix += L"\t";

				callback(prefix);

				prefix = prefix.Left(prefix.Length() - 1);
				writer.WriteLine(prefix + L"}");
				WriteFileEnd(file, writer);
			}

/***********************************************************************
WriteAstFiles
***********************************************************************/

			CppGenOutput WriteAstFiles(AstDefFile* file, collections::Dictionary<WString, WString>& files)
			{
				CppGenOutput output;
				output.astH = file->filePrefix + file->Name() + L".h";
				output.astCpp = file->filePrefix + file->Name() + L".cpp";
				output.emptyH = file->filePrefix + file->Name() + L"_Empty.h";
				output.emptyCpp = file->filePrefix + file->Name() + L"_Empty.cpp";
				output.copyH = file->filePrefix + file->Name() + L"_Copy.h";
				output.copyCpp = file->filePrefix + file->Name() + L"_Copy.cpp";
				output.traverseH = file->filePrefix + file->Name() + L"_Traverse.h";
				output.traverseCpp = file->filePrefix + file->Name() + L"_Traverse.cpp";

				{
					WString fileH = GenerateToStream([=](StreamWriter& writer)
					{
						WriteAstHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([=](StreamWriter& writer)
					{
						WriteAstCppFile(file, writer);
					});

					files.Add(output.astH, fileH);
					files.Add(output.astCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([=](StreamWriter& writer)
					{
						WriteEmptyVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([=](StreamWriter& writer)
					{
						WriteEmptyVisitorCppFile(file, writer);
					});

					files.Add(output.emptyH, fileH);
					files.Add(output.emptyCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([=](StreamWriter& writer)
					{
						WriteCopyVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([=](StreamWriter& writer)
					{
						WriteCopyVisitorCppFile(file, writer);
					});

					files.Add(output.copyH, fileH);
					files.Add(output.copyCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([=](StreamWriter& writer)
					{
						WriteTraverseVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([=](StreamWriter& writer)
					{
						WriteTraverseVisitorCppFile(file, writer);
					});

					files.Add(output.traverseH, fileH);
					files.Add(output.traverseCpp, fileCpp);
				}
				return output;
			}
		}
	}
}