#include "AstCppGen.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			using namespace collections;
			using namespace stream;

/***********************************************************************
Utility
***********************************************************************/

			void WriteFileComment(const WString& name, stream::StreamWriter& writer)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"This file is generated by: Vczh Parser Generator");
				writer.WriteLine(L"From parser definition:" + name);
				writer.WriteLine(L"Licensed under https://github.com/vczh-libraries/License");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
			}

			WString WriteNssBegin(List<WString>& cppNss, stream::StreamWriter& writer)
			{
				WString prefix;
				for (auto ns : cppNss)
				{
					writer.WriteLine(prefix + L"namespace " + ns);
					writer.WriteLine(prefix + L"{");
					prefix += L"\t";
				}
				return prefix;
			}

			void WriteNssEnd(List<WString>& cppNss, stream::StreamWriter& writer)
			{
				vint counter = cppNss.Count();
				for (auto ns : cppNss)
				{
					counter--;
					for (vint i = 0; i < counter; i++) writer.WriteChar(L'\t');
					writer.WriteLine(L"}");
				}
			}

			WString WriteFileBegin(AstDefFile* file, const WString& includeFile, stream::StreamWriter& writer)
			{
				for (auto include : file->includes)
				{
					writer.WriteLine(L"#include \"" + include + L"\"");
				}
				if (includeFile != L"")
				{
					writer.WriteLine(L"#include \"" + file->Owner()->name + includeFile + L".h\"");
				}
				writer.WriteLine(L"");
				return WriteNssBegin(file->cppNss, writer);
			}

			void WriteFileEnd(AstDefFile* file, stream::StreamWriter& writer)
			{
				WriteNssEnd(file->cppNss, writer);
			}

			void CollectVisitorsAndConcreteClasses(AstDefFile* file, List<AstClassSymbol*>& visitors, List<AstClassSymbol*>& concreteClasses)
			{
				for (auto name : file->SymbolOrder())
				{
					if (auto classSymbol = dynamic_cast<AstClassSymbol*>(file->Symbols()[name]))
					{
						if (classSymbol->derivedClasses.Count() > 0)
						{
							visitors.Add(classSymbol);
						}
						if (!classSymbol->baseClass && classSymbol->derivedClasses.Count() == 0)
						{
							concreteClasses.Add(classSymbol);
						}
					}
				}
			}

/***********************************************************************
Forward Declarations
***********************************************************************/

			extern void		WriteTypeForwardDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteClassEnumDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteFieldEnumDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeDefinitions(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteVisitorImpl(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeReflectionDeclaration(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);
			extern void		WriteTypeReflectionImplementation(AstDefFile* file, const WString& prefix, stream::StreamWriter& writer);

/***********************************************************************
WriteAstHeaderFile
***********************************************************************/

			void WriteAstHeaderFile(AstDefFile* file, stream::StreamWriter& writer)
			{
				WriteFileComment(file->Name(), writer);
				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#ifndef ");
					writer.WriteLine(file->headerGuard + L"_AST");
					writer.WriteString(L"#define ");
					writer.WriteLine(file->headerGuard + L"_AST");
				}
				else
				{
					writer.WriteLine(L"#pragma once");
				}
				writer.WriteLine(L"");
				WString prefix = WriteFileBegin(file, L"", writer);

				WriteTypeForwardDefinitions(file, prefix, writer);
				WriteClassEnumDefinitions(file, prefix, writer);
				WriteFieldEnumDefinitions(file, prefix, writer);
				WriteTypeDefinitions(file, prefix, writer);

				WriteFileEnd(file, writer);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				WriteTypeReflectionDeclaration(file, L"\t\t\t", writer);
				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");

				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#endif");
				}
			}

/***********************************************************************
WriteAstCppFile
***********************************************************************/

			void WriteAstCppFile(AstDefFile* file, stream::StreamWriter& writer)
			{
				WriteFileComment(file->Name(), writer);
				WString prefix = WriteFileBegin(file, file->Name(), writer);

				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Visitor Pattern Implementation");
				writer.WriteLine(L"***********************************************************************/");
				WriteVisitorImpl(file, prefix, writer);

				WriteFileEnd(file, writer);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				WriteTypeReflectionImplementation(file, L"\t\t\t", writer);
				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");
			}

/***********************************************************************
WriteVisitorHeaderFile
***********************************************************************/

			void WriteUtilityHeaderFile(AstDefFile* file, const WString& guardPostfix, const WString& nss, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteFileComment(file->Name(), writer);
				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#ifndef ");
					writer.WriteLine(file->headerGuard + L"_AST_" + guardPostfix);
					writer.WriteString(L"#define ");
					writer.WriteLine(file->headerGuard + L"_AST_" + guardPostfix);
				}
				else
				{
					writer.WriteLine(L"#pragma once");
				}
				writer.WriteLine(L"");
				WString prefix = WriteFileBegin(file, file->Name(), writer);
				writer.WriteLine(prefix + L"namespace " + nss);
				writer.WriteLine(prefix + L"{");
				prefix += L"\t";

				callback(prefix);

				prefix = prefix.Left(prefix.Length() - 1);
				writer.WriteLine(prefix + L"}");
				WriteFileEnd(file, writer);

				if (file->headerGuard != L"")
				{
					writer.WriteString(L"#endif");
				}
			}

			void WriteVisitorHeaderFile(AstDefFile* file, const WString& visitorName, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteUtilityHeaderFile(file, wupper(visitorName) + L"VISITOR", wlower(visitorName) + L"_visitor", writer, callback);
			}

/***********************************************************************
WriteVisitorCppFile
***********************************************************************/

			void WriteUtilityCppFile(AstDefFile* file, const WString& fileNamePostfix, const WString& nss, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteFileComment(file->Name(), writer);
				WString prefix = WriteFileBegin(file, file->Name() + L"_" + fileNamePostfix, writer);
				writer.WriteLine(prefix + L"namespace " + nss);
				writer.WriteLine(prefix + L"{");
				prefix += L"\t";

				callback(prefix);

				prefix = prefix.Left(prefix.Length() - 1);
				writer.WriteLine(prefix + L"}");
				WriteFileEnd(file, writer);
			}

			void WriteVisitorCppFile(AstDefFile* file, const WString& visitorName, stream::StreamWriter& writer, Func<void(const WString&)> callback)
			{
				WriteUtilityCppFile(file, visitorName, wlower(visitorName) + L"_visitor", writer, callback);
			}

/***********************************************************************
WriteAstFiles
***********************************************************************/

			Ptr<CppAstGenOutput> WriteAstFiles(AstDefFile* file, collections::Dictionary<WString, WString>& files)
			{
				auto output = MakePtr<CppAstGenOutput>();
				output->astH = file->Owner()->name + file->Name() + L".h";
				output->astCpp = file->Owner()->name + file->Name() + L".cpp";
				output->builderH = file->Owner()->name + file->Name() + L"_Builder.h";
				output->builderCpp = file->Owner()->name + file->Name() + L"_Builder.cpp";
				output->emptyH = file->Owner()->name + file->Name() + L"_Empty.h";
				output->emptyCpp = file->Owner()->name + file->Name() + L"_Empty.cpp";
				output->copyH = file->Owner()->name + file->Name() + L"_Copy.h";
				output->copyCpp = file->Owner()->name + file->Name() + L"_Copy.cpp";
				output->traverseH = file->Owner()->name + file->Name() + L"_Traverse.h";
				output->traverseCpp = file->Owner()->name + file->Name() + L"_Traverse.cpp";
				output->jsonH = file->Owner()->name + file->Name() + L"_Json.h";
				output->jsonCpp = file->Owner()->name + file->Name() + L"_Json.cpp";

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteAstHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteAstCppFile(file, writer);
					});

					files.Add(output->astH, fileH);
					files.Add(output->astCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteAstBuilderHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteAstBuilderCppFile(file, writer);
					});

					files.Add(output->builderH, fileH);
					files.Add(output->builderCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteEmptyVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteEmptyVisitorCppFile(file, writer);
					});

					files.Add(output->emptyH, fileH);
					files.Add(output->emptyCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteCopyVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteCopyVisitorCppFile(file, writer);
					});

					files.Add(output->copyH, fileH);
					files.Add(output->copyCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteTraverseVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteTraverseVisitorCppFile(file, writer);
					});

					files.Add(output->traverseH, fileH);
					files.Add(output->traverseCpp, fileCpp);
				}

				{
					WString fileH = GenerateToStream([&](StreamWriter& writer)
					{
						WriteJsonVisitorHeaderFile(file, writer);
					});

					WString fileCpp = GenerateToStream([&](StreamWriter& writer)
					{
						WriteJsonVisitorCppFile(file, writer);
					});

					files.Add(output->jsonH, fileH);
					files.Add(output->jsonCpp, fileCpp);
				}
				return output;
			}
		}
	}
}