#include "ParserCppGen.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			using namespace collections;
			using namespace stream;

/***********************************************************************
GenerateParserFileNames
***********************************************************************/

			Ptr<CppParserGenOutput> GenerateParserFileNames(ParserSymbolManager& manager)
			{
				auto parserOutput = MakePtr<CppParserGenOutput>();
				parserOutput->assemblyH = manager.name + L"_Assembler.h";
				parserOutput->assemblyCpp = manager.name + L"_Assembler.cpp";
				parserOutput->lexerH = manager.name + L"_Lexer.h";
				parserOutput->lexerCpp = manager.name + L"_Lexer.cpp";
				return parserOutput;
			}

/***********************************************************************
WriteCppStringBody
***********************************************************************/

			void WriteCppStringBody(const WString& body, stream::StreamWriter& writer)
			{
				for (vint i = 0; i < body.Length(); i++)
				{
					auto c = body[i];
					switch (c)
					{
					case L'\t':
						writer.WriteString(L"\\t");
						break;
					case L'\r':
						writer.WriteString(L"\\r");
						break;
					case L'\n':
						writer.WriteString(L"\\n");
						break;
					case L'\\':
						writer.WriteString(L"\\\\");
						break;
					case L'\"':
						writer.WriteString(L"\\\"");
						break;
					case L'\'':
						writer.WriteString(L"\\\'");
						break;
					default:
						writer.WriteChar(c);
					}
				}
			}

/***********************************************************************
Utility
***********************************************************************/

			void WriteFileComment(const WString& name, stream::StreamWriter& writer)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"This file is generated by: Vczh Parser Generator");
				writer.WriteLine(L"From parser definition:" + name);
				writer.WriteLine(L"Licensed under https://github.com/vczh-libraries/License");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
			}

			WString WriteNssBegin(collections::List<WString>& cppNss, stream::StreamWriter& writer)
			{
				WString prefix;
				for (auto ns : cppNss)
				{
					writer.WriteLine(prefix + L"namespace " + ns);
					writer.WriteLine(prefix + L"{");
					prefix += L"\t";
				}
				return prefix;
			}

			void WriteNssEnd(collections::List<WString>& cppNss, stream::StreamWriter& writer)
			{
				vint counter = cppNss.Count();
				for (auto ns : cppNss)
				{
					counter--;
					for (vint i = 0; i < counter; i++) writer.WriteChar(L'\t');
					writer.WriteLine(L"}");
				}
			}

			extern void WriteLoadDataFunctionHeader(const WString& prefix, const WString& functionName, stream::StreamWriter& writer)
			{
				writer.WriteLine(prefix + L"extern void " + functionName + L"(vl::stream::IStream& outputStream);");
			}

			extern void WriteLoadDataFunctionCpp(const WString& prefix, const WString& functionName, stream::MemoryStream& rawData, bool compressData, stream::StreamWriter& writer)
			{
				MemoryStream compressedData;
				if (compressData)
				{
					CompressStream(rawData, compressedData);
				}
				else
				{
					CopyStream(rawData, compressedData);
				}
				compressedData.SeekFromBegin(0);

				vint lengthBeforeCompressing = (vint)rawData.Size();
				vint length = (vint)compressedData.Size();
				const vint block = 256;
				vint remain = length % block;
				vint solidRows = length / block;
				vint rows = solidRows + (remain ? 1 : 0);

				writer.WriteLine(prefix + L"void " + functionName + L"(vl::stream::IStream& outputStream)");
				writer.WriteLine(prefix + L"{");
				writer.WriteLine(prefix + L"\tstatic const vl::vint dataLength = " + itow(length) + L"; // " + itow(lengthBeforeCompressing) + L" bytes before compressing");
				writer.WriteLine(prefix + L"\tstatic const vl::vint dataBlock = " + itow(block) + L";");
				writer.WriteLine(prefix + L"\tstatic const vl::vint dataRemain = " + itow(remain) + L";");
				writer.WriteLine(prefix + L"\tstatic const vl::vint dataSolidRows = " + itow(solidRows) + L";");
				writer.WriteLine(prefix + L"\tstatic const vl::vint dataRows = " + itow(rows) + L";");
				writer.WriteLine(prefix + L"\tstatic const char* compressed[] = {");
				{
					char buffer[block];
					const wchar_t* hex = L"0123456789ABCDEF";
					for (vint i = 0; i < rows; i++)
					{
						vint size = i == solidRows ? remain : block;
						vint read = compressedData.Read(buffer, size);
						CHECK_ERROR(size == read, L"vl::glr::parsergen::WriteLexerCppFile()#Failed to read compressed data.");
						writer.WriteString(prefix + L"\t\t\"");
						for (vint j = 0; j < size; j++)
						{
							vuint8_t byte = buffer[j];
							writer.WriteString(L"\\x");
							writer.WriteChar(hex[byte / 16]);
							writer.WriteChar(hex[byte % 16]);
						}
						writer.WriteLine(L"\",");
					}
				}
				writer.WriteLine(prefix + L"\t};");
				writer.WriteLine(prefix + L"\tvl::glr::DecompressSerializedData(compressed, " + WString(compressData ? L"true" : L"false") + L", dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);");
				writer.WriteLine(prefix + L"}");
			}
		}
	}
}