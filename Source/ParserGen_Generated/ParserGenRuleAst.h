/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST

#include "../AstBase.h"
#include "../SyntaxBase.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class GlrAlternativeSyntax;
			class GlrAssignment;
			class GlrClause;
			class GlrCreateClause;
			class GlrLoopSyntax;
			class GlrOptionalSyntax;
			class GlrPartialClause;
			class GlrRefSyntax;
			class GlrReuseClause;
			class GlrRule;
			class GlrSequenceSyntax;
			class GlrSyntax;
			class GlrSyntaxFile;
			class GlrUseSyntax;

			enum class GlrRefType
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				Id = 0,
				Literal = 1,
				ConditionalLiteral = 2,
			};

			enum class GlrOptionalPriority
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				Equal = 0,
				PreferTake = 1,
				PreferSkip = 2,
			};

			enum class GlrAssignmentType
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				Strong = 0,
				Weak = 1,
			};

			class GlrSyntax abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrSyntax>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrRefSyntax* node) = 0;
					virtual void Visit(GlrUseSyntax* node) = 0;
					virtual void Visit(GlrLoopSyntax* node) = 0;
					virtual void Visit(GlrOptionalSyntax* node) = 0;
					virtual void Visit(GlrSequenceSyntax* node) = 0;
					virtual void Visit(GlrAlternativeSyntax* node) = 0;
				};

				virtual void Accept(GlrSyntax::IVisitor* visitor) = 0;

			};

			class GlrRefSyntax : public GlrSyntax, vl::reflection::Description<GlrRefSyntax>
			{
			public:
				GlrRefType refType = GlrRefType::UNDEFINED_ENUM_ITEM_VALUE;
				vl::glr::ParsingToken literal;
				vl::glr::ParsingToken field;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrUseSyntax : public GlrSyntax, vl::reflection::Description<GlrUseSyntax>
			{
			public:
				vl::glr::ParsingToken name;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrLoopSyntax : public GlrSyntax, vl::reflection::Description<GlrLoopSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> syntax;
				vl::Ptr<GlrSyntax> delimiter;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrOptionalSyntax : public GlrSyntax, vl::reflection::Description<GlrOptionalSyntax>
			{
			public:
				GlrOptionalPriority priority = GlrOptionalPriority::UNDEFINED_ENUM_ITEM_VALUE;
				vl::Ptr<GlrSyntax> syntax;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrSequenceSyntax : public GlrSyntax, vl::reflection::Description<GlrSequenceSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> first;
				vl::Ptr<GlrSyntax> second;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrAlternativeSyntax : public GlrSyntax, vl::reflection::Description<GlrAlternativeSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> first;
				vl::Ptr<GlrSyntax> second;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrClause abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrClause>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrCreateClause* node) = 0;
					virtual void Visit(GlrPartialClause* node) = 0;
					virtual void Visit(GlrReuseClause* node) = 0;
				};

				virtual void Accept(GlrClause::IVisitor* visitor) = 0;

			};

			class GlrAssignment : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrAssignment>
			{
			public:
				GlrAssignmentType type = GlrAssignmentType::UNDEFINED_ENUM_ITEM_VALUE;
				vl::glr::ParsingToken field;
				vl::glr::ParsingToken value;
			};

			class GlrCreateClause : public GlrClause, vl::reflection::Description<GlrCreateClause>
			{
			public:
				vl::glr::ParsingToken type;
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrPartialClause : public GlrClause, vl::reflection::Description<GlrPartialClause>
			{
			public:
				vl::glr::ParsingToken type;
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrReuseClause : public GlrClause, vl::reflection::Description<GlrReuseClause>
			{
			public:
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrRule : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrRule>
			{
			public:
				vl::glr::ParsingToken name;
				vl::collections::List<vl::Ptr<GlrClause>> clauses;
			};

			class GlrSyntaxFile : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrSyntaxFile>
			{
			public:
				vl::collections::List<vl::Ptr<GlrRule>> rules;
			};
		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntax::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRefType)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRefSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrUseSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrLoopSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrOptionalPriority)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrOptionalSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSequenceSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAlternativeSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAssignmentType)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAssignment)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrCreateClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrPartialClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrReuseClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRule)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntaxFile)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrSyntax::IVisitor)
				void Visit(vl::glr::parsergen::GlrRefSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrUseSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrLoopSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrOptionalSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrSequenceSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrAlternativeSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrSyntax::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrClause::IVisitor)
				void Visit(vl::glr::parsergen::GlrCreateClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrPartialClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrReuseClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrClause::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool ParserGenRuleAstLoadTypes();
		}
	}
}
#endif