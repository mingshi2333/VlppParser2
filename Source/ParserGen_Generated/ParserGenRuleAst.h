/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST

#include "../AstBase.h"
#include "../SyntaxBase.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class GlrAssignment;
			class GlrClause;
			class GlrCreateClause;
			class GlrLiteralClause;
			class GlrLoopClause;
			class GlrOptionalClause;
			class GlrRefClause;
			class GlrRule;
			class GlrSequenceClause;
			class GlrSyntaxFile;
			class GlrUseClause;
			class Glr_ReuseClause;

			class GlrClause abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrClause>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrRefClause* node) = 0;
					virtual void Visit(GlrLiteralClause* node) = 0;
					virtual void Visit(GlrUseClause* node) = 0;
					virtual void Visit(GlrLoopClause* node) = 0;
					virtual void Visit(GlrOptionalClause* node) = 0;
					virtual void Visit(GlrSequenceClause* node) = 0;
					virtual void Visit(GlrCreateClause* node) = 0;
					virtual void Visit(Glr_ReuseClause* node) = 0;
				};

				virtual void Accept(GlrClause::IVisitor* visitor) = 0;

			};

			class GlrRefClause : public GlrClause, vl::reflection::Description<GlrRefClause>
			{
			public:
				vl::glr::ParsingToken name;
				vl::glr::ParsingToken field;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrLiteralClause : public GlrClause, vl::reflection::Description<GlrLiteralClause>
			{
			public:
				vl::glr::ParsingToken value;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrUseClause : public GlrClause, vl::reflection::Description<GlrUseClause>
			{
			public:
				vl::Ptr<GlrClause> clause;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrLoopClause : public GlrClause, vl::reflection::Description<GlrLoopClause>
			{
			public:
				vl::Ptr<GlrClause> clause;
				vl::Ptr<GlrClause> delimiter;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrOptionalClause : public GlrClause, vl::reflection::Description<GlrOptionalClause>
			{
			public:
				vl::Ptr<GlrClause> clause;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrSequenceClause : public GlrClause, vl::reflection::Description<GlrSequenceClause>
			{
			public:
				vl::Ptr<GlrClause> first;
				vl::Ptr<GlrClause> second;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrAssignment : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrAssignment>
			{
			public:
				vl::glr::ParsingToken field;
				vl::glr::ParsingToken value;
			};

			class GlrCreateClause : public GlrClause, vl::reflection::Description<GlrCreateClause>
			{
			public:
				vl::glr::ParsingToken type;
				vl::Ptr<GlrClause> clause;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class Glr_ReuseClause : public GlrClause, vl::reflection::Description<Glr_ReuseClause>
			{
			public:
				vl::Ptr<GlrClause> clause;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrRule : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrRule>
			{
			public:
				vl::glr::ParsingToken name;
				vl::collections::List<vl::Ptr<GlrClause>> clauses;
			};

			class GlrSyntaxFile : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrSyntaxFile>
			{
			public:
				vl::collections::List<vl::Ptr<GlrRule>> rules;
			};
		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRefClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrLiteralClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrUseClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrLoopClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrOptionalClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSequenceClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAssignment)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrCreateClause)
			DECL_TYPE_INFO(vl::glr::parsergen::Glr_ReuseClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRule)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntaxFile)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrClause::IVisitor)
				void Visit(vl::glr::parsergen::GlrRefClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrLiteralClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrUseClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrLoopClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrOptionalClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrSequenceClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrCreateClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::Glr_ReuseClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrClause::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool GlrRuleAstLoadTypes();
		}
	}
}
#endif