/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "ParserGenRuleAst_Builder.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{

/***********************************************************************
AlternativeSyntaxBuilder
***********************************************************************/

				AlternativeSyntaxBuilder& AlternativeSyntaxBuilder::first(const vl::Ptr<GlrSyntax>& value)
				{
					node->first = value;
					return *this;
				}

				AlternativeSyntaxBuilder& AlternativeSyntaxBuilder::second(const vl::Ptr<GlrSyntax>& value)
				{
					node->second = value;
					return *this;
				}

/***********************************************************************
AssignmentBuilder
***********************************************************************/

				AssignmentBuilder& AssignmentBuilder::field(const vl::WString& value)
				{
					node->field.value = value;
					return *this;
				}

				AssignmentBuilder& AssignmentBuilder::value(const vl::WString& value)
				{
					node->value.value = value;
					return *this;
				}

/***********************************************************************
CreateClauseBuilder
***********************************************************************/

				CreateClauseBuilder& CreateClauseBuilder::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				CreateClauseBuilder& CreateClauseBuilder::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

				CreateClauseBuilder& CreateClauseBuilder::type(const vl::WString& value)
				{
					node->type.value = value;
					return *this;
				}

/***********************************************************************
LiteralSyntaxBuilder
***********************************************************************/

				LiteralSyntaxBuilder& LiteralSyntaxBuilder::value(const vl::WString& value)
				{
					node->value.value = value;
					return *this;
				}

/***********************************************************************
LoopSyntaxBuilder
***********************************************************************/

				LoopSyntaxBuilder& LoopSyntaxBuilder::delimiter(const vl::Ptr<GlrSyntax>& value)
				{
					node->delimiter = value;
					return *this;
				}

				LoopSyntaxBuilder& LoopSyntaxBuilder::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
OptionalSyntaxBuilder
***********************************************************************/

				OptionalSyntaxBuilder& OptionalSyntaxBuilder::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
PartialClauseBuilder
***********************************************************************/

				PartialClauseBuilder& PartialClauseBuilder::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				PartialClauseBuilder& PartialClauseBuilder::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

				PartialClauseBuilder& PartialClauseBuilder::type(const vl::WString& value)
				{
					node->type.value = value;
					return *this;
				}

/***********************************************************************
RefSyntaxBuilder
***********************************************************************/

				RefSyntaxBuilder& RefSyntaxBuilder::field(const vl::WString& value)
				{
					node->field.value = value;
					return *this;
				}

				RefSyntaxBuilder& RefSyntaxBuilder::name(const vl::WString& value)
				{
					node->name.value = value;
					return *this;
				}

/***********************************************************************
ReuseClauseBuilder
***********************************************************************/

				ReuseClauseBuilder& ReuseClauseBuilder::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				ReuseClauseBuilder& ReuseClauseBuilder::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
RuleBuilder
***********************************************************************/

				RuleBuilder& RuleBuilder::clauses(const vl::Ptr<GlrClause>& value)
				{
					node->clauses.Add(value);
					return *this;
				}

				RuleBuilder& RuleBuilder::name(const vl::WString& value)
				{
					node->name.value = value;
					return *this;
				}

/***********************************************************************
SequenceSyntaxBuilder
***********************************************************************/

				SequenceSyntaxBuilder& SequenceSyntaxBuilder::first(const vl::Ptr<GlrSyntax>& value)
				{
					node->first = value;
					return *this;
				}

				SequenceSyntaxBuilder& SequenceSyntaxBuilder::second(const vl::Ptr<GlrSyntax>& value)
				{
					node->second = value;
					return *this;
				}

/***********************************************************************
SyntaxFileBuilder
***********************************************************************/

				SyntaxFileBuilder& SyntaxFileBuilder::rules(const vl::Ptr<GlrRule>& value)
				{
					node->rules.Add(value);
					return *this;
				}

/***********************************************************************
UseSyntaxBuilder
***********************************************************************/

				UseSyntaxBuilder& UseSyntaxBuilder::name(const vl::WString& value)
				{
					node->name.value = value;
					return *this;
				}
			}
		}
	}
}
