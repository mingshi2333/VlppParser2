/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "ParserGenRuleAst_Builder.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{

/***********************************************************************
MakeAlternativeSyntax
***********************************************************************/

				MakeAlternativeSyntax& MakeAlternativeSyntax::first(const vl::Ptr<GlrSyntax>& value)
				{
					node->first = value;
					return *this;
				}

				MakeAlternativeSyntax& MakeAlternativeSyntax::second(const vl::Ptr<GlrSyntax>& value)
				{
					node->second = value;
					return *this;
				}

/***********************************************************************
MakeAssignment
***********************************************************************/

				MakeAssignment& MakeAssignment::field(const vl::WString& value)
				{
					node->field.value = value;
					return *this;
				}

				MakeAssignment& MakeAssignment::value(const vl::WString& value)
				{
					node->value.value = value;
					return *this;
				}

/***********************************************************************
MakeCreateClause
***********************************************************************/

				MakeCreateClause& MakeCreateClause::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				MakeCreateClause& MakeCreateClause::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

				MakeCreateClause& MakeCreateClause::type(const vl::WString& value)
				{
					node->type.value = value;
					return *this;
				}

/***********************************************************************
MakeLoopSyntax
***********************************************************************/

				MakeLoopSyntax& MakeLoopSyntax::delimiter(const vl::Ptr<GlrSyntax>& value)
				{
					node->delimiter = value;
					return *this;
				}

				MakeLoopSyntax& MakeLoopSyntax::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
MakeOptionalSyntax
***********************************************************************/

				MakeOptionalSyntax& MakeOptionalSyntax::priority(GlrOptionalPriority value)
				{
					node->priority = value;
					return *this;
				}

				MakeOptionalSyntax& MakeOptionalSyntax::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
MakePartialClause
***********************************************************************/

				MakePartialClause& MakePartialClause::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				MakePartialClause& MakePartialClause::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

				MakePartialClause& MakePartialClause::type(const vl::WString& value)
				{
					node->type.value = value;
					return *this;
				}

/***********************************************************************
MakeRefSyntax
***********************************************************************/

				MakeRefSyntax& MakeRefSyntax::field(const vl::WString& value)
				{
					node->field.value = value;
					return *this;
				}

				MakeRefSyntax& MakeRefSyntax::literal(const vl::WString& value)
				{
					node->literal.value = value;
					return *this;
				}

				MakeRefSyntax& MakeRefSyntax::refType(GlrRefType value)
				{
					node->refType = value;
					return *this;
				}

/***********************************************************************
MakeReuseClause
***********************************************************************/

				MakeReuseClause& MakeReuseClause::assignments(const vl::Ptr<GlrAssignment>& value)
				{
					node->assignments.Add(value);
					return *this;
				}

				MakeReuseClause& MakeReuseClause::syntax(const vl::Ptr<GlrSyntax>& value)
				{
					node->syntax = value;
					return *this;
				}

/***********************************************************************
MakeRule
***********************************************************************/

				MakeRule& MakeRule::clauses(const vl::Ptr<GlrClause>& value)
				{
					node->clauses.Add(value);
					return *this;
				}

				MakeRule& MakeRule::name(const vl::WString& value)
				{
					node->name.value = value;
					return *this;
				}

/***********************************************************************
MakeSequenceSyntax
***********************************************************************/

				MakeSequenceSyntax& MakeSequenceSyntax::first(const vl::Ptr<GlrSyntax>& value)
				{
					node->first = value;
					return *this;
				}

				MakeSequenceSyntax& MakeSequenceSyntax::second(const vl::Ptr<GlrSyntax>& value)
				{
					node->second = value;
					return *this;
				}

/***********************************************************************
MakeSyntaxFile
***********************************************************************/

				MakeSyntaxFile& MakeSyntaxFile::rules(const vl::Ptr<GlrRule>& value)
				{
					node->rules.Add(value);
					return *this;
				}

/***********************************************************************
MakeUseSyntax
***********************************************************************/

				MakeUseSyntax& MakeUseSyntax::name(const vl::WString& value)
				{
					node->name.value = value;
					return *this;
				}
			}
		}
	}
}
