/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER

#include "ParserGenRuleAst.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{
				class AlternativeSyntaxBuilder
				{
				private:
					GlrAlternativeSyntax* node;
				public:
					AlternativeSyntaxBuilder(GlrAlternativeSyntax* _node) : node(_node) {}
					AlternativeSyntaxBuilder& first(const vl::Ptr<GlrSyntax>& value);
					AlternativeSyntaxBuilder& second(const vl::Ptr<GlrSyntax>& value);
				};

				class AssignmentBuilder
				{
				private:
					GlrAssignment* node;
				public:
					AssignmentBuilder(GlrAssignment* _node) : node(_node) {}
					AssignmentBuilder& field(const vl::WString& value);
					AssignmentBuilder& value(const vl::WString& value);
				};

				class CreateClauseBuilder
				{
				private:
					GlrCreateClause* node;
				public:
					CreateClauseBuilder(GlrCreateClause* _node) : node(_node) {}
					CreateClauseBuilder& assignments(const vl::Ptr<GlrAssignment>& value);
					CreateClauseBuilder& syntax(const vl::Ptr<GlrSyntax>& value);
					CreateClauseBuilder& type(const vl::WString& value);
				};

				class LiteralSyntaxBuilder
				{
				private:
					GlrLiteralSyntax* node;
				public:
					LiteralSyntaxBuilder(GlrLiteralSyntax* _node) : node(_node) {}
					LiteralSyntaxBuilder& value(const vl::WString& value);
				};

				class LoopSyntaxBuilder
				{
				private:
					GlrLoopSyntax* node;
				public:
					LoopSyntaxBuilder(GlrLoopSyntax* _node) : node(_node) {}
					LoopSyntaxBuilder& Syntax(const vl::Ptr<GlrSyntax>& value);
					LoopSyntaxBuilder& delimiter(const vl::Ptr<GlrSyntax>& value);
				};

				class OptionalSyntaxBuilder
				{
				private:
					GlrOptionalSyntax* node;
				public:
					OptionalSyntaxBuilder(GlrOptionalSyntax* _node) : node(_node) {}
					OptionalSyntaxBuilder& Syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class PartialClauseBuilder
				{
				private:
					GlrPartialClause* node;
				public:
					PartialClauseBuilder(GlrPartialClause* _node) : node(_node) {}
					PartialClauseBuilder& assignments(const vl::Ptr<GlrAssignment>& value);
					PartialClauseBuilder& syntax(const vl::Ptr<GlrSyntax>& value);
					PartialClauseBuilder& type(const vl::WString& value);
				};

				class RefSyntaxBuilder
				{
				private:
					GlrRefSyntax* node;
				public:
					RefSyntaxBuilder(GlrRefSyntax* _node) : node(_node) {}
					RefSyntaxBuilder& field(const vl::WString& value);
					RefSyntaxBuilder& name(const vl::WString& value);
				};

				class RuleBuilder
				{
				private:
					GlrRule* node;
				public:
					RuleBuilder(GlrRule* _node) : node(_node) {}
					RuleBuilder& clauses(const vl::Ptr<GlrClause>& value);
					RuleBuilder& name(const vl::WString& value);
				};

				class SequenceSyntaxBuilder
				{
				private:
					GlrSequenceSyntax* node;
				public:
					SequenceSyntaxBuilder(GlrSequenceSyntax* _node) : node(_node) {}
					SequenceSyntaxBuilder& first(const vl::Ptr<GlrSyntax>& value);
					SequenceSyntaxBuilder& second(const vl::Ptr<GlrSyntax>& value);
				};

				class SyntaxFileBuilder
				{
				private:
					GlrSyntaxFile* node;
				public:
					SyntaxFileBuilder(GlrSyntaxFile* _node) : node(_node) {}
					SyntaxFileBuilder& rules(const vl::Ptr<GlrRule>& value);
				};

				class UseSyntaxBuilder
				{
				private:
					GlrUseSyntax* node;
				public:
					UseSyntaxBuilder(GlrUseSyntax* _node) : node(_node) {}
					UseSyntaxBuilder& Syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class _ReuseClauseBuilder
				{
				private:
					Glr_ReuseClause* node;
				public:
					_ReuseClauseBuilder(Glr_ReuseClause* _node) : node(_node) {}
					_ReuseClauseBuilder& assignments(const vl::Ptr<GlrAssignment>& value);
					_ReuseClauseBuilder& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				using MakeAlternativeSyntax = vl::glr::ParsingAstBuilder<GlrAlternativeSyntax, AlternativeSyntaxBuilder>;
				using MakeAssignment = vl::glr::ParsingAstBuilder<GlrAssignment, AssignmentBuilder>;
				using MakeCreateClause = vl::glr::ParsingAstBuilder<GlrCreateClause, CreateClauseBuilder>;
				using MakeLiteralSyntax = vl::glr::ParsingAstBuilder<GlrLiteralSyntax, LiteralSyntaxBuilder>;
				using MakeLoopSyntax = vl::glr::ParsingAstBuilder<GlrLoopSyntax, LoopSyntaxBuilder>;
				using MakeOptionalSyntax = vl::glr::ParsingAstBuilder<GlrOptionalSyntax, OptionalSyntaxBuilder>;
				using MakePartialClause = vl::glr::ParsingAstBuilder<GlrPartialClause, PartialClauseBuilder>;
				using MakeRefSyntax = vl::glr::ParsingAstBuilder<GlrRefSyntax, RefSyntaxBuilder>;
				using MakeRule = vl::glr::ParsingAstBuilder<GlrRule, RuleBuilder>;
				using MakeSequenceSyntax = vl::glr::ParsingAstBuilder<GlrSequenceSyntax, SequenceSyntaxBuilder>;
				using MakeSyntaxFile = vl::glr::ParsingAstBuilder<GlrSyntaxFile, SyntaxFileBuilder>;
				using MakeUseSyntax = vl::glr::ParsingAstBuilder<GlrUseSyntax, UseSyntaxBuilder>;
				using Make_ReuseClause = vl::glr::ParsingAstBuilder<Glr_ReuseClause, _ReuseClauseBuilder>;
			}
		}
	}
}
#endif