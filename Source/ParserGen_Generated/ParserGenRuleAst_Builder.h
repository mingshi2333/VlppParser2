/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER

#include "ParserGenRuleAst.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{
				class MakeAlternativeSyntax : public vl::glr::ParsingAstBuilder<GlrAlternativeSyntax>
				{
				public:
					MakeAlternativeSyntax& first(const vl::Ptr<GlrSyntax>& value);
					MakeAlternativeSyntax& second(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeAssignment : public vl::glr::ParsingAstBuilder<GlrAssignment>
				{
				public:
					MakeAssignment& field(const vl::WString& value);
					MakeAssignment& value(const vl::WString& value);
				};

				class MakeCreateClause : public vl::glr::ParsingAstBuilder<GlrCreateClause>
				{
				public:
					MakeCreateClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakeCreateClause& syntax(const vl::Ptr<GlrSyntax>& value);
					MakeCreateClause& type(const vl::WString& value);
				};

				class MakeLiteralSyntax : public vl::glr::ParsingAstBuilder<GlrLiteralSyntax>
				{
				public:
					MakeLiteralSyntax& value(const vl::WString& value);
				};

				class MakeLoopSyntax : public vl::glr::ParsingAstBuilder<GlrLoopSyntax>
				{
				public:
					MakeLoopSyntax& delimiter(const vl::Ptr<GlrSyntax>& value);
					MakeLoopSyntax& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeOptionalSyntax : public vl::glr::ParsingAstBuilder<GlrOptionalSyntax>
				{
				public:
					MakeOptionalSyntax& priority(GlrOptionalPriority value);
					MakeOptionalSyntax& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakePartialClause : public vl::glr::ParsingAstBuilder<GlrPartialClause>
				{
				public:
					MakePartialClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakePartialClause& syntax(const vl::Ptr<GlrSyntax>& value);
					MakePartialClause& type(const vl::WString& value);
				};

				class MakeRefSyntax : public vl::glr::ParsingAstBuilder<GlrRefSyntax>
				{
				public:
					MakeRefSyntax& field(const vl::WString& value);
					MakeRefSyntax& name(const vl::WString& value);
				};

				class MakeReuseClause : public vl::glr::ParsingAstBuilder<GlrReuseClause>
				{
				public:
					MakeReuseClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakeReuseClause& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeRule : public vl::glr::ParsingAstBuilder<GlrRule>
				{
				public:
					MakeRule& clauses(const vl::Ptr<GlrClause>& value);
					MakeRule& name(const vl::WString& value);
				};

				class MakeSequenceSyntax : public vl::glr::ParsingAstBuilder<GlrSequenceSyntax>
				{
				public:
					MakeSequenceSyntax& first(const vl::Ptr<GlrSyntax>& value);
					MakeSequenceSyntax& second(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeSyntaxFile : public vl::glr::ParsingAstBuilder<GlrSyntaxFile>
				{
				public:
					MakeSyntaxFile& rules(const vl::Ptr<GlrRule>& value);
				};

				class MakeUseSyntax : public vl::glr::ParsingAstBuilder<GlrUseSyntax>
				{
				public:
					MakeUseSyntax& name(const vl::WString& value);
				};

			}
		}
	}
}
#endif