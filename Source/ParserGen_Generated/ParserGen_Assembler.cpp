/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "ParserGen_Assembler.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{

/***********************************************************************
ParserGenAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

			vl::Ptr<vl::glr::ParsingAstBase> ParserGenAstInsReceiver::CreateAstNode(vl::vint32_t type)
			{
				switch((ParserGenClasses)type)
				{
				case ParserGenClasses::AlternativeSyntax:
					return new vl::glr::parsergen::GlrAlternativeSyntax();
				case ParserGenClasses::Assignment:
					return new vl::glr::parsergen::GlrAssignment();
				case ParserGenClasses::AstFile:
					return new vl::glr::parsergen::GlrAstFile();
				case ParserGenClasses::Class:
					return new vl::glr::parsergen::GlrClass();
				case ParserGenClasses::ClassProp:
					return new vl::glr::parsergen::GlrClassProp();
				case ParserGenClasses::Clause:
					throw vl::glr::AstInsException(L"Unable to create abstract class \"vl::glr::parsergen::GlrClause\".", vl::glr::AstInsErrorType::UnknownType, type);
				case ParserGenClasses::CreateClause:
					return new vl::glr::parsergen::GlrCreateClause();
				case ParserGenClasses::Enum:
					return new vl::glr::parsergen::GlrEnum();
				case ParserGenClasses::EnumItem:
					return new vl::glr::parsergen::GlrEnumItem();
				case ParserGenClasses::LiteralSyntax:
					return new vl::glr::parsergen::GlrLiteralSyntax();
				case ParserGenClasses::LoopSyntax:
					return new vl::glr::parsergen::GlrLoopSyntax();
				case ParserGenClasses::OptionalSyntax:
					return new vl::glr::parsergen::GlrOptionalSyntax();
				case ParserGenClasses::PartialClause:
					return new vl::glr::parsergen::GlrPartialClause();
				case ParserGenClasses::RefSyntax:
					return new vl::glr::parsergen::GlrRefSyntax();
				case ParserGenClasses::ReuseClause:
					return new vl::glr::parsergen::GlrReuseClause();
				case ParserGenClasses::Rule:
					return new vl::glr::parsergen::GlrRule();
				case ParserGenClasses::SequenceSyntax:
					return new vl::glr::parsergen::GlrSequenceSyntax();
				case ParserGenClasses::Syntax:
					throw vl::glr::AstInsException(L"Unable to create abstract class \"vl::glr::parsergen::GlrSyntax\".", vl::glr::AstInsErrorType::UnknownType, type);
				case ParserGenClasses::SyntaxFile:
					return new vl::glr::parsergen::GlrSyntaxFile();
				case ParserGenClasses::Type:
					throw vl::glr::AstInsException(L"Unable to create abstract class \"vl::glr::parsergen::GlrType\".", vl::glr::AstInsErrorType::UnknownType, type);
				case ParserGenClasses::UseSyntax:
					return new vl::glr::parsergen::GlrUseSyntax();
				default:
					throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
				}
			}

			void ParserGenAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
			{
				switch((ParserGenFields)field)
				{
				case ParserGenFields::AlternativeSyntax_first:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrAlternativeSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::first\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->first) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::first\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::first\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->first = typedValue;
					}
					break;
				case ParserGenFields::AlternativeSyntax_second:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrAlternativeSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::second\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->second) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::second\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::second\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->second = typedValue;
					}
					break;
				case ParserGenFields::AstFile_types:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrAstFile*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAstFile::types\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrType>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAstFile::types\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->types.Add(typedValue);
					}
					break;
				case ParserGenFields::Class_props:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClass*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::props\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrClassProp>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::props\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->props.Add(typedValue);
					}
					break;
				case ParserGenFields::CreateClause_assignments:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrCreateClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::assignments\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrAssignment>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::assignments\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->assignments.Add(typedValue);
					}
					break;
				case ParserGenFields::CreateClause_syntax:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrCreateClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::syntax\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->syntax) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::syntax\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::syntax\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->syntax = typedValue;
					}
					break;
				case ParserGenFields::Enum_items:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrEnum*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnum::items\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrEnumItem>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnum::items\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->items.Add(typedValue);
					}
					break;
				case ParserGenFields::LoopSyntax_delimiter:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrLoopSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::delimiter\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->delimiter) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::delimiter\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::delimiter\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->delimiter = typedValue;
					}
					break;
				case ParserGenFields::LoopSyntax_syntax:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrLoopSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::syntax\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->syntax) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::syntax\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::syntax\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->syntax = typedValue;
					}
					break;
				case ParserGenFields::OptionalSyntax_syntax:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrOptionalSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::syntax\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->syntax) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::syntax\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::syntax\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->syntax = typedValue;
					}
					break;
				case ParserGenFields::PartialClause_assignments:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrPartialClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::assignments\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrAssignment>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::assignments\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->assignments.Add(typedValue);
					}
					break;
				case ParserGenFields::PartialClause_syntax:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrPartialClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::syntax\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->syntax) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::syntax\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::syntax\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->syntax = typedValue;
					}
					break;
				case ParserGenFields::ReuseClause_assignments:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrReuseClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::assignments\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrAssignment>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::assignments\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->assignments.Add(typedValue);
					}
					break;
				case ParserGenFields::ReuseClause_syntax:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrReuseClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::syntax\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->syntax) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::syntax\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::syntax\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->syntax = typedValue;
					}
					break;
				case ParserGenFields::Rule_clauses:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrRule*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::clauses\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrClause>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::clauses\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->clauses.Add(typedValue);
					}
					break;
				case ParserGenFields::SequenceSyntax_first:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrSequenceSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::first\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->first) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::first\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::first\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->first = typedValue;
					}
					break;
				case ParserGenFields::SequenceSyntax_second:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrSequenceSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::second\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->second) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::second\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrSyntax>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::second\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->second = typedValue;
					}
					break;
				case ParserGenFields::SyntaxFile_rules:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrSyntaxFile*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSyntaxFile::rules\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						auto typedValue = value.Cast<vl::glr::parsergen::GlrRule>();
						if (!typedValue) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSyntaxFile::rules\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
						typedObject->rules.Add(typedValue);
					}
					break;
				case ParserGenFields::Assignment_field:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::field\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Assignment_value:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::value\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_ambiguity:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::ambiguity\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_baseClass:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::baseClass\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_propType:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propType\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_propTypeName:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propTypeName\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_type:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::type\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::EnumItem_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnumItem::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LiteralSyntax_value:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLiteralSyntax::value\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::OptionalSyntax_priority:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::priority\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_type:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::type\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::RefSyntax_field:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::field\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::RefSyntax_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Rule_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Type_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrType::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::UseSyntax_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrUseSyntax::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				default:
					throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
				}
			}

			void ParserGenAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
			{
				switch((ParserGenFields)field)
				{
				case ParserGenFields::Assignment_field:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrAssignment*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::field\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->field.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::field\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->field, token);
					}
					break;
				case ParserGenFields::Assignment_value:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrAssignment*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->value.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->value, token);
					}
					break;
				case ParserGenFields::Class_baseClass:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClass*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::baseClass\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->baseClass.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::baseClass\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->baseClass, token);
					}
					break;
				case ParserGenFields::ClassProp_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClassProp*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::ClassProp_propTypeName:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClassProp*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propTypeName\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->propTypeName.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propTypeName\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->propTypeName, token);
					}
					break;
				case ParserGenFields::CreateClause_type:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrCreateClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::type\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->type.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::type\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->type, token);
					}
					break;
				case ParserGenFields::EnumItem_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrEnumItem*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnumItem::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnumItem::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::LiteralSyntax_value:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrLiteralSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLiteralSyntax::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->value.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLiteralSyntax::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->value, token);
					}
					break;
				case ParserGenFields::PartialClause_type:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrPartialClause*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::type\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->type.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::type\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->type, token);
					}
					break;
				case ParserGenFields::RefSyntax_field:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrRefSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::field\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->field.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::field\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->field, token);
					}
					break;
				case ParserGenFields::RefSyntax_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrRefSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::Rule_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrRule*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::Type_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrType*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrType::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrType::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::UseSyntax_name:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrUseSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrUseSyntax::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrUseSyntax::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						AssignToken(typedObject->name, token);
					}
					break;
				case ParserGenFields::AlternativeSyntax_first:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::first\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::AlternativeSyntax_second:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::second\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::AstFile_types:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAstFile::types\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_ambiguity:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::ambiguity\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_props:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::props\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_propType:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propType\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::assignments\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::syntax\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Enum_items:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnum::items\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LoopSyntax_delimiter:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::delimiter\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LoopSyntax_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::syntax\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::OptionalSyntax_priority:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::priority\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::OptionalSyntax_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::syntax\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::assignments\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::syntax\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ReuseClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::assignments\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ReuseClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::syntax\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Rule_clauses:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::clauses\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SequenceSyntax_first:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::first\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SequenceSyntax_second:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::second\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SyntaxFile_rules:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSyntaxFile::rules\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				default:
					throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
				}
			}

			void ParserGenAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
			{
				switch((ParserGenFields)field)
				{
				case ParserGenFields::Class_ambiguity:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClass*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::ambiguity\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->ambiguity == vl::glr::parsergen::GlrClassAmbiguity::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::ambiguity\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						typedObject->ambiguity = (vl::glr::parsergen::GlrClassAmbiguity)enumItem;
					}
					break;
				case ParserGenFields::ClassProp_propType:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrClassProp*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propType\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->propType == vl::glr::parsergen::GlrPropType::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propType\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						typedObject->propType = (vl::glr::parsergen::GlrPropType)enumItem;
					}
					break;
				case ParserGenFields::OptionalSyntax_priority:
					{
						auto typedObject = dynamic_cast<vl::glr::parsergen::GlrOptionalSyntax*>(object);
						if (!typedObject) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::priority\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
						if (typedObject->priority == vl::glr::parsergen::GlrOptionalPriority::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::priority\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
						typedObject->priority = (vl::glr::parsergen::GlrOptionalPriority)enumItem;
					}
					break;
				case ParserGenFields::AlternativeSyntax_first:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::first\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::AlternativeSyntax_second:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAlternativeSyntax::second\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Assignment_field:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::field\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Assignment_value:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAssignment::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::AstFile_types:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrAstFile::types\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_baseClass:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::baseClass\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Class_props:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClass::props\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ClassProp_propTypeName:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrClassProp::propTypeName\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::assignments\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::syntax\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::CreateClause_type:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrCreateClause::type\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Enum_items:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnum::items\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::EnumItem_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrEnumItem::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LiteralSyntax_value:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLiteralSyntax::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LoopSyntax_delimiter:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::delimiter\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::LoopSyntax_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrLoopSyntax::syntax\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::OptionalSyntax_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrOptionalSyntax::syntax\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::assignments\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::syntax\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::PartialClause_type:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrPartialClause::type\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::RefSyntax_field:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::field\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::RefSyntax_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRefSyntax::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ReuseClause_assignments:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::assignments\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::ReuseClause_syntax:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrReuseClause::syntax\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Rule_clauses:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::clauses\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Rule_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrRule::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SequenceSyntax_first:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::first\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SequenceSyntax_second:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSequenceSyntax::second\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::SyntaxFile_rules:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrSyntaxFile::rules\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::Type_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrType::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				case ParserGenFields::UseSyntax_name:
					throw vl::glr::AstInsException(L"Field \"vl::glr::parsergen::GlrUseSyntax::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				default:
					throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
				}
			}

			const wchar_t* ParserGenTypeName(ParserGenClasses type)
			{
				const wchar_t* results[] = {
					L"AlternativeSyntax",
					L"Assignment",
					L"AstFile",
					L"Class",
					L"ClassProp",
					L"Clause",
					L"CreateClause",
					L"Enum",
					L"EnumItem",
					L"LiteralSyntax",
					L"LoopSyntax",
					L"OptionalSyntax",
					L"PartialClause",
					L"RefSyntax",
					L"ReuseClause",
					L"Rule",
					L"SequenceSyntax",
					L"Syntax",
					L"SyntaxFile",
					L"Type",
					L"UseSyntax",
				};
				vl::vint index = (vl::vint)type;
				return 0 <= index && index < 21 ? results[index] : nullptr;
			}

			const wchar_t* ParserGenCppTypeName(ParserGenClasses type)
			{
				const wchar_t* results[] = {
					L"vl::glr::parsergen::GlrAlternativeSyntax",
					L"vl::glr::parsergen::GlrAssignment",
					L"vl::glr::parsergen::GlrAstFile",
					L"vl::glr::parsergen::GlrClass",
					L"vl::glr::parsergen::GlrClassProp",
					L"vl::glr::parsergen::GlrClause",
					L"vl::glr::parsergen::GlrCreateClause",
					L"vl::glr::parsergen::GlrEnum",
					L"vl::glr::parsergen::GlrEnumItem",
					L"vl::glr::parsergen::GlrLiteralSyntax",
					L"vl::glr::parsergen::GlrLoopSyntax",
					L"vl::glr::parsergen::GlrOptionalSyntax",
					L"vl::glr::parsergen::GlrPartialClause",
					L"vl::glr::parsergen::GlrRefSyntax",
					L"vl::glr::parsergen::GlrReuseClause",
					L"vl::glr::parsergen::GlrRule",
					L"vl::glr::parsergen::GlrSequenceSyntax",
					L"vl::glr::parsergen::GlrSyntax",
					L"vl::glr::parsergen::GlrSyntaxFile",
					L"vl::glr::parsergen::GlrType",
					L"vl::glr::parsergen::GlrUseSyntax",
				};
				vl::vint index = (vl::vint)type;
				return 0 <= index && index < 21 ? results[index] : nullptr;
			}

			const wchar_t* ParserGenFieldName(ParserGenFields field)
			{
				switch(field)
				{
				case ParserGenFields::AlternativeSyntax_first:
					return L"AlternativeSyntax::first";
				case ParserGenFields::AlternativeSyntax_second:
					return L"AlternativeSyntax::second";
				case ParserGenFields::Assignment_field:
					return L"Assignment::field";
				case ParserGenFields::Assignment_value:
					return L"Assignment::value";
				case ParserGenFields::AstFile_types:
					return L"AstFile::types";
				case ParserGenFields::Class_ambiguity:
					return L"Class::ambiguity";
				case ParserGenFields::Class_baseClass:
					return L"Class::baseClass";
				case ParserGenFields::Class_props:
					return L"Class::props";
				case ParserGenFields::ClassProp_name:
					return L"ClassProp::name";
				case ParserGenFields::ClassProp_propType:
					return L"ClassProp::propType";
				case ParserGenFields::ClassProp_propTypeName:
					return L"ClassProp::propTypeName";
				case ParserGenFields::CreateClause_assignments:
					return L"CreateClause::assignments";
				case ParserGenFields::CreateClause_syntax:
					return L"CreateClause::syntax";
				case ParserGenFields::CreateClause_type:
					return L"CreateClause::type";
				case ParserGenFields::Enum_items:
					return L"Enum::items";
				case ParserGenFields::EnumItem_name:
					return L"EnumItem::name";
				case ParserGenFields::LiteralSyntax_value:
					return L"LiteralSyntax::value";
				case ParserGenFields::LoopSyntax_delimiter:
					return L"LoopSyntax::delimiter";
				case ParserGenFields::LoopSyntax_syntax:
					return L"LoopSyntax::syntax";
				case ParserGenFields::OptionalSyntax_priority:
					return L"OptionalSyntax::priority";
				case ParserGenFields::OptionalSyntax_syntax:
					return L"OptionalSyntax::syntax";
				case ParserGenFields::PartialClause_assignments:
					return L"PartialClause::assignments";
				case ParserGenFields::PartialClause_syntax:
					return L"PartialClause::syntax";
				case ParserGenFields::PartialClause_type:
					return L"PartialClause::type";
				case ParserGenFields::RefSyntax_field:
					return L"RefSyntax::field";
				case ParserGenFields::RefSyntax_name:
					return L"RefSyntax::name";
				case ParserGenFields::ReuseClause_assignments:
					return L"ReuseClause::assignments";
				case ParserGenFields::ReuseClause_syntax:
					return L"ReuseClause::syntax";
				case ParserGenFields::Rule_clauses:
					return L"Rule::clauses";
				case ParserGenFields::Rule_name:
					return L"Rule::name";
				case ParserGenFields::SequenceSyntax_first:
					return L"SequenceSyntax::first";
				case ParserGenFields::SequenceSyntax_second:
					return L"SequenceSyntax::second";
				case ParserGenFields::SyntaxFile_rules:
					return L"SyntaxFile::rules";
				case ParserGenFields::Type_name:
					return L"Type::name";
				case ParserGenFields::UseSyntax_name:
					return L"UseSyntax::name";
				default:
					return nullptr;
				}
			}

			const wchar_t* ParserGenCppFieldName(ParserGenFields field)
			{
				switch(field)
				{
				case ParserGenFields::AlternativeSyntax_first:
					return L"vl::glr::parsergen::GlrAlternativeSyntax::first";
				case ParserGenFields::AlternativeSyntax_second:
					return L"vl::glr::parsergen::GlrAlternativeSyntax::second";
				case ParserGenFields::Assignment_field:
					return L"vl::glr::parsergen::GlrAssignment::field";
				case ParserGenFields::Assignment_value:
					return L"vl::glr::parsergen::GlrAssignment::value";
				case ParserGenFields::AstFile_types:
					return L"vl::glr::parsergen::GlrAstFile::types";
				case ParserGenFields::Class_ambiguity:
					return L"vl::glr::parsergen::GlrClass::ambiguity";
				case ParserGenFields::Class_baseClass:
					return L"vl::glr::parsergen::GlrClass::baseClass";
				case ParserGenFields::Class_props:
					return L"vl::glr::parsergen::GlrClass::props";
				case ParserGenFields::ClassProp_name:
					return L"vl::glr::parsergen::GlrClassProp::name";
				case ParserGenFields::ClassProp_propType:
					return L"vl::glr::parsergen::GlrClassProp::propType";
				case ParserGenFields::ClassProp_propTypeName:
					return L"vl::glr::parsergen::GlrClassProp::propTypeName";
				case ParserGenFields::CreateClause_assignments:
					return L"vl::glr::parsergen::GlrCreateClause::assignments";
				case ParserGenFields::CreateClause_syntax:
					return L"vl::glr::parsergen::GlrCreateClause::syntax";
				case ParserGenFields::CreateClause_type:
					return L"vl::glr::parsergen::GlrCreateClause::type";
				case ParserGenFields::Enum_items:
					return L"vl::glr::parsergen::GlrEnum::items";
				case ParserGenFields::EnumItem_name:
					return L"vl::glr::parsergen::GlrEnumItem::name";
				case ParserGenFields::LiteralSyntax_value:
					return L"vl::glr::parsergen::GlrLiteralSyntax::value";
				case ParserGenFields::LoopSyntax_delimiter:
					return L"vl::glr::parsergen::GlrLoopSyntax::delimiter";
				case ParserGenFields::LoopSyntax_syntax:
					return L"vl::glr::parsergen::GlrLoopSyntax::syntax";
				case ParserGenFields::OptionalSyntax_priority:
					return L"vl::glr::parsergen::GlrOptionalSyntax::priority";
				case ParserGenFields::OptionalSyntax_syntax:
					return L"vl::glr::parsergen::GlrOptionalSyntax::syntax";
				case ParserGenFields::PartialClause_assignments:
					return L"vl::glr::parsergen::GlrPartialClause::assignments";
				case ParserGenFields::PartialClause_syntax:
					return L"vl::glr::parsergen::GlrPartialClause::syntax";
				case ParserGenFields::PartialClause_type:
					return L"vl::glr::parsergen::GlrPartialClause::type";
				case ParserGenFields::RefSyntax_field:
					return L"vl::glr::parsergen::GlrRefSyntax::field";
				case ParserGenFields::RefSyntax_name:
					return L"vl::glr::parsergen::GlrRefSyntax::name";
				case ParserGenFields::ReuseClause_assignments:
					return L"vl::glr::parsergen::GlrReuseClause::assignments";
				case ParserGenFields::ReuseClause_syntax:
					return L"vl::glr::parsergen::GlrReuseClause::syntax";
				case ParserGenFields::Rule_clauses:
					return L"vl::glr::parsergen::GlrRule::clauses";
				case ParserGenFields::Rule_name:
					return L"vl::glr::parsergen::GlrRule::name";
				case ParserGenFields::SequenceSyntax_first:
					return L"vl::glr::parsergen::GlrSequenceSyntax::first";
				case ParserGenFields::SequenceSyntax_second:
					return L"vl::glr::parsergen::GlrSequenceSyntax::second";
				case ParserGenFields::SyntaxFile_rules:
					return L"vl::glr::parsergen::GlrSyntaxFile::rules";
				case ParserGenFields::Type_name:
					return L"vl::glr::parsergen::GlrType::name";
				case ParserGenFields::UseSyntax_name:
					return L"vl::glr::parsergen::GlrUseSyntax::name";
				default:
					return nullptr;
				}
			}

			vl::Ptr<vl::glr::ParsingAstBase> ParserGenAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
			{
				switch((ParserGenClasses)type)
				{
				case ParserGenClasses::AlternativeSyntax:
				case ParserGenClasses::Assignment:
				case ParserGenClasses::AstFile:
				case ParserGenClasses::Class:
				case ParserGenClasses::ClassProp:
				case ParserGenClasses::Clause:
				case ParserGenClasses::CreateClause:
				case ParserGenClasses::Enum:
				case ParserGenClasses::EnumItem:
				case ParserGenClasses::LiteralSyntax:
				case ParserGenClasses::LoopSyntax:
				case ParserGenClasses::OptionalSyntax:
				case ParserGenClasses::PartialClause:
				case ParserGenClasses::RefSyntax:
				case ParserGenClasses::ReuseClause:
				case ParserGenClasses::Rule:
				case ParserGenClasses::SequenceSyntax:
				case ParserGenClasses::Syntax:
				case ParserGenClasses::SyntaxFile:
				case ParserGenClasses::Type:
				case ParserGenClasses::UseSyntax:
					throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
				default:
					throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
				}
			}
		}
	}
}
