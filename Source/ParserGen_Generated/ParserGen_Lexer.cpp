/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "ParserGen_Lexer.h"

namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			bool ParserGenTokenDeleter(vl::vint token)
			{
				switch((ParserGenTokens)token)
				{
				case ParserGenTokens::SPACE:
					return true;
				default:
					return false;
				}
			}

			const wchar_t* ParserGenTokenId(ParserGenTokens token)
			{
				static const wchar_t* results[] = {
					L"CLASS",
					L"ENUM",
					L"VAR",
					L"TOKEN",
					L"AS",
					L"PARTIAL",
					L"OPEN_ROUND",
					L"CLOSE_ROUND",
					L"OPEN_SQUARE",
					L"CLOSE_SQUARE",
					L"OPEN_CURLY",
					L"CLOSE_CURLY",
					L"COMMA",
					L"COLON",
					L"SEMICOLON",
					L"INFER",
					L"ALTERNATIVE",
					L"USE",
					L"ASSIGN",
					L"ID",
					L"STRING",
					L"SPACE",
				};
				vl::vint index = (vl::vint)token;
				return 0 <= index && index < ParserGenTokenCount ? results[index] : nullptr;
			}

			const wchar_t* ParserGenTokenDisplayText(ParserGenTokens token)
			{
				static const wchar_t* results[] = {
					L"class",
					L"enum",
					L"var",
					L"token",
					L"as",
					L"partial",
					L"(",
					L")",
					L"[",
					L"]",
					L"{",
					L"}",
					L",",
					L":",
					L";",
					L"::=",
					L"|",
					L"!",
					L"=",
					nullptr,
					nullptr,
					nullptr,
				};
				vl::vint index = (vl::vint)token;
				return 0 <= index && index < ParserGenTokenCount ? results[index] : nullptr;
			}

			const wchar_t* ParserGenTokenRegex(ParserGenTokens token)
			{
				static const wchar_t* results[] = {
					L"class",
					L"enum",
					L"var",
					L"token",
					L"as",
					L"partial",
					L"/(",
					L"/)",
					L"/[",
					L"/]",
					L"/{",
					L"/}",
					L",",
					L":",
					L";",
					L"::=",
					L"/|",
					L"!",
					L"=",
					L"[a-zA-Z_][a-zA-Z0-9_]*",
					L"(\"[^\"]*\")+",
					L"/s+",
				};
				vl::vint index = (vl::vint)token;
				return 0 <= index && index < ParserGenTokenCount ? results[index] : nullptr;
			}

			void ParserGenLexerData(vl::stream::IStream& outputStream)
			{
				static const vl::vint dataLength = 1096; // 11671 bytes before compressing
				static const vl::vint dataBlock = 256;
				static const vl::vint dataRemain = 72;
				static const vl::vint dataSolidRows = 4;
				static const vl::vint dataRows = 5;
				static const char* compressed[] = {
					"\x97\x2D\x00\x00\x40\x04\x00\x00\x33\x00\x01\xB6\x01\x84\x81\x81\x1A\x82\x01\x04\x88\x04\x89\x04\x84\x82\x05\x0F\x84\x8B\x04\x8C\x04\x81\x06\x8B\x04\x8E\x04\x9F\x04\x80\x11\x8E\x82\x21\x20\x84\x82\x13\x94\x83\x10\x82\x27\x04\xA8\x0A\x94\x81\x15\x96\x82\x2A\x04\xAB\x04\x8C\x14\x98\x83\x16\x04\xAF\x04\x90\x14\x81\x1C\x82\x1D\x3F\x84\xBB\x02\xA4\x84\x1D\xA2\x82\x3D\x48\x84\x9E\x14\x80\x20\x83\x20\x04\xDA\x04\x9B\x23\xAC\x80\x2E\xAB\x04\xDD\x19\xA4\x8E\x2C\xAC\x83\x2F\x5F\x84\xA0\x22\xB4\x81\x31\xB2\x82\x62\x68\x84\x83\x3B\xB4\x80\x32\xB7\x04\xE5\x31\xA4\x86\x34\x80\x34\x82\x69\x78\x84\x8A\x3B\xBC\x83\x34\xBF\x04\xEC\x01\xC4\x8D\x34\xC0\x82\x37\x87\x84\xAF\x2A\xC4\x80\x39\xC6\x82\x71\x10\xC4\x92\x33\xCC\x83\x38\xCB\x04\xF4\x19\xC4\x85\x3C\xCC\x82\x3B\x9F\x84\xB7\x24\x8A\x3C\x83\x3C\xD3\x04\xFC\x29\xC4\x8D\x3C\xD4\x82\x3F\x04\xFF\x7F\x70\x00\x02\xDA\xD9\x0A\x04\xB8\xC1\x96\xDF\x7A\xDD\xDA\xDB\xBE\x91\x04\x94\x01\xDE\xDB\x02\x85\xC5\xB2\xD7\x9B\xDC\xDE\xDA\x8D\x80\x0F\x49\xFF\x72\x02\xEB\x0A\x86\xE6\xB2\x90\x98\xFF",
					"\x76\xEB\xED\x02\x82\xDD\x80\x09\x81\x81\xF2\x00\xF1\xF3\xE4\xE8\xC0\x01\xFC\xF2\xF6\x02\xF5\xED\x81\x84\x0A\xF3\x02\xF7\x89\x80\xB4\x81\x95\x9B\xED\xE5\xFE\xFF\xFF\x00\x81\x82\x83\x7F\x17\x12\x73\x80\x6F\x05\xBC\x72\x81\x82\xBF\x72\x6C\x83\x83\x04\x50\x81\x42\x84\x00\x14\x86\x05\x84\x18\x93\x89\x85\x85\x1B\x94\x8E\x86\x81\x07\xA1\x82\x8B\x88\x24\x8C\x84\x8A\x6D\x26\xA2\x89\x8A\x83\x1D\xAD\x8A\x87\x8B\x1C\xB0\x84\x84\x06\x2E\xB1\x86\x8F\x87\x32\xA0\x87\x8B\x8E\x3C\xA5\x8A\x8F\x81\x2B\x80\x92\x75\x06\x35\xB8\x87\x8D\x91\x48\xB9\x8A\x93\x91\x30\xBD\x8E\x93\x93\x21\x81\x93\x8A\x94\x0B\x92\x76\x93\x95\x49\x8C\x90\x02\x06\x59\x98\x9D\x90\x94\x60\xA1\x98\x83\x8F\x03\x94\x91\x81\x90\x5E\x9A\x99\x9B\x9A\x1B\x9B\x0D\x94\x99\x62\xB1\x93\x94\x9C\x67\xB4\x9D\x71\x90\x1C\x2F\x9B\x90\x9B\x7B\xBA\x9A\x96\x9C\x80\x81\xA2\xA3\xA0\x84\x85\xA6\xA3\xA1\x88\x89\xAA\xA3\xA2\x8C\x8D\xAE\xA3\xA3\x90\x91\xA2\xA7\xA4\x94\x95\xA6\xA7\xA5\x98\x99\xAA\xA7\xA6\x9C\x9D\xAE\xA7\xA7\xA0\x93\xAD\x06\x9D\xA1\xA5\xA6\xAB\xA9\xA8\xA9\xAA\xAB\xAA",
					"\xAC\xAD\xAE\xAB\xAB\xB0\xB1\xA2\xAD\x9D\x0A\x91\x94\xA8\x8A\x56\xBE\x9C\x9E\x9A\xBA\x99\x9C\x8E\x07\x04\x40\xB1\x42\xB0\x00\x04\xB6\xB1\xB0\xC8\x81\x4C\x47\xB0\xC9\x85\xBD\xB3\xB1\xCC\x91\xBE\xB2\xB4\xD0\x93\xB6\xB5\xB5\xD8\x8F\xBA\xB4\xB5\xDB\x97\xBD\xB5\xB6\xDC\xA1\xBE\xB6\xB8\xD5\xBF\x7E\x45\x40\xE7\x8D\x8F\x3D\xBA\xBC\x6C\xB3\xAF\xBB\xF0\xB4\xAA\xBB\x9C\xB5\x80\x81\x91\x48\x7D\xB9\xBC\xAE\xBE\xBB\x86\x90\xBE\x99\x42\xB5\xB4\x81\xAE\xFC\xBD\xA5\xC3\xC1\xFB\xB3\xB0\xAC\xC0\x65\xB7\xAC\x8B\x76\xFD\x86\xC9\xC1\x9A\x24\x4B\x9F\xBE\xC3\x77\x98\xC8\x9A\xC4\x11\xFA\xB7\x48\xC2\x0C\xEC\xA1\xCA\xBC\xF4\xAA\xBD\xC6\x96\x24\x1C\xCA\xCA\xC0\x22\xD8\xC3\x98\xCB\xFD\x5B\xC0\xCB\xCA\x13\xD2\xC7\xC4\xCC\xF6\x9A\xC4\xC1\xCD\x33\xFD\xC0\x01\x09\x36\xF1\xB1\x8A\x09\x2E\xC2\xD7\xA0\xB8\xE3\x89\xD4\xB3\xB2\x4A\xDF\xBE\xD0\xB9\x4F\xCD\xD0\xD7\xD4\x52\xD5\xD8\xD3\xD5\x51\xD8\xD8\xCC\x94\x29\x5B\xD6\xD3\xD7\xED\x9F\x4B\x76\xBB\xB2\x64\xD0\xDB\xD9\xAF\xA3\xC9\xCE\xD7\x0F\xE6\xC4\xCF\xC9\x46\xAB\x48\xC3\xCD\x0A\xF6\xAC\xDB\x3F\x32",
					"\xFC\xCA\xDC\x83\x2E\x7E\xCB\xAC\xDD\x3C\xAA\xDF\xCA\xDB\x7E\xEF\xD6\xE3\xDD\xA5\x82\xEE\x7E\xE2\x6D\xC3\xE6\x91\x4C\x85\xD1\xEA\xDC\xE0\x3B\x8C\xE8\xDF\xCE\x70\xC7\xEA\x97\x4C\xFA\xA8\xDE\xE7\xA7\x35\x41\x41\xE8\x00\xA3\xE5\xE6\x4E\xE8\xA7\xC0\x08\x4C\xEA\xAC\xE4\xE9\xEA\xE9\xAD\xF0\xEE\xE9\xEC\xAF\xF5\xE4\xEF\xED\xB3\xF9\xE2\xEF\xEE\xB6\xFA\xED\xEC\xEF\xB8\xC0\xFE\xED\xEB\x89\xC5\xDD\xE2\x8A\x98\xDA\xE9\xE5\x40\x2E\x3E\x94\xE7\x89\x96\xF9\xDB\xF3\xDE\xCA\xC6\xFF\xA6\xE5\x83\xE5\xCE\xE1\xF5\x30\xBA\x42\xE6\xBF\xEF\x98\xF8\xAF\xDD\xD2\xFE\x9C\x4F\xF7\x9A\xFC\x82\xF3\xFA\xA9\xEB\xE3\xF3\xFB\xEC\xC1\xFF\xEF\xFC\xF2\xF5\xF0\xFC\xFD\xF7\xF6\xF1\xFD\xFE\xEF\xC6\xAD\xD5\xDD\x9F\x61\x80\xA6\x62\x77\x78\xBB\x44\x74\x7A\xE8\x69\x82\x8D\x4F\x7E\x46\xF2\x49\x7A\x81\xD3\x7F\x6D\xF8\x56\x71\x7A\xE9\x31\x04\x7B\x08\x99\x80\x85\x0C\x8A\x7A\xE4\x50\x60\x83\x32\x18\x80\xF8\x33\x54\x81\xCB\x4E\x87\x83\x10\x82\x86\xAF\x3B\x4E\x1F\x7F\x2F\x1F\x13\x7F\x0F\x1F\x01\x00\x25\x21\xF4\x36\x83\x3D\xF0\x2E\x3C\x41\x47\x31\x21\x85\x01\x25",
					"\x21\x01\x3A\x38\x00\x77\x30\x01\xFD\x00\x03\x39\x00\x0F\x38\x00\x79\x30\x00\xE1\x01\x24\x3A\x37\x97\x41\x40\x3E\x31\x3E\x1C\xB7\x81\x3C\xF3\x31\x88\x41\x52\x80\x00\xE2\x13\x89\x87\x01\x26\x3F\x15\x84\x21\x3B\x80\x1C\x89\x3C\xE3\x36\x8A\x1A\xDC\x8E\x8B\x1A\xB5\x3B\x8C\x01\x3F\x39\x40\x00",
				};
				vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
			}
		}
	}
}
