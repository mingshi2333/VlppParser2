/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_BUILTIN_CPP_AST_AST
#define VCZH_PARSER2_BUILTIN_CPP_AST_AST

#include "../../../../Source/AstBase.h"
#include "../../../../Source/SyntaxBase.h"

namespace cpp_parser
{
	class CppConstType;
	class CppExprOnly;
	class CppFile;
	class CppGenericArgument;
	class CppGenericArguments;
	class CppIdentifier;
	class CppNameIdentifier;
	class CppNumericExprLiteral;
	class CppOperatorIdentifier;
	class CppPrimitiveExprLiteral;
	class CppPrimitiveType;
	class CppQualifiedName;
	class CppStringLiteral;
	class CppStringLiteralFragment;
	class CppTypeOnly;
	class CppTypeOrExpr;
	class CppVolatileType;

	enum class CppNameKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Normal = 0,
		Enum = 1,
		EnumClass = 2,
		Class = 3,
		Struct = 4,
		Union = 5,
		Dtor = 6,
		UserDefinedLiteral = 7,
	};

	enum class CppOperators
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		New = 0,
		NewArray = 1,
		Delete = 2,
		DeleteArray = 3,
		Comma = 4,
		RoundBracket = 5,
		Parantheses = 6,
		Bracket = 7,
		PointerDeref = 8,
		Pointer = 9,
		EQ = 10,
		NE = 11,
		LT = 12,
		LE = 13,
		GT = 14,
		GE = 15,
		Not = 16,
		Revert = 17,
		Xor = 18,
		And = 19,
		BitwiseAnd = 20,
		Or = 21,
		BitwiseOr = 22,
		Mul = 23,
		Div = 24,
		Mod = 25,
		Plus = 26,
		Increase = 27,
		Minus = 28,
		Decrease = 29,
		LeftShift = 30,
		RightShift = 31,
		Assign = 32,
		RevertAssign = 33,
		XorAssign = 34,
		AndAssign = 35,
		OrAssign = 36,
		MulAssign = 37,
		DivAssign = 38,
		ModAssign = 39,
		PlusAssign = 40,
		MinusAssign = 41,
		LeftShiftAssign = 42,
		RightShiftAssign = 43,
	};

	enum class CppQualifiedNameKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Root = 0,
		Context = 1,
		Decltype = 2,
		DecltypeAuto = 3,
		Member = 4,
	};

	enum class CppPrimitiveExprLiteralKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		True = 0,
		False = 1,
		Nullptr = 2,
		This = 3,
		__Nullptr = 4,
	};

	enum class CppNumericExprLiteralKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Integer = 0,
		Hex = 1,
		Binary = 2,
		Float = 3,
		FloatHex = 4,
		Char = 5,
	};

	enum class CppStringLiteralKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		String = 0,
		Macro_LPREFIX = 1,
	};

	enum class CppPrimitiveTypeKinds
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Neutral = 0,
		Signed = 1,
		Unsigned = 2,
	};

	class CppTypeOrExpr abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<CppTypeOrExpr>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(CppExprOnly* node) = 0;
			virtual void Visit(CppTypeOnly* node) = 0;
			virtual void Visit(CppQualifiedName* node) = 0;
		};

		virtual void Accept(CppTypeOrExpr::IVisitor* visitor) = 0;

	};

	class CppExprOnly abstract : public CppTypeOrExpr, vl::reflection::Description<CppExprOnly>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(CppPrimitiveExprLiteral* node) = 0;
			virtual void Visit(CppNumericExprLiteral* node) = 0;
			virtual void Visit(CppStringLiteral* node) = 0;
		};

		virtual void Accept(CppExprOnly::IVisitor* visitor) = 0;


		void Accept(CppTypeOrExpr::IVisitor* visitor) override;
	};

	class CppTypeOnly abstract : public CppTypeOrExpr, vl::reflection::Description<CppTypeOnly>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(CppPrimitiveType* node) = 0;
			virtual void Visit(CppConstType* node) = 0;
			virtual void Visit(CppVolatileType* node) = 0;
		};

		virtual void Accept(CppTypeOnly::IVisitor* visitor) = 0;


		void Accept(CppTypeOrExpr::IVisitor* visitor) override;
	};

	class CppIdentifier abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<CppIdentifier>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(CppNameIdentifier* node) = 0;
			virtual void Visit(CppOperatorIdentifier* node) = 0;
		};

		virtual void Accept(CppIdentifier::IVisitor* visitor) = 0;

	};

	class CppNameIdentifier : public CppIdentifier, vl::reflection::Description<CppNameIdentifier>
	{
	public:
		CppNameKinds kind = CppNameKinds::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken name;

		void Accept(CppIdentifier::IVisitor* visitor) override;
	};

	class CppOperatorIdentifier : public CppIdentifier, vl::reflection::Description<CppOperatorIdentifier>
	{
	public:
		CppOperators op = CppOperators::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(CppIdentifier::IVisitor* visitor) override;
	};

	class CppGenericArgument : public vl::glr::ParsingAstBase, vl::reflection::Description<CppGenericArgument>
	{
	public:
		vl::Ptr<CppTypeOrExpr> argument;
		vl::glr::ParsingToken variadic;
	};

	class CppGenericArguments : public vl::glr::ParsingAstBase, vl::reflection::Description<CppGenericArguments>
	{
	public:
		vl::collections::List<vl::Ptr<CppGenericArgument>> arguments;
	};

	class CppQualifiedName : public CppTypeOrExpr, vl::reflection::Description<CppQualifiedName>
	{
	public:
		CppQualifiedNameKinds kind = CppQualifiedNameKinds::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<CppTypeOrExpr> expr;
		vl::Ptr<CppQualifiedName> parent;
		vl::Ptr<CppIdentifier> id;
		vl::Ptr<CppGenericArguments> arguments;

		void Accept(CppTypeOrExpr::IVisitor* visitor) override;
	};

	class CppPrimitiveExprLiteral : public CppExprOnly, vl::reflection::Description<CppPrimitiveExprLiteral>
	{
	public:
		CppPrimitiveExprLiteralKinds kind = CppPrimitiveExprLiteralKinds::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(CppExprOnly::IVisitor* visitor) override;
	};

	class CppNumericExprLiteral : public CppExprOnly, vl::reflection::Description<CppNumericExprLiteral>
	{
	public:
		CppNumericExprLiteralKinds kind = CppNumericExprLiteralKinds::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken literal;

		void Accept(CppExprOnly::IVisitor* visitor) override;
	};

	class CppStringLiteralFragment : public vl::glr::ParsingAstBase, vl::reflection::Description<CppStringLiteralFragment>
	{
	public:
		CppStringLiteralKinds kind = CppStringLiteralKinds::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken literal;
	};

	class CppStringLiteral : public CppExprOnly, vl::reflection::Description<CppStringLiteral>
	{
	public:
		vl::collections::List<vl::Ptr<CppStringLiteralFragment>> fragments;

		void Accept(CppExprOnly::IVisitor* visitor) override;
	};

	class CppPrimitiveType : public CppTypeOnly, vl::reflection::Description<CppPrimitiveType>
	{
	public:
		CppPrimitiveTypeKinds kind = CppPrimitiveTypeKinds::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken literal1;
		vl::glr::ParsingToken literal2;

		void Accept(CppTypeOnly::IVisitor* visitor) override;
	};

	class CppConstType : public CppTypeOnly, vl::reflection::Description<CppConstType>
	{
	public:
		vl::Ptr<CppTypeOrExpr> type;

		void Accept(CppTypeOnly::IVisitor* visitor) override;
	};

	class CppVolatileType : public CppTypeOnly, vl::reflection::Description<CppVolatileType>
	{
	public:
		vl::Ptr<CppTypeOrExpr> type;

		void Accept(CppTypeOnly::IVisitor* visitor) override;
	};

	class CppFile : public vl::glr::ParsingAstBase, vl::reflection::Description<CppFile>
	{
	public:
	};
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(cpp_parser::CppTypeOrExpr)
			DECL_TYPE_INFO(cpp_parser::CppTypeOrExpr::IVisitor)
			DECL_TYPE_INFO(cpp_parser::CppExprOnly)
			DECL_TYPE_INFO(cpp_parser::CppExprOnly::IVisitor)
			DECL_TYPE_INFO(cpp_parser::CppTypeOnly)
			DECL_TYPE_INFO(cpp_parser::CppTypeOnly::IVisitor)
			DECL_TYPE_INFO(cpp_parser::CppNameKinds)
			DECL_TYPE_INFO(cpp_parser::CppIdentifier)
			DECL_TYPE_INFO(cpp_parser::CppIdentifier::IVisitor)
			DECL_TYPE_INFO(cpp_parser::CppNameIdentifier)
			DECL_TYPE_INFO(cpp_parser::CppOperators)
			DECL_TYPE_INFO(cpp_parser::CppOperatorIdentifier)
			DECL_TYPE_INFO(cpp_parser::CppGenericArgument)
			DECL_TYPE_INFO(cpp_parser::CppGenericArguments)
			DECL_TYPE_INFO(cpp_parser::CppQualifiedNameKinds)
			DECL_TYPE_INFO(cpp_parser::CppQualifiedName)
			DECL_TYPE_INFO(cpp_parser::CppPrimitiveExprLiteralKinds)
			DECL_TYPE_INFO(cpp_parser::CppPrimitiveExprLiteral)
			DECL_TYPE_INFO(cpp_parser::CppNumericExprLiteralKinds)
			DECL_TYPE_INFO(cpp_parser::CppNumericExprLiteral)
			DECL_TYPE_INFO(cpp_parser::CppStringLiteralKinds)
			DECL_TYPE_INFO(cpp_parser::CppStringLiteralFragment)
			DECL_TYPE_INFO(cpp_parser::CppStringLiteral)
			DECL_TYPE_INFO(cpp_parser::CppPrimitiveTypeKinds)
			DECL_TYPE_INFO(cpp_parser::CppPrimitiveType)
			DECL_TYPE_INFO(cpp_parser::CppConstType)
			DECL_TYPE_INFO(cpp_parser::CppVolatileType)
			DECL_TYPE_INFO(cpp_parser::CppFile)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(cpp_parser::CppTypeOrExpr::IVisitor)
				void Visit(cpp_parser::CppExprOnly* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppTypeOnly* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppQualifiedName* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(cpp_parser::CppTypeOrExpr::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(cpp_parser::CppExprOnly::IVisitor)
				void Visit(cpp_parser::CppPrimitiveExprLiteral* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppNumericExprLiteral* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppStringLiteral* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(cpp_parser::CppExprOnly::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(cpp_parser::CppTypeOnly::IVisitor)
				void Visit(cpp_parser::CppPrimitiveType* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppConstType* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppVolatileType* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(cpp_parser::CppTypeOnly::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(cpp_parser::CppIdentifier::IVisitor)
				void Visit(cpp_parser::CppNameIdentifier* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(cpp_parser::CppOperatorIdentifier* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(cpp_parser::CppIdentifier::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool CppAstLoadTypes();
		}
	}
}
#endif