/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Cpp
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Cpp_Assembler.h"

namespace cpp_parser
{

/***********************************************************************
CppAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CppAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		auto cppTypeName = CppCppTypeName((CppClasses)type);
		switch((CppClasses)type)
		{
		case CppClasses::File:
			return new cpp_parser::CppFile();
		case CppClasses::Name:
			return new cpp_parser::CppName();
		case CppClasses::OperatorName:
			return new cpp_parser::CppOperatorName();
		default:
			return vl::glr::AssemblyThrowCannotCreateAbstractType(type, cppTypeName);
		}
	}

	void CppAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = CppCppFieldName((CppFields)field);
		return vl::glr::AssemblyThrowFieldNotObject(field, cppFieldName);
	}

	void CppAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex)
	{
		auto cppFieldName = CppCppFieldName((CppFields)field);
		switch((CppFields)field)
		{
		case CppFields::Name_name:
			return vl::glr::AssemblerSetTokenField(&cpp_parser::CppName::name, object, field, token, tokenIndex, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotToken(field, cppFieldName);
		}
	}

	void CppAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment)
	{
		auto cppFieldName = CppCppFieldName((CppFields)field);
		switch((CppFields)field)
		{
		case CppFields::Name_kind:
			return vl::glr::AssemblerSetEnumField(&cpp_parser::CppName::kind, object, field, enumItem, weakAssignment, cppFieldName);
		case CppFields::OperatorName_op:
			return vl::glr::AssemblerSetEnumField(&cpp_parser::CppOperatorName::op, object, field, enumItem, weakAssignment, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotEnum(field, cppFieldName);
		}
	}

	const wchar_t* CppTypeName(CppClasses type)
	{
		const wchar_t* results[] = {
			L"File",
			L"Name",
			L"OperatorName",
			L"QualifiedName",
			L"TypeOrExpr",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 5 ? results[index] : nullptr;
	}

	const wchar_t* CppCppTypeName(CppClasses type)
	{
		const wchar_t* results[] = {
			L"cpp_parser::CppFile",
			L"cpp_parser::CppName",
			L"cpp_parser::CppOperatorName",
			L"cpp_parser::CppQualifiedName",
			L"cpp_parser::CppTypeOrExpr",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 5 ? results[index] : nullptr;
	}

	const wchar_t* CppFieldName(CppFields field)
	{
		const wchar_t* results[] = {
			L"Name::kind",
			L"Name::name",
			L"OperatorName::op",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 3 ? results[index] : nullptr;
	}

	const wchar_t* CppCppFieldName(CppFields field)
	{
		const wchar_t* results[] = {
			L"cpp_parser::CppName::kind",
			L"cpp_parser::CppName::name",
			L"cpp_parser::CppOperatorName::op",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 3 ? results[index] : nullptr;
	}

	vl::Ptr<vl::glr::ParsingAstBase> CppAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = CppCppTypeName((CppClasses)type);
		return vl::glr::AssemblyThrowTypeNotAllowAmbiguity(type, cppTypeName);
	}
}
