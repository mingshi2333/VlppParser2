//////////////////////////////////////////////////////////////////
// QualifiedName
//////////////////////////////////////////////////////////////////

_Name
  ::= ID:name                       as Name {kind = Normal}
  ::= "~" ID:name                   as Name {kind = Dtor}
  ::= "enum" ID:name                as Name {kind = Enum}
  ::= "enum" "class" ID:name        as Name {kind = EnumClass}
  ::= "class" ID:name               as Name {kind = Class}
  ::= "struct" ID:name              as Name {kind = Struct}
  ::= "union" ID:name               as Name {kind = Union}
  ;

_OperatorName
  ::= "operator" '""' ID:name       as Name {kind = UserDefinedLiteral}
  ::= "operator" "new"              as OperatorName {op = New}
  ::= "operator" "new" "[" "]"      as OperatorName {op = NewArray}
  ::= "operator" "delete"           as OperatorName {op = Delete}
  ::= "operator" "delete" "[" "]"   as OperatorName {op = DeleteArray}
  ::= "operator" ","                as OperatorName {op = Comma}
  ::= "operator" "(" ")"            as OperatorName {op = Parantheses}
  ::= "operator" "[" "]"            as OperatorName {op = Bracket}
  ::= "operator" "->*"              as OperatorName {op = PointerDeref}
  ::= "operator" "->"               as OperatorName {op = Pointer}
  ::= "operator" "!="               as OperatorName {op = NE}
  ::= "operator" "!"                as OperatorName {op = Not}
  ::= "operator" "=="               as OperatorName {op = EQ}
  ::= "operator" "="                as OperatorName {op = Assign}
  ::= "operator" "~="               as OperatorName {op = RevertAssign}
  ::= "operator" "~"                as OperatorName {op = Revert}
  ::= "operator" "^="               as OperatorName {op = XorAssign}
  ::= "operator" "^"                as OperatorName {op = Xor}
  ::= "operator" "&&"               as OperatorName {op = And}
  ::= "operator" "&="               as OperatorName {op = AndAssign}
  ::= "operator" "&"                as OperatorName {op = BitwiseAnd}
  ::= "operator" "||"               as OperatorName {op = Or}
  ::= "operator" "|="               as OperatorName {op = OrAssign}
  ::= "operator" "|"                as OperatorName {op = BitwiseOr}
  ::= "operator" "*="               as OperatorName {op = MulAssign}
  ::= "operator" "*"                as OperatorName {op = Mul}
  ::= "operator" "/="               as OperatorName {op = DivAssign}
  ::= "operator" "/"                as OperatorName {op = Div}
  ::= "operator" "%="               as OperatorName {op = ModAssign}
  ::= "operator" "%"                as OperatorName {op = Mod}
  ::= "operator" "+="               as OperatorName {op = PlusAssign}
  ::= "operator" "++"               as OperatorName {op = Increase}
  ::= "operator" "+"                as OperatorName {op = Plus}
  ::= "operator" "-="               as OperatorName {op = MinusAssign}
  ::= "operator" "--"               as OperatorName {op = Decrease}
  ::= "operator" "-"                as OperatorName {op = Minus}
  ::= "operator" "<<="              as OperatorName {op = LeftShiftAssign}
  ::= "operator" "<<"               as OperatorName {op = LeftShift}
  ::= "operator" "<="               as OperatorName {op = LE}
  ::= "operator" "<"                as OperatorName {op = LT}
  ::= "operator" ">>="              as OperatorName {op = RightShiftAssign}
  ::= "operator" ">>"               as OperatorName {op = RightShift}
  ::= "operator" ">="               as OperatorName {op = GE}
  ::= "operator" ">"                as OperatorName {op = GT}
  ;

_QualifiedName
  ::= !_Name
  ::= !_OperatorName
  ;

//////////////////////////////////////////////////////////////////
// PrimitiveExpr
//////////////////////////////////////////////////////////////////

_StringLiteralFragment
  ::= MACRO_LPREFIX as StringLiteralFragment {kind = Macro_LPREFIX}
  ::= STRING:literal as StringLiteralFragment {kind = String}
  ;

_PrimitiveExpr : TypeOrExpr
  ::= "true" as PrimitiveExprLiteral {kind = True}
  ::= "false" as PrimitiveExprLiteral {kind = False}
  ::= "nullptr" as PrimitiveExprLiteral {kind = Nullptr}
  ::= "this" as PrimitiveExprLiteral {kind = This}
  ::= "__nullptr" as PrimitiveExprLiteral {kind = __Nullptr}
  ::= INT:literal as NumericExprLiteral {kind = Integer}
  ::= HEX:literal as NumericExprLiteral {kind = Hex}
  ::= BIN:literal as NumericExprLiteral {kind = Binary}
  ::= FLOAT:literal as NumericExprLiteral {kind = Float}
  ::= FLOATHEX:literal as NumericExprLiteral {kind = FloatHex}
  ::= CHAR:literal as NumericExprLiteral {kind = Char}
  ::= _StringLiteralFragment:fragments {_StringLiteralFragment:fragments} as StringLiteral
  ;

//////////////////////////////////////////////////////////////////
// PrimitiveType
//////////////////////////////////////////////////////////////////

_PrimitiveTypeLiteral
  ::= "wchar_t":literal1                 as partial PrimitiveType
  ::= "char8_t":literal1                 as partial PrimitiveType
  ::= "char16_t":literal1                as partial PrimitiveType
  ::= "char32_t":literal1                as partial PrimitiveType
  ::= "char":literal1                    as partial PrimitiveType
  ::= "short":literal1                   as partial PrimitiveType
  ::= "int":literal1                     as partial PrimitiveType
  ::= "__int8":literal1                  as partial PrimitiveType
  ::= "__int16":literal1                 as partial PrimitiveType
  ::= "__int32":literal1                 as partial PrimitiveType
  ::= "__int64":literal1                 as partial PrimitiveType
  ::= "long":literal1                    as partial PrimitiveType
  ::= "long":literal1 "int":literal2     as partial PrimitiveType
  ::= "long":literal1 "long":literal2    as partial PrimitiveType
  ;

_PrimitiveType
  ::= "signed" [_PrimitiveTypeLiteral]   as PrimitiveType {kind = Signed}
  ::= "unsigned" [_PrimitiveTypeLiteral] as PrimitiveType {kind = Unsigned}
  ::= "void":literal1                    as PrimitiveType {kind = Neutral}
  ::= "bool":literal1                    as PrimitiveType {kind = Neutral}
  ::= "float":literal1                   as PrimitiveType {kind = Neutral}
  ::= "double":literal1                  as PrimitiveType {kind = Neutral}
  ::= "long":literal1 "double":literal2  as PrimitiveType {kind = Neutral}
  ::= _PrimitiveTypeLiteral              as PrimitiveType {kind = Neutral}
  ;

_ShortType : TypeOrExpr
  ::= "const" _QualifiedName:type as ConstType
  ::= "volatile" _QualifiedName:type as VolatileType
  ::= "const" _ShortType:type as ConstType
  ::= "volatile" _ShortType:type as VolatileType
  ::= !_PrimitiveType
  ;

_LongType
  ::= left_recursion_placeholder(Shared,Type)
  ::= !_ShortType
  ::= _LongType:type "const" as ConstType
  ::= _LongType:type "volatile" as VolatileType
  ;

//////////////////////////////////////////////////////////////////
// TypeOrExpr
//////////////////////////////////////////////////////////////////

_TypeOrExpr
  ::= !_QualifiedName left_recursion_inject(Shared) _LongType
  ::= !_ShortType left_recursion_inject(Type) _LongType
  ::= !_PrimitiveExpr
  ;

//////////////////////////////////////////////////////////////////
// SYNTAX
//////////////////////////////////////////////////////////////////

_File
  ::= ";" as File
  ;