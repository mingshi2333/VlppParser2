//////////////////////////////////////////////////////////////////
// QualifiedName
//////////////////////////////////////////////////////////////////

_NameIdentifier
  ::= ID:name                       as NameIdentifier {kind = Normal}
  ::= "~" ID:name                   as NameIdentifier {kind = Dtor}
  ::= "enum" ID:name                as NameIdentifier {kind = Enum}
  ::= "enum" "class" ID:name        as NameIdentifier {kind = EnumClass}
  ::= "class" ID:name               as NameIdentifier {kind = Class}
  ::= "struct" ID:name              as NameIdentifier {kind = Struct}
  ::= "union" ID:name               as NameIdentifier {kind = Union}
  ;

_OperatorIdentifier
  ::= "operator" '""' ID:name       as NameIdentifier {kind = UserDefinedLiteral}
  ::= "operator" "new"              as OperatorIdentifier {op = New}
  ::= "operator" "new" "[" "]"      as OperatorIdentifier {op = NewArray}
  ::= "operator" "delete"           as OperatorIdentifier {op = Delete}
  ::= "operator" "delete" "[" "]"   as OperatorIdentifier {op = DeleteArray}
  ::= "operator" ","                as OperatorIdentifier {op = Comma}
  ::= "operator" "(" ")"            as OperatorIdentifier {op = Parantheses}
  ::= "operator" "[" "]"            as OperatorIdentifier {op = Bracket}
  ::= "operator" "->*"              as OperatorIdentifier {op = PointerDeref}
  ::= "operator" "->"               as OperatorIdentifier {op = Pointer}
  ::= "operator" "!="               as OperatorIdentifier {op = NE}
  ::= "operator" "!"                as OperatorIdentifier {op = Not}
  ::= "operator" "=="               as OperatorIdentifier {op = EQ}
  ::= "operator" "="                as OperatorIdentifier {op = Assign}
  ::= "operator" "~="               as OperatorIdentifier {op = RevertAssign}
  ::= "operator" "~"                as OperatorIdentifier {op = Revert}
  ::= "operator" "^="               as OperatorIdentifier {op = XorAssign}
  ::= "operator" "^"                as OperatorIdentifier {op = Xor}
  ::= "operator" "&&"               as OperatorIdentifier {op = And}
  ::= "operator" "&="               as OperatorIdentifier {op = AndAssign}
  ::= "operator" "&"                as OperatorIdentifier {op = BitwiseAnd}
  ::= "operator" "||"               as OperatorIdentifier {op = Or}
  ::= "operator" "|="               as OperatorIdentifier {op = OrAssign}
  ::= "operator" "|"                as OperatorIdentifier {op = BitwiseOr}
  ::= "operator" "*="               as OperatorIdentifier {op = MulAssign}
  ::= "operator" "*"                as OperatorIdentifier {op = Mul}
  ::= "operator" "/="               as OperatorIdentifier {op = DivAssign}
  ::= "operator" "/"                as OperatorIdentifier {op = Div}
  ::= "operator" "%="               as OperatorIdentifier {op = ModAssign}
  ::= "operator" "%"                as OperatorIdentifier {op = Mod}
  ::= "operator" "+="               as OperatorIdentifier {op = PlusAssign}
  ::= "operator" "++"               as OperatorIdentifier {op = Increase}
  ::= "operator" "+"                as OperatorIdentifier {op = Plus}
  ::= "operator" "-="               as OperatorIdentifier {op = MinusAssign}
  ::= "operator" "--"               as OperatorIdentifier {op = Decrease}
  ::= "operator" "-"                as OperatorIdentifier {op = Minus}
  ::= "operator" "<<="              as OperatorIdentifier {op = LeftShiftAssign}
  ::= "operator" "<<"               as OperatorIdentifier {op = LeftShift}
  ::= "operator" "<="               as OperatorIdentifier {op = LE}
  ::= "operator" "<"                as OperatorIdentifier {op = LT}
  ::= "operator" ">>="              as OperatorIdentifier {op = RightShiftAssign}
  ::= "operator" ">>"               as OperatorIdentifier {op = RightShift}
  ::= "operator" ">="               as OperatorIdentifier {op = GE}
  ::= "operator" ">"                as OperatorIdentifier {op = GT}
  ;

_Identifier
  ::= !_NameIdentifier
  ::= !_OperatorIdentifier
  ;

_GenericArgument
  ::= _TypeOrExpr_NoComma_NoLT:argument ["...":variadic] as GenericArgument
  ;

_GenericArguments
  ::= "<" {_GenericArgument:arguments ; ","} ">" as GenericArguments
  ;

_QualifiedName
  ::= ["::":rootScope] _Identifier:id ["template" _GenericArguments:arguments] as QualifiedName
  ::= _QualifiedName:parent "::" _Identifier:id ["template" _GenericArguments:arguments] as QualifiedName
  ;

//////////////////////////////////////////////////////////////////
// PrimitiveExpr
//////////////////////////////////////////////////////////////////

_StringLiteralFragment
  ::= MACRO_LPREFIX as StringLiteralFragment {kind = Macro_LPREFIX}
  ::= STRING:literal as StringLiteralFragment {kind = String}
  ;

_PrimitiveExpr : TypeOrExpr
  ::= "true" as PrimitiveExprLiteral {kind = True}
  ::= "false" as PrimitiveExprLiteral {kind = False}
  ::= "nullptr" as PrimitiveExprLiteral {kind = Nullptr}
  ::= "this" as PrimitiveExprLiteral {kind = This}
  ::= "__nullptr" as PrimitiveExprLiteral {kind = __Nullptr}
  ::= INT:literal as NumericExprLiteral {kind = Integer}
  ::= HEX:literal as NumericExprLiteral {kind = Hex}
  ::= BIN:literal as NumericExprLiteral {kind = Binary}
  ::= FLOAT:literal as NumericExprLiteral {kind = Float}
  ::= FLOATHEX:literal as NumericExprLiteral {kind = FloatHex}
  ::= CHAR:literal as NumericExprLiteral {kind = Char}
  ::= _StringLiteralFragment:fragments {_StringLiteralFragment:fragments} as StringLiteral
  ;

//////////////////////////////////////////////////////////////////
// PrimitiveType
//////////////////////////////////////////////////////////////////

_PrimitiveTypeLiteral
  ::= "wchar_t":literal1                 as partial PrimitiveType
  ::= "char8_t":literal1                 as partial PrimitiveType
  ::= "char16_t":literal1                as partial PrimitiveType
  ::= "char32_t":literal1                as partial PrimitiveType
  ::= "char":literal1                    as partial PrimitiveType
  ::= "short":literal1                   as partial PrimitiveType
  ::= "int":literal1                     as partial PrimitiveType
  ::= "__int8":literal1                  as partial PrimitiveType
  ::= "__int16":literal1                 as partial PrimitiveType
  ::= "__int32":literal1                 as partial PrimitiveType
  ::= "__int64":literal1                 as partial PrimitiveType
  ::= "long":literal1                    as partial PrimitiveType
  ::= "long":literal1 "int":literal2     as partial PrimitiveType
  ::= "long":literal1 "long":literal2    as partial PrimitiveType
  ;

_PrimitiveType
  ::= "signed" [_PrimitiveTypeLiteral]   as PrimitiveType {kind = Signed}
  ::= "unsigned" [_PrimitiveTypeLiteral] as PrimitiveType {kind = Unsigned}
  ::= "void":literal1                    as PrimitiveType {kind = Neutral}
  ::= "bool":literal1                    as PrimitiveType {kind = Neutral}
  ::= "float":literal1                   as PrimitiveType {kind = Neutral}
  ::= "double":literal1                  as PrimitiveType {kind = Neutral}
  ::= "long":literal1 "double":literal2  as PrimitiveType {kind = Neutral}
  ::= _PrimitiveTypeLiteral              as PrimitiveType {kind = Neutral}
  ::= "typename" !_QualifiedName
  ;

_ShortType : TypeOrExpr
  ::= "const" _QualifiedName:type as ConstType
  ::= "volatile" _QualifiedName:type as VolatileType
  ::= "const" _ShortType:type as ConstType
  ::= "volatile" _ShortType:type as VolatileType
  ::= !_PrimitiveType
  ;

_LongType
  ::= left_recursion_placeholder(Shared,Type)
  ::= !_ShortType
  ::= _LongType:type "const" as ConstType
  ::= _LongType:type "volatile" as VolatileType
  ;

//////////////////////////////////////////////////////////////////
// TypeOrExpr
//////////////////////////////////////////////////////////////////

_TypeOrExpr
  ::= !_QualifiedName left_recursion_inject(Shared) _LongType
  ::= !_ShortType left_recursion_inject(Type) _LongType
  ::= !_PrimitiveExpr
  ;

_TypeOrExpr_NoComma_NoLT
  ::= !_TypeOrExpr
  ;

//////////////////////////////////////////////////////////////////
// SYNTAX
//////////////////////////////////////////////////////////////////

_File
  ::= ";" as File
  ;