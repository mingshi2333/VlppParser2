/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_BUILTIN_WORKFLOW_AST_AST_BUILDER
#define VCZH_PARSER2_BUILTIN_WORKFLOW_AST_AST_BUILDER

#include "WorkflowAst.h"

namespace vl
{
	namespace glr
	{
		namespace workflow
		{
			namespace builder
			{
				class AttachEventExpressionBuilder
				{
				private:
					WfAttachEventExpression* node;
				public:
					AttachEventExpressionBuilder(WfAttachEventExpression* _node) : node(_node) {}
					AttachEventExpressionBuilder& event(const vl::Ptr<WfExpression>& value);
					AttachEventExpressionBuilder& function(const vl::Ptr<WfExpression>& value);
				};

				class AttributeBuilder
				{
				private:
					WfAttribute* node;
				public:
					AttributeBuilder(WfAttribute* _node) : node(_node) {}
					AttributeBuilder& category(const vl::WString& value);
					AttributeBuilder& name(const vl::WString& value);
					AttributeBuilder& value(const vl::Ptr<WfExpression>& value);
				};

				class AutoPropertyDeclarationBuilder
				{
				private:
					WfAutoPropertyDeclaration* node;
				public:
					AutoPropertyDeclarationBuilder(WfAutoPropertyDeclaration* _node) : node(_node) {}
					AutoPropertyDeclarationBuilder& configConst(WfAPConst value);
					AutoPropertyDeclarationBuilder& configObserve(WfAPObserve value);
					AutoPropertyDeclarationBuilder& expression(const vl::Ptr<WfExpression>& value);
					AutoPropertyDeclarationBuilder& functionKind(WfFunctionKind value);
					AutoPropertyDeclarationBuilder& type(const vl::Ptr<WfType>& value);
				};

				class BaseConstructorCallBuilder
				{
				private:
					WfBaseConstructorCall* node;
				public:
					BaseConstructorCallBuilder(WfBaseConstructorCall* _node) : node(_node) {}
					BaseConstructorCallBuilder& arguments(const vl::Ptr<WfExpression>& value);
					BaseConstructorCallBuilder& type(const vl::Ptr<WfType>& value);
				};

				class BinaryExpressionBuilder
				{
				private:
					WfBinaryExpression* node;
				public:
					BinaryExpressionBuilder(WfBinaryExpression* _node) : node(_node) {}
					BinaryExpressionBuilder& first(const vl::Ptr<WfExpression>& value);
					BinaryExpressionBuilder& op(WfBinaryOperator value);
					BinaryExpressionBuilder& second(const vl::Ptr<WfExpression>& value);
				};

				class BindExpressionBuilder
				{
				private:
					WfBindExpression* node;
				public:
					BindExpressionBuilder(WfBindExpression* _node) : node(_node) {}
					BindExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class BlockStatementBuilder
				{
				private:
					WfBlockStatement* node;
				public:
					BlockStatementBuilder(WfBlockStatement* _node) : node(_node) {}
					BlockStatementBuilder& endLabel(const vl::WString& value);
					BlockStatementBuilder& statements(const vl::Ptr<WfStatement>& value);
				};

				class CallExpressionBuilder
				{
				private:
					WfCallExpression* node;
				public:
					CallExpressionBuilder(WfCallExpression* _node) : node(_node) {}
					CallExpressionBuilder& arguments(const vl::Ptr<WfExpression>& value);
					CallExpressionBuilder& function(const vl::Ptr<WfExpression>& value);
				};

				class CastResultInterfaceDeclarationBuilder
				{
				private:
					WfCastResultInterfaceDeclaration* node;
				public:
					CastResultInterfaceDeclarationBuilder(WfCastResultInterfaceDeclaration* _node) : node(_node) {}
					CastResultInterfaceDeclarationBuilder& baseType(const vl::Ptr<WfType>& value);
					CastResultInterfaceDeclarationBuilder& elementType(const vl::Ptr<WfType>& value);
				};

				class ChildExpressionBuilder
				{
				private:
					WfChildExpression* node;
				public:
					ChildExpressionBuilder(WfChildExpression* _node) : node(_node) {}
					ChildExpressionBuilder& name(const vl::WString& value);
					ChildExpressionBuilder& parent(const vl::Ptr<WfExpression>& value);
				};

				class ChildTypeBuilder
				{
				private:
					WfChildType* node;
				public:
					ChildTypeBuilder(WfChildType* _node) : node(_node) {}
					ChildTypeBuilder& name(const vl::WString& value);
					ChildTypeBuilder& parent(const vl::Ptr<WfType>& value);
				};

				class ClassDeclarationBuilder
				{
				private:
					WfClassDeclaration* node;
				public:
					ClassDeclarationBuilder(WfClassDeclaration* _node) : node(_node) {}
					ClassDeclarationBuilder& baseTypes(const vl::Ptr<WfType>& value);
					ClassDeclarationBuilder& constructorType(WfConstructorType value);
					ClassDeclarationBuilder& declarations(const vl::Ptr<WfDeclaration>& value);
					ClassDeclarationBuilder& kind(WfClassKind value);
				};

				class CoOperatorExpressionBuilder
				{
				private:
					WfCoOperatorExpression* node;
				public:
					CoOperatorExpressionBuilder(WfCoOperatorExpression* _node) : node(_node) {}
					CoOperatorExpressionBuilder& name(const vl::WString& value);
				};

				class CoOperatorStatementBuilder
				{
				private:
					WfCoOperatorStatement* node;
				public:
					CoOperatorStatementBuilder(WfCoOperatorStatement* _node) : node(_node) {}
					CoOperatorStatementBuilder& arguments(const vl::Ptr<WfExpression>& value);
					CoOperatorStatementBuilder& opName(const vl::WString& value);
					CoOperatorStatementBuilder& varName(const vl::WString& value);
				};

				class CoPauseStatementBuilder
				{
				private:
					WfCoPauseStatement* node;
				public:
					CoPauseStatementBuilder(WfCoPauseStatement* _node) : node(_node) {}
					CoPauseStatementBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class CoProviderStatementBuilder
				{
				private:
					WfCoProviderStatement* node;
				public:
					CoProviderStatementBuilder(WfCoProviderStatement* _node) : node(_node) {}
					CoProviderStatementBuilder& name(const vl::WString& value);
					CoProviderStatementBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class ConstructorArgumentBuilder
				{
				private:
					WfConstructorArgument* node;
				public:
					ConstructorArgumentBuilder(WfConstructorArgument* _node) : node(_node) {}
					ConstructorArgumentBuilder& key(const vl::Ptr<WfExpression>& value);
					ConstructorArgumentBuilder& value(const vl::Ptr<WfExpression>& value);
				};

				class ConstructorDeclarationBuilder
				{
				private:
					WfConstructorDeclaration* node;
				public:
					ConstructorDeclarationBuilder(WfConstructorDeclaration* _node) : node(_node) {}
					ConstructorDeclarationBuilder& arguments(const vl::Ptr<WfFunctionArgument>& value);
					ConstructorDeclarationBuilder& baseConstructorCalls(const vl::Ptr<WfBaseConstructorCall>& value);
					ConstructorDeclarationBuilder& constructorType(WfConstructorType value);
					ConstructorDeclarationBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class ConstructorExpressionBuilder
				{
				private:
					WfConstructorExpression* node;
				public:
					ConstructorExpressionBuilder(WfConstructorExpression* _node) : node(_node) {}
					ConstructorExpressionBuilder& arguments(const vl::Ptr<WfConstructorArgument>& value);
				};

				class DeclarationBuilder
				{
				private:
					WfDeclaration* node;
				public:
					DeclarationBuilder(WfDeclaration* _node) : node(_node) {}
					DeclarationBuilder& attributes(const vl::Ptr<WfAttribute>& value);
					DeclarationBuilder& name(const vl::WString& value);
				};

				class DeleteStatementBuilder
				{
				private:
					WfDeleteStatement* node;
				public:
					DeleteStatementBuilder(WfDeleteStatement* _node) : node(_node) {}
					DeleteStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class DestructorDeclarationBuilder
				{
				private:
					WfDestructorDeclaration* node;
				public:
					DestructorDeclarationBuilder(WfDestructorDeclaration* _node) : node(_node) {}
					DestructorDeclarationBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class DetachEventExpressionBuilder
				{
				private:
					WfDetachEventExpression* node;
				public:
					DetachEventExpressionBuilder(WfDetachEventExpression* _node) : node(_node) {}
					DetachEventExpressionBuilder& event(const vl::Ptr<WfExpression>& value);
					DetachEventExpressionBuilder& handler(const vl::Ptr<WfExpression>& value);
				};

				class EnumDeclarationBuilder
				{
				private:
					WfEnumDeclaration* node;
				public:
					EnumDeclarationBuilder(WfEnumDeclaration* _node) : node(_node) {}
					EnumDeclarationBuilder& items(const vl::Ptr<WfEnumItem>& value);
					EnumDeclarationBuilder& kind(WfEnumKind value);
				};

				class EnumItemBuilder
				{
				private:
					WfEnumItem* node;
				public:
					EnumItemBuilder(WfEnumItem* _node) : node(_node) {}
					EnumItemBuilder& attributes(const vl::Ptr<WfAttribute>& value);
					EnumItemBuilder& intersections(const vl::Ptr<WfEnumItemIntersection>& value);
					EnumItemBuilder& kind(WfEnumItemKind value);
					EnumItemBuilder& name(const vl::WString& value);
					EnumItemBuilder& number(const vl::WString& value);
				};

				class EnumItemIntersectionBuilder
				{
				private:
					WfEnumItemIntersection* node;
				public:
					EnumItemIntersectionBuilder(WfEnumItemIntersection* _node) : node(_node) {}
					EnumItemIntersectionBuilder& name(const vl::WString& value);
				};

				class EnumerableTypeBuilder
				{
				private:
					WfEnumerableType* node;
				public:
					EnumerableTypeBuilder(WfEnumerableType* _node) : node(_node) {}
					EnumerableTypeBuilder& element(const vl::Ptr<WfType>& value);
				};

				class EventDeclarationBuilder
				{
				private:
					WfEventDeclaration* node;
				public:
					EventDeclarationBuilder(WfEventDeclaration* _node) : node(_node) {}
					EventDeclarationBuilder& arguments(const vl::Ptr<WfType>& value);
				};

				class ExpectedTypeCastExpressionBuilder
				{
				private:
					WfExpectedTypeCastExpression* node;
				public:
					ExpectedTypeCastExpressionBuilder(WfExpectedTypeCastExpression* _node) : node(_node) {}
					ExpectedTypeCastExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					ExpectedTypeCastExpressionBuilder& strategy(WfTypeCastingStrategy value);
				};

				class ExpressionStatementBuilder
				{
				private:
					WfExpressionStatement* node;
				public:
					ExpressionStatementBuilder(WfExpressionStatement* _node) : node(_node) {}
					ExpressionStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class FloatingExpressionBuilder
				{
				private:
					WfFloatingExpression* node;
				public:
					FloatingExpressionBuilder(WfFloatingExpression* _node) : node(_node) {}
					FloatingExpressionBuilder& value(const vl::WString& value);
				};

				class ForEachStatementBuilder
				{
				private:
					WfForEachStatement* node;
				public:
					ForEachStatementBuilder(WfForEachStatement* _node) : node(_node) {}
					ForEachStatementBuilder& collection(const vl::Ptr<WfExpression>& value);
					ForEachStatementBuilder& direction(WfForEachDirection value);
					ForEachStatementBuilder& name(const vl::WString& value);
					ForEachStatementBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class FormatExpressionBuilder
				{
				private:
					WfFormatExpression* node;
				public:
					FormatExpressionBuilder(WfFormatExpression* _node) : node(_node) {}
					FormatExpressionBuilder& value(const vl::WString& value);
				};

				class FunctionArgumentBuilder
				{
				private:
					WfFunctionArgument* node;
				public:
					FunctionArgumentBuilder(WfFunctionArgument* _node) : node(_node) {}
					FunctionArgumentBuilder& attributes(const vl::Ptr<WfAttribute>& value);
					FunctionArgumentBuilder& name(const vl::WString& value);
					FunctionArgumentBuilder& type(const vl::Ptr<WfType>& value);
				};

				class FunctionDeclarationBuilder
				{
				private:
					WfFunctionDeclaration* node;
				public:
					FunctionDeclarationBuilder(WfFunctionDeclaration* _node) : node(_node) {}
					FunctionDeclarationBuilder& anonymity(WfFunctionAnonymity value);
					FunctionDeclarationBuilder& arguments(const vl::Ptr<WfFunctionArgument>& value);
					FunctionDeclarationBuilder& functionKind(WfFunctionKind value);
					FunctionDeclarationBuilder& returnType(const vl::Ptr<WfType>& value);
					FunctionDeclarationBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class FunctionExpressionBuilder
				{
				private:
					WfFunctionExpression* node;
				public:
					FunctionExpressionBuilder(WfFunctionExpression* _node) : node(_node) {}
					FunctionExpressionBuilder& function(const vl::Ptr<WfFunctionDeclaration>& value);
				};

				class FunctionTypeBuilder
				{
				private:
					WfFunctionType* node;
				public:
					FunctionTypeBuilder(WfFunctionType* _node) : node(_node) {}
					FunctionTypeBuilder& arguments(const vl::Ptr<WfType>& value);
					FunctionTypeBuilder& result(const vl::Ptr<WfType>& value);
				};

				class GotoStatementBuilder
				{
				private:
					WfGotoStatement* node;
				public:
					GotoStatementBuilder(WfGotoStatement* _node) : node(_node) {}
					GotoStatementBuilder& label(const vl::WString& value);
				};

				class IfExpressionBuilder
				{
				private:
					WfIfExpression* node;
				public:
					IfExpressionBuilder(WfIfExpression* _node) : node(_node) {}
					IfExpressionBuilder& condition(const vl::Ptr<WfExpression>& value);
					IfExpressionBuilder& falseBranch(const vl::Ptr<WfExpression>& value);
					IfExpressionBuilder& trueBranch(const vl::Ptr<WfExpression>& value);
				};

				class IfStatementBuilder
				{
				private:
					WfIfStatement* node;
				public:
					IfStatementBuilder(WfIfStatement* _node) : node(_node) {}
					IfStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
					IfStatementBuilder& falseBranch(const vl::Ptr<WfStatement>& value);
					IfStatementBuilder& name(const vl::WString& value);
					IfStatementBuilder& trueBranch(const vl::Ptr<WfStatement>& value);
					IfStatementBuilder& type(const vl::Ptr<WfType>& value);
				};

				class InferExpressionBuilder
				{
				private:
					WfInferExpression* node;
				public:
					InferExpressionBuilder(WfInferExpression* _node) : node(_node) {}
					InferExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					InferExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class IntegerExpressionBuilder
				{
				private:
					WfIntegerExpression* node;
				public:
					IntegerExpressionBuilder(WfIntegerExpression* _node) : node(_node) {}
					IntegerExpressionBuilder& value(const vl::WString& value);
				};

				class LetExpressionBuilder
				{
				private:
					WfLetExpression* node;
				public:
					LetExpressionBuilder(WfLetExpression* _node) : node(_node) {}
					LetExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					LetExpressionBuilder& variables(const vl::Ptr<WfLetVariable>& value);
				};

				class LetVariableBuilder
				{
				private:
					WfLetVariable* node;
				public:
					LetVariableBuilder(WfLetVariable* _node) : node(_node) {}
					LetVariableBuilder& name(const vl::WString& value);
					LetVariableBuilder& value(const vl::Ptr<WfExpression>& value);
				};

				class LiteralExpressionBuilder
				{
				private:
					WfLiteralExpression* node;
				public:
					LiteralExpressionBuilder(WfLiteralExpression* _node) : node(_node) {}
					LiteralExpressionBuilder& value(WfLiteralValue value);
				};

				class MapTypeBuilder
				{
				private:
					WfMapType* node;
				public:
					MapTypeBuilder(WfMapType* _node) : node(_node) {}
					MapTypeBuilder& key(const vl::Ptr<WfType>& value);
					MapTypeBuilder& value(const vl::Ptr<WfType>& value);
					MapTypeBuilder& writability(WfMapWritability value);
				};

				class MemberExpressionBuilder
				{
				private:
					WfMemberExpression* node;
				public:
					MemberExpressionBuilder(WfMemberExpression* _node) : node(_node) {}
					MemberExpressionBuilder& name(const vl::WString& value);
					MemberExpressionBuilder& parent(const vl::Ptr<WfExpression>& value);
				};

				class MixinCastExpressionBuilder
				{
				private:
					WfMixinCastExpression* node;
				public:
					MixinCastExpressionBuilder(WfMixinCastExpression* _node) : node(_node) {}
					MixinCastExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					MixinCastExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class ModuleBuilder
				{
				private:
					WfModule* node;
				public:
					ModuleBuilder(WfModule* _node) : node(_node) {}
					ModuleBuilder& declarations(const vl::Ptr<WfDeclaration>& value);
					ModuleBuilder& moduleType(WfModuleType value);
					ModuleBuilder& name(const vl::WString& value);
					ModuleBuilder& paths(const vl::Ptr<WfModuleUsingPath>& value);
				};

				class ModuleUsingItemBuilder
				{
				private:
					WfModuleUsingItem* node;
				public:
					ModuleUsingItemBuilder(WfModuleUsingItem* _node) : node(_node) {}
					ModuleUsingItemBuilder& fragments(const vl::Ptr<WfModuleUsingFragment>& value);
				};

				class ModuleUsingNameFragmentBuilder
				{
				private:
					WfModuleUsingNameFragment* node;
				public:
					ModuleUsingNameFragmentBuilder(WfModuleUsingNameFragment* _node) : node(_node) {}
					ModuleUsingNameFragmentBuilder& name(const vl::WString& value);
				};

				class ModuleUsingPathBuilder
				{
				private:
					WfModuleUsingPath* node;
				public:
					ModuleUsingPathBuilder(WfModuleUsingPath* _node) : node(_node) {}
					ModuleUsingPathBuilder& items(const vl::Ptr<WfModuleUsingItem>& value);
				};

				class NamespaceDeclarationBuilder
				{
				private:
					WfNamespaceDeclaration* node;
				public:
					NamespaceDeclarationBuilder(WfNamespaceDeclaration* _node) : node(_node) {}
					NamespaceDeclarationBuilder& declarations(const vl::Ptr<WfDeclaration>& value);
				};

				class NewClassExpressionBuilder
				{
				private:
					WfNewClassExpression* node;
				public:
					NewClassExpressionBuilder(WfNewClassExpression* _node) : node(_node) {}
					NewClassExpressionBuilder& arguments(const vl::Ptr<WfExpression>& value);
					NewClassExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class NewCoroutineExpressionBuilder
				{
				private:
					WfNewCoroutineExpression* node;
				public:
					NewCoroutineExpressionBuilder(WfNewCoroutineExpression* _node) : node(_node) {}
					NewCoroutineExpressionBuilder& name(const vl::WString& value);
					NewCoroutineExpressionBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class NewInterfaceExpressionBuilder
				{
				private:
					WfNewInterfaceExpression* node;
				public:
					NewInterfaceExpressionBuilder(WfNewInterfaceExpression* _node) : node(_node) {}
					NewInterfaceExpressionBuilder& declarations(const vl::Ptr<WfDeclaration>& value);
					NewInterfaceExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class NullableTypeBuilder
				{
				private:
					WfNullableType* node;
				public:
					NullableTypeBuilder(WfNullableType* _node) : node(_node) {}
					NullableTypeBuilder& element(const vl::Ptr<WfType>& value);
				};

				class ObservableListTypeBuilder
				{
				private:
					WfObservableListType* node;
				public:
					ObservableListTypeBuilder(WfObservableListType* _node) : node(_node) {}
					ObservableListTypeBuilder& element(const vl::Ptr<WfType>& value);
				};

				class ObserveExpressionBuilder
				{
				private:
					WfObserveExpression* node;
				public:
					ObserveExpressionBuilder(WfObserveExpression* _node) : node(_node) {}
					ObserveExpressionBuilder& events(const vl::Ptr<WfExpression>& value);
					ObserveExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					ObserveExpressionBuilder& name(const vl::WString& value);
					ObserveExpressionBuilder& observeType(WfObserveType value);
					ObserveExpressionBuilder& parent(const vl::Ptr<WfExpression>& value);
				};

				class OrderedLambdaExpressionBuilder
				{
				private:
					WfOrderedLambdaExpression* node;
				public:
					OrderedLambdaExpressionBuilder(WfOrderedLambdaExpression* _node) : node(_node) {}
					OrderedLambdaExpressionBuilder& body(const vl::Ptr<WfExpression>& value);
				};

				class OrderedNameExpressionBuilder
				{
				private:
					WfOrderedNameExpression* node;
				public:
					OrderedNameExpressionBuilder(WfOrderedNameExpression* _node) : node(_node) {}
					OrderedNameExpressionBuilder& name(const vl::WString& value);
				};

				class PredefinedTypeBuilder
				{
				private:
					WfPredefinedType* node;
				public:
					PredefinedTypeBuilder(WfPredefinedType* _node) : node(_node) {}
					PredefinedTypeBuilder& name(WfPredefinedTypeName value);
				};

				class PropertyDeclarationBuilder
				{
				private:
					WfPropertyDeclaration* node;
				public:
					PropertyDeclarationBuilder(WfPropertyDeclaration* _node) : node(_node) {}
					PropertyDeclarationBuilder& getter(const vl::WString& value);
					PropertyDeclarationBuilder& setter(const vl::WString& value);
					PropertyDeclarationBuilder& type(const vl::Ptr<WfType>& value);
					PropertyDeclarationBuilder& valueChangedEvent(const vl::WString& value);
				};

				class RaiseExceptionStatementBuilder
				{
				private:
					WfRaiseExceptionStatement* node;
				public:
					RaiseExceptionStatementBuilder(WfRaiseExceptionStatement* _node) : node(_node) {}
					RaiseExceptionStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class RangeExpressionBuilder
				{
				private:
					WfRangeExpression* node;
				public:
					RangeExpressionBuilder(WfRangeExpression* _node) : node(_node) {}
					RangeExpressionBuilder& begin(const vl::Ptr<WfExpression>& value);
					RangeExpressionBuilder& beginBoundary(WfRangeBoundary value);
					RangeExpressionBuilder& end(const vl::Ptr<WfExpression>& value);
					RangeExpressionBuilder& endBoundary(WfRangeBoundary value);
				};

				class RawPointerTypeBuilder
				{
				private:
					WfRawPointerType* node;
				public:
					RawPointerTypeBuilder(WfRawPointerType* _node) : node(_node) {}
					RawPointerTypeBuilder& element(const vl::Ptr<WfType>& value);
				};

				class ReferenceExpressionBuilder
				{
				private:
					WfReferenceExpression* node;
				public:
					ReferenceExpressionBuilder(WfReferenceExpression* _node) : node(_node) {}
					ReferenceExpressionBuilder& name(const vl::WString& value);
				};

				class ReferenceTypeBuilder
				{
				private:
					WfReferenceType* node;
				public:
					ReferenceTypeBuilder(WfReferenceType* _node) : node(_node) {}
					ReferenceTypeBuilder& name(const vl::WString& value);
				};

				class ReturnStatementBuilder
				{
				private:
					WfReturnStatement* node;
				public:
					ReturnStatementBuilder(WfReturnStatement* _node) : node(_node) {}
					ReturnStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class SetTestingExpressionBuilder
				{
				private:
					WfSetTestingExpression* node;
				public:
					SetTestingExpressionBuilder(WfSetTestingExpression* _node) : node(_node) {}
					SetTestingExpressionBuilder& collection(const vl::Ptr<WfExpression>& value);
					SetTestingExpressionBuilder& element(const vl::Ptr<WfExpression>& value);
					SetTestingExpressionBuilder& test(WfSetTesting value);
				};

				class SharedPointerTypeBuilder
				{
				private:
					WfSharedPointerType* node;
				public:
					SharedPointerTypeBuilder(WfSharedPointerType* _node) : node(_node) {}
					SharedPointerTypeBuilder& element(const vl::Ptr<WfType>& value);
				};

				class StateDeclarationBuilder
				{
				private:
					WfStateDeclaration* node;
				public:
					StateDeclarationBuilder(WfStateDeclaration* _node) : node(_node) {}
					StateDeclarationBuilder& arguments(const vl::Ptr<WfFunctionArgument>& value);
					StateDeclarationBuilder& name(const vl::WString& value);
					StateDeclarationBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class StateInputBuilder
				{
				private:
					WfStateInput* node;
				public:
					StateInputBuilder(WfStateInput* _node) : node(_node) {}
					StateInputBuilder& arguments(const vl::Ptr<WfFunctionArgument>& value);
					StateInputBuilder& name(const vl::WString& value);
				};

				class StateInvokeStatementBuilder
				{
				private:
					WfStateInvokeStatement* node;
				public:
					StateInvokeStatementBuilder(WfStateInvokeStatement* _node) : node(_node) {}
					StateInvokeStatementBuilder& arguments(const vl::Ptr<WfExpression>& value);
					StateInvokeStatementBuilder& name(const vl::WString& value);
					StateInvokeStatementBuilder& type(WfStateInvokeType value);
				};

				class StateMachineDeclarationBuilder
				{
				private:
					WfStateMachineDeclaration* node;
				public:
					StateMachineDeclarationBuilder(WfStateMachineDeclaration* _node) : node(_node) {}
					StateMachineDeclarationBuilder& inputs(const vl::Ptr<WfStateInput>& value);
					StateMachineDeclarationBuilder& states(const vl::Ptr<WfStateDeclaration>& value);
				};

				class StateSwitchArgumentBuilder
				{
				private:
					WfStateSwitchArgument* node;
				public:
					StateSwitchArgumentBuilder(WfStateSwitchArgument* _node) : node(_node) {}
					StateSwitchArgumentBuilder& name(const vl::WString& value);
				};

				class StateSwitchCaseBuilder
				{
				private:
					WfStateSwitchCase* node;
				public:
					StateSwitchCaseBuilder(WfStateSwitchCase* _node) : node(_node) {}
					StateSwitchCaseBuilder& arguments(const vl::Ptr<WfStateSwitchArgument>& value);
					StateSwitchCaseBuilder& name(const vl::WString& value);
					StateSwitchCaseBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class StateSwitchStatementBuilder
				{
				private:
					WfStateSwitchStatement* node;
				public:
					StateSwitchStatementBuilder(WfStateSwitchStatement* _node) : node(_node) {}
					StateSwitchStatementBuilder& caseBranches(const vl::Ptr<WfStateSwitchCase>& value);
					StateSwitchStatementBuilder& type(WfStateSwitchType value);
				};

				class StringExpressionBuilder
				{
				private:
					WfStringExpression* node;
				public:
					StringExpressionBuilder(WfStringExpression* _node) : node(_node) {}
					StringExpressionBuilder& value(const vl::WString& value);
				};

				class StructDeclarationBuilder
				{
				private:
					WfStructDeclaration* node;
				public:
					StructDeclarationBuilder(WfStructDeclaration* _node) : node(_node) {}
					StructDeclarationBuilder& members(const vl::Ptr<WfStructMember>& value);
				};

				class StructMemberBuilder
				{
				private:
					WfStructMember* node;
				public:
					StructMemberBuilder(WfStructMember* _node) : node(_node) {}
					StructMemberBuilder& attributes(const vl::Ptr<WfAttribute>& value);
					StructMemberBuilder& name(const vl::WString& value);
					StructMemberBuilder& type(const vl::Ptr<WfType>& value);
				};

				class SwitchCaseBuilder
				{
				private:
					WfSwitchCase* node;
				public:
					SwitchCaseBuilder(WfSwitchCase* _node) : node(_node) {}
					SwitchCaseBuilder& expression(const vl::Ptr<WfExpression>& value);
					SwitchCaseBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				class SwitchStatementBuilder
				{
				private:
					WfSwitchStatement* node;
				public:
					SwitchStatementBuilder(WfSwitchStatement* _node) : node(_node) {}
					SwitchStatementBuilder& caseBranches(const vl::Ptr<WfSwitchCase>& value);
					SwitchStatementBuilder& defaultBranch(const vl::Ptr<WfStatement>& value);
					SwitchStatementBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class TopQualifiedExpressionBuilder
				{
				private:
					WfTopQualifiedExpression* node;
				public:
					TopQualifiedExpressionBuilder(WfTopQualifiedExpression* _node) : node(_node) {}
					TopQualifiedExpressionBuilder& name(const vl::WString& value);
				};

				class TopQualifiedTypeBuilder
				{
				private:
					WfTopQualifiedType* node;
				public:
					TopQualifiedTypeBuilder(WfTopQualifiedType* _node) : node(_node) {}
					TopQualifiedTypeBuilder& name(const vl::WString& value);
				};

				class TryStatementBuilder
				{
				private:
					WfTryStatement* node;
				public:
					TryStatementBuilder(WfTryStatement* _node) : node(_node) {}
					TryStatementBuilder& catchStatement(const vl::Ptr<WfStatement>& value);
					TryStatementBuilder& finallyStatement(const vl::Ptr<WfStatement>& value);
					TryStatementBuilder& name(const vl::WString& value);
					TryStatementBuilder& protectedStatement(const vl::Ptr<WfStatement>& value);
				};

				class TypeCastingExpressionBuilder
				{
				private:
					WfTypeCastingExpression* node;
				public:
					TypeCastingExpressionBuilder(WfTypeCastingExpression* _node) : node(_node) {}
					TypeCastingExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					TypeCastingExpressionBuilder& strategy(WfTypeCastingStrategy value);
					TypeCastingExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class TypeOfExpressionExpressionBuilder
				{
				private:
					WfTypeOfExpressionExpression* node;
				public:
					TypeOfExpressionExpressionBuilder(WfTypeOfExpressionExpression* _node) : node(_node) {}
					TypeOfExpressionExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
				};

				class TypeOfTypeExpressionBuilder
				{
				private:
					WfTypeOfTypeExpression* node;
				public:
					TypeOfTypeExpressionBuilder(WfTypeOfTypeExpression* _node) : node(_node) {}
					TypeOfTypeExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class TypeTestingExpressionBuilder
				{
				private:
					WfTypeTestingExpression* node;
				public:
					TypeTestingExpressionBuilder(WfTypeTestingExpression* _node) : node(_node) {}
					TypeTestingExpressionBuilder& expression(const vl::Ptr<WfExpression>& value);
					TypeTestingExpressionBuilder& test(WfTypeTesting value);
					TypeTestingExpressionBuilder& type(const vl::Ptr<WfType>& value);
				};

				class UnaryExpressionBuilder
				{
				private:
					WfUnaryExpression* node;
				public:
					UnaryExpressionBuilder(WfUnaryExpression* _node) : node(_node) {}
					UnaryExpressionBuilder& op(WfUnaryOperator value);
					UnaryExpressionBuilder& operand(const vl::Ptr<WfExpression>& value);
				};

				class VariableDeclarationBuilder
				{
				private:
					WfVariableDeclaration* node;
				public:
					VariableDeclarationBuilder(WfVariableDeclaration* _node) : node(_node) {}
					VariableDeclarationBuilder& expression(const vl::Ptr<WfExpression>& value);
					VariableDeclarationBuilder& type(const vl::Ptr<WfType>& value);
				};

				class VariableStatementBuilder
				{
				private:
					WfVariableStatement* node;
				public:
					VariableStatementBuilder(WfVariableStatement* _node) : node(_node) {}
					VariableStatementBuilder& variable(const vl::Ptr<WfVariableDeclaration>& value);
				};

				class VirtualCfeDeclarationBuilder
				{
				private:
					WfVirtualCfeDeclaration* node;
				public:
					VirtualCfeDeclarationBuilder(WfVirtualCfeDeclaration* _node) : node(_node) {}
					VirtualCfeDeclarationBuilder& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
				};

				class VirtualCfeExpressionBuilder
				{
				private:
					WfVirtualCfeExpression* node;
				public:
					VirtualCfeExpressionBuilder(WfVirtualCfeExpression* _node) : node(_node) {}
					VirtualCfeExpressionBuilder& expandedExpression(const vl::Ptr<WfExpression>& value);
				};

				class VirtualCseDeclarationBuilder
				{
				private:
					WfVirtualCseDeclaration* node;
				public:
					VirtualCseDeclarationBuilder(WfVirtualCseDeclaration* _node) : node(_node) {}
					VirtualCseDeclarationBuilder& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
				};

				class VirtualCseExpressionBuilder
				{
				private:
					WfVirtualCseExpression* node;
				public:
					VirtualCseExpressionBuilder(WfVirtualCseExpression* _node) : node(_node) {}
					VirtualCseExpressionBuilder& expandedExpression(const vl::Ptr<WfExpression>& value);
				};

				class VirtualCseStatementBuilder
				{
				private:
					WfVirtualCseStatement* node;
				public:
					VirtualCseStatementBuilder(WfVirtualCseStatement* _node) : node(_node) {}
					VirtualCseStatementBuilder& expandedStatement(const vl::Ptr<WfStatement>& value);
				};

				class WhileStatementBuilder
				{
				private:
					WfWhileStatement* node;
				public:
					WhileStatementBuilder(WfWhileStatement* _node) : node(_node) {}
					WhileStatementBuilder& condition(const vl::Ptr<WfExpression>& value);
					WhileStatementBuilder& statement(const vl::Ptr<WfStatement>& value);
				};

				using MakeAttachEventExpression = vl::glr::ParsingAstBuilder<WfAttachEventExpression, AttachEventExpressionBuilder>;
				using MakeAttribute = vl::glr::ParsingAstBuilder<WfAttribute, AttributeBuilder>;
				using MakeAutoPropertyDeclaration = vl::glr::ParsingAstBuilder<WfAutoPropertyDeclaration, AutoPropertyDeclarationBuilder, VirtualCfeDeclarationBuilder, DeclarationBuilder>;
				using MakeBaseConstructorCall = vl::glr::ParsingAstBuilder<WfBaseConstructorCall, BaseConstructorCallBuilder>;
				using MakeBinaryExpression = vl::glr::ParsingAstBuilder<WfBinaryExpression, BinaryExpressionBuilder>;
				using MakeBindExpression = vl::glr::ParsingAstBuilder<WfBindExpression, BindExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeBlockStatement = vl::glr::ParsingAstBuilder<WfBlockStatement, BlockStatementBuilder>;
				using MakeBreakStatement = vl::glr::ParsingAstBuilder<WfBreakStatement>;
				using MakeCallExpression = vl::glr::ParsingAstBuilder<WfCallExpression, CallExpressionBuilder>;
				using MakeCastResultInterfaceDeclaration = vl::glr::ParsingAstBuilder<WfCastResultInterfaceDeclaration, CastResultInterfaceDeclarationBuilder, VirtualCfeDeclarationBuilder, DeclarationBuilder>;
				using MakeChildExpression = vl::glr::ParsingAstBuilder<WfChildExpression, ChildExpressionBuilder>;
				using MakeChildType = vl::glr::ParsingAstBuilder<WfChildType, ChildTypeBuilder>;
				using MakeClassDeclaration = vl::glr::ParsingAstBuilder<WfClassDeclaration, ClassDeclarationBuilder, DeclarationBuilder>;
				using MakeCoOperatorExpression = vl::glr::ParsingAstBuilder<WfCoOperatorExpression, CoOperatorExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeCoOperatorStatement = vl::glr::ParsingAstBuilder<WfCoOperatorStatement, CoOperatorStatementBuilder>;
				using MakeCoPauseStatement = vl::glr::ParsingAstBuilder<WfCoPauseStatement, CoPauseStatementBuilder>;
				using MakeCoProviderStatement = vl::glr::ParsingAstBuilder<WfCoProviderStatement, CoProviderStatementBuilder, VirtualCseStatementBuilder>;
				using MakeConstructorArgument = vl::glr::ParsingAstBuilder<WfConstructorArgument, ConstructorArgumentBuilder>;
				using MakeConstructorDeclaration = vl::glr::ParsingAstBuilder<WfConstructorDeclaration, ConstructorDeclarationBuilder, DeclarationBuilder>;
				using MakeConstructorExpression = vl::glr::ParsingAstBuilder<WfConstructorExpression, ConstructorExpressionBuilder>;
				using MakeContinueStatement = vl::glr::ParsingAstBuilder<WfContinueStatement>;
				using MakeDeleteStatement = vl::glr::ParsingAstBuilder<WfDeleteStatement, DeleteStatementBuilder>;
				using MakeDestructorDeclaration = vl::glr::ParsingAstBuilder<WfDestructorDeclaration, DestructorDeclarationBuilder, DeclarationBuilder>;
				using MakeDetachEventExpression = vl::glr::ParsingAstBuilder<WfDetachEventExpression, DetachEventExpressionBuilder>;
				using MakeEnumDeclaration = vl::glr::ParsingAstBuilder<WfEnumDeclaration, EnumDeclarationBuilder, DeclarationBuilder>;
				using MakeEnumItem = vl::glr::ParsingAstBuilder<WfEnumItem, EnumItemBuilder>;
				using MakeEnumItemIntersection = vl::glr::ParsingAstBuilder<WfEnumItemIntersection, EnumItemIntersectionBuilder>;
				using MakeEnumerableType = vl::glr::ParsingAstBuilder<WfEnumerableType, EnumerableTypeBuilder>;
				using MakeEventDeclaration = vl::glr::ParsingAstBuilder<WfEventDeclaration, EventDeclarationBuilder, DeclarationBuilder>;
				using MakeExpectedTypeCastExpression = vl::glr::ParsingAstBuilder<WfExpectedTypeCastExpression, ExpectedTypeCastExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeExpressionStatement = vl::glr::ParsingAstBuilder<WfExpressionStatement, ExpressionStatementBuilder>;
				using MakeFloatingExpression = vl::glr::ParsingAstBuilder<WfFloatingExpression, FloatingExpressionBuilder>;
				using MakeForEachStatement = vl::glr::ParsingAstBuilder<WfForEachStatement, ForEachStatementBuilder, VirtualCseStatementBuilder>;
				using MakeFormatExpression = vl::glr::ParsingAstBuilder<WfFormatExpression, FormatExpressionBuilder, VirtualCfeExpressionBuilder>;
				using MakeFunctionArgument = vl::glr::ParsingAstBuilder<WfFunctionArgument, FunctionArgumentBuilder>;
				using MakeFunctionDeclaration = vl::glr::ParsingAstBuilder<WfFunctionDeclaration, FunctionDeclarationBuilder, DeclarationBuilder>;
				using MakeFunctionExpression = vl::glr::ParsingAstBuilder<WfFunctionExpression, FunctionExpressionBuilder>;
				using MakeFunctionType = vl::glr::ParsingAstBuilder<WfFunctionType, FunctionTypeBuilder>;
				using MakeGotoStatement = vl::glr::ParsingAstBuilder<WfGotoStatement, GotoStatementBuilder>;
				using MakeIfExpression = vl::glr::ParsingAstBuilder<WfIfExpression, IfExpressionBuilder>;
				using MakeIfStatement = vl::glr::ParsingAstBuilder<WfIfStatement, IfStatementBuilder>;
				using MakeInferExpression = vl::glr::ParsingAstBuilder<WfInferExpression, InferExpressionBuilder>;
				using MakeIntegerExpression = vl::glr::ParsingAstBuilder<WfIntegerExpression, IntegerExpressionBuilder>;
				using MakeLetExpression = vl::glr::ParsingAstBuilder<WfLetExpression, LetExpressionBuilder>;
				using MakeLetVariable = vl::glr::ParsingAstBuilder<WfLetVariable, LetVariableBuilder>;
				using MakeLiteralExpression = vl::glr::ParsingAstBuilder<WfLiteralExpression, LiteralExpressionBuilder>;
				using MakeMapType = vl::glr::ParsingAstBuilder<WfMapType, MapTypeBuilder>;
				using MakeMemberExpression = vl::glr::ParsingAstBuilder<WfMemberExpression, MemberExpressionBuilder>;
				using MakeMixinCastExpression = vl::glr::ParsingAstBuilder<WfMixinCastExpression, MixinCastExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeModule = vl::glr::ParsingAstBuilder<WfModule, ModuleBuilder>;
				using MakeModuleUsingItem = vl::glr::ParsingAstBuilder<WfModuleUsingItem, ModuleUsingItemBuilder>;
				using MakeModuleUsingNameFragment = vl::glr::ParsingAstBuilder<WfModuleUsingNameFragment, ModuleUsingNameFragmentBuilder>;
				using MakeModuleUsingPath = vl::glr::ParsingAstBuilder<WfModuleUsingPath, ModuleUsingPathBuilder>;
				using MakeModuleUsingWildCardFragment = vl::glr::ParsingAstBuilder<WfModuleUsingWildCardFragment>;
				using MakeNamespaceDeclaration = vl::glr::ParsingAstBuilder<WfNamespaceDeclaration, NamespaceDeclarationBuilder, DeclarationBuilder>;
				using MakeNewClassExpression = vl::glr::ParsingAstBuilder<WfNewClassExpression, NewClassExpressionBuilder>;
				using MakeNewCoroutineExpression = vl::glr::ParsingAstBuilder<WfNewCoroutineExpression, NewCoroutineExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeNewInterfaceExpression = vl::glr::ParsingAstBuilder<WfNewInterfaceExpression, NewInterfaceExpressionBuilder>;
				using MakeNullableType = vl::glr::ParsingAstBuilder<WfNullableType, NullableTypeBuilder>;
				using MakeObservableListType = vl::glr::ParsingAstBuilder<WfObservableListType, ObservableListTypeBuilder>;
				using MakeObserveExpression = vl::glr::ParsingAstBuilder<WfObserveExpression, ObserveExpressionBuilder>;
				using MakeOrderedLambdaExpression = vl::glr::ParsingAstBuilder<WfOrderedLambdaExpression, OrderedLambdaExpressionBuilder>;
				using MakeOrderedNameExpression = vl::glr::ParsingAstBuilder<WfOrderedNameExpression, OrderedNameExpressionBuilder>;
				using MakePredefinedType = vl::glr::ParsingAstBuilder<WfPredefinedType, PredefinedTypeBuilder>;
				using MakePropertyDeclaration = vl::glr::ParsingAstBuilder<WfPropertyDeclaration, PropertyDeclarationBuilder, DeclarationBuilder>;
				using MakeRaiseExceptionStatement = vl::glr::ParsingAstBuilder<WfRaiseExceptionStatement, RaiseExceptionStatementBuilder>;
				using MakeRangeExpression = vl::glr::ParsingAstBuilder<WfRangeExpression, RangeExpressionBuilder>;
				using MakeRawPointerType = vl::glr::ParsingAstBuilder<WfRawPointerType, RawPointerTypeBuilder>;
				using MakeReferenceExpression = vl::glr::ParsingAstBuilder<WfReferenceExpression, ReferenceExpressionBuilder>;
				using MakeReferenceType = vl::glr::ParsingAstBuilder<WfReferenceType, ReferenceTypeBuilder>;
				using MakeReturnStatement = vl::glr::ParsingAstBuilder<WfReturnStatement, ReturnStatementBuilder>;
				using MakeSetTestingExpression = vl::glr::ParsingAstBuilder<WfSetTestingExpression, SetTestingExpressionBuilder>;
				using MakeSharedPointerType = vl::glr::ParsingAstBuilder<WfSharedPointerType, SharedPointerTypeBuilder>;
				using MakeStateDeclaration = vl::glr::ParsingAstBuilder<WfStateDeclaration, StateDeclarationBuilder>;
				using MakeStateInput = vl::glr::ParsingAstBuilder<WfStateInput, StateInputBuilder>;
				using MakeStateInvokeStatement = vl::glr::ParsingAstBuilder<WfStateInvokeStatement, StateInvokeStatementBuilder>;
				using MakeStateMachineDeclaration = vl::glr::ParsingAstBuilder<WfStateMachineDeclaration, StateMachineDeclarationBuilder, VirtualCseDeclarationBuilder, DeclarationBuilder>;
				using MakeStateSwitchArgument = vl::glr::ParsingAstBuilder<WfStateSwitchArgument, StateSwitchArgumentBuilder>;
				using MakeStateSwitchCase = vl::glr::ParsingAstBuilder<WfStateSwitchCase, StateSwitchCaseBuilder>;
				using MakeStateSwitchStatement = vl::glr::ParsingAstBuilder<WfStateSwitchStatement, StateSwitchStatementBuilder>;
				using MakeStringExpression = vl::glr::ParsingAstBuilder<WfStringExpression, StringExpressionBuilder>;
				using MakeStructDeclaration = vl::glr::ParsingAstBuilder<WfStructDeclaration, StructDeclarationBuilder, DeclarationBuilder>;
				using MakeStructMember = vl::glr::ParsingAstBuilder<WfStructMember, StructMemberBuilder>;
				using MakeSwitchCase = vl::glr::ParsingAstBuilder<WfSwitchCase, SwitchCaseBuilder>;
				using MakeSwitchStatement = vl::glr::ParsingAstBuilder<WfSwitchStatement, SwitchStatementBuilder, VirtualCseStatementBuilder>;
				using MakeThisExpression = vl::glr::ParsingAstBuilder<WfThisExpression>;
				using MakeTopQualifiedExpression = vl::glr::ParsingAstBuilder<WfTopQualifiedExpression, TopQualifiedExpressionBuilder>;
				using MakeTopQualifiedType = vl::glr::ParsingAstBuilder<WfTopQualifiedType, TopQualifiedTypeBuilder>;
				using MakeTryStatement = vl::glr::ParsingAstBuilder<WfTryStatement, TryStatementBuilder>;
				using MakeTypeCastingExpression = vl::glr::ParsingAstBuilder<WfTypeCastingExpression, TypeCastingExpressionBuilder>;
				using MakeTypeOfExpressionExpression = vl::glr::ParsingAstBuilder<WfTypeOfExpressionExpression, TypeOfExpressionExpressionBuilder>;
				using MakeTypeOfTypeExpression = vl::glr::ParsingAstBuilder<WfTypeOfTypeExpression, TypeOfTypeExpressionBuilder>;
				using MakeTypeTestingExpression = vl::glr::ParsingAstBuilder<WfTypeTestingExpression, TypeTestingExpressionBuilder>;
				using MakeUnaryExpression = vl::glr::ParsingAstBuilder<WfUnaryExpression, UnaryExpressionBuilder>;
				using MakeVariableDeclaration = vl::glr::ParsingAstBuilder<WfVariableDeclaration, VariableDeclarationBuilder, DeclarationBuilder>;
				using MakeVariableStatement = vl::glr::ParsingAstBuilder<WfVariableStatement, VariableStatementBuilder>;
				using MakeWhileStatement = vl::glr::ParsingAstBuilder<WfWhileStatement, WhileStatementBuilder>;
			}
		}
	}
}
#endif