/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_BUILTIN_WORKFLOW_AST_AST_BUILDER
#define VCZH_PARSER2_BUILTIN_WORKFLOW_AST_AST_BUILDER

#include "WorkflowAst.h"

namespace vl
{
	namespace glr
	{
		namespace workflow
		{
			namespace builder
			{
				class AttachEventExpressionBuilder
				{
				private:
					WorkflowAttachEventExpression* node;
				public:
					AttachEventExpressionBuilder(WorkflowAttachEventExpression* _node) : node(_node) {}
					AttachEventExpressionBuilder& event(const vl::Ptr<WorkflowExpression>& value);
					AttachEventExpressionBuilder& function(const vl::Ptr<WorkflowExpression>& value);
				};

				class AttributeBuilder
				{
				private:
					WorkflowAttribute* node;
				public:
					AttributeBuilder(WorkflowAttribute* _node) : node(_node) {}
					AttributeBuilder& category(const vl::WString& value);
					AttributeBuilder& name(const vl::WString& value);
					AttributeBuilder& value(const vl::Ptr<WorkflowExpression>& value);
				};

				class AutoPropertyDeclarationBuilder
				{
				private:
					WorkflowAutoPropertyDeclaration* node;
				public:
					AutoPropertyDeclarationBuilder(WorkflowAutoPropertyDeclaration* _node) : node(_node) {}
					AutoPropertyDeclarationBuilder& configConst(WorkflowAPConst value);
					AutoPropertyDeclarationBuilder& configObserve(WorkflowAPObserve value);
					AutoPropertyDeclarationBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					AutoPropertyDeclarationBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class BaseConstructorCallBuilder
				{
				private:
					WorkflowBaseConstructorCall* node;
				public:
					BaseConstructorCallBuilder(WorkflowBaseConstructorCall* _node) : node(_node) {}
					BaseConstructorCallBuilder& arguments(const vl::Ptr<WorkflowExpression>& value);
					BaseConstructorCallBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class BinaryExpressionBuilder
				{
				private:
					WorkflowBinaryExpression* node;
				public:
					BinaryExpressionBuilder(WorkflowBinaryExpression* _node) : node(_node) {}
					BinaryExpressionBuilder& first(const vl::Ptr<WorkflowExpression>& value);
					BinaryExpressionBuilder& op(WorkflowBinaryOperator value);
					BinaryExpressionBuilder& second(const vl::Ptr<WorkflowExpression>& value);
				};

				class BindExpressionBuilder
				{
				private:
					WorkflowBindExpression* node;
				public:
					BindExpressionBuilder(WorkflowBindExpression* _node) : node(_node) {}
					BindExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class BlockStatementBuilder
				{
				private:
					WorkflowBlockStatement* node;
				public:
					BlockStatementBuilder(WorkflowBlockStatement* _node) : node(_node) {}
					BlockStatementBuilder& endLabel(const vl::WString& value);
					BlockStatementBuilder& statements(const vl::Ptr<WorkflowStatement>& value);
				};

				class CallExpressionBuilder
				{
				private:
					WorkflowCallExpression* node;
				public:
					CallExpressionBuilder(WorkflowCallExpression* _node) : node(_node) {}
					CallExpressionBuilder& arguments(const vl::Ptr<WorkflowExpression>& value);
					CallExpressionBuilder& function(const vl::Ptr<WorkflowExpression>& value);
				};

				class CastResultInterfaceDeclarationBuilder
				{
				private:
					WorkflowCastResultInterfaceDeclaration* node;
				public:
					CastResultInterfaceDeclarationBuilder(WorkflowCastResultInterfaceDeclaration* _node) : node(_node) {}
					CastResultInterfaceDeclarationBuilder& baseType(const vl::Ptr<WorkflowType>& value);
					CastResultInterfaceDeclarationBuilder& elementType(const vl::Ptr<WorkflowType>& value);
				};

				class ChildExpressionBuilder
				{
				private:
					WorkflowChildExpression* node;
				public:
					ChildExpressionBuilder(WorkflowChildExpression* _node) : node(_node) {}
					ChildExpressionBuilder& name(const vl::WString& value);
					ChildExpressionBuilder& parent(const vl::Ptr<WorkflowExpression>& value);
				};

				class ChildTypeBuilder
				{
				private:
					WorkflowChildType* node;
				public:
					ChildTypeBuilder(WorkflowChildType* _node) : node(_node) {}
					ChildTypeBuilder& name(const vl::WString& value);
					ChildTypeBuilder& parent(const vl::Ptr<WorkflowType>& value);
				};

				class ClassDeclarationBuilder
				{
				private:
					WorkflowClassDeclaration* node;
				public:
					ClassDeclarationBuilder(WorkflowClassDeclaration* _node) : node(_node) {}
					ClassDeclarationBuilder& baseTypes(const vl::Ptr<WorkflowType>& value);
					ClassDeclarationBuilder& constructorType(WorkflowConstructorType value);
					ClassDeclarationBuilder& declarations(const vl::Ptr<WorkflowDeclaration>& value);
					ClassDeclarationBuilder& kind(WorkflowClassKind value);
				};

				class ClassMemberBuilder
				{
				private:
					WorkflowClassMember* node;
				public:
					ClassMemberBuilder(WorkflowClassMember* _node) : node(_node) {}
					ClassMemberBuilder& kind(WorkflowClassMemberKind value);
				};

				class CoOperatorExpressionBuilder
				{
				private:
					WorkflowCoOperatorExpression* node;
				public:
					CoOperatorExpressionBuilder(WorkflowCoOperatorExpression* _node) : node(_node) {}
					CoOperatorExpressionBuilder& name(const vl::WString& value);
				};

				class CoOperatorStatementBuilder
				{
				private:
					WorkflowCoOperatorStatement* node;
				public:
					CoOperatorStatementBuilder(WorkflowCoOperatorStatement* _node) : node(_node) {}
					CoOperatorStatementBuilder& arguments(const vl::Ptr<WorkflowExpression>& value);
					CoOperatorStatementBuilder& opName(const vl::WString& value);
					CoOperatorStatementBuilder& varName(const vl::WString& value);
				};

				class CoPauseStatementBuilder
				{
				private:
					WorkflowCoPauseStatement* node;
				public:
					CoPauseStatementBuilder(WorkflowCoPauseStatement* _node) : node(_node) {}
					CoPauseStatementBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class CoProviderStatementBuilder
				{
				private:
					WorkflowCoProviderStatement* node;
				public:
					CoProviderStatementBuilder(WorkflowCoProviderStatement* _node) : node(_node) {}
					CoProviderStatementBuilder& name(const vl::WString& value);
					CoProviderStatementBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class ConstructorArgumentBuilder
				{
				private:
					WorkflowConstructorArgument* node;
				public:
					ConstructorArgumentBuilder(WorkflowConstructorArgument* _node) : node(_node) {}
					ConstructorArgumentBuilder& key(const vl::Ptr<WorkflowExpression>& value);
					ConstructorArgumentBuilder& value(const vl::Ptr<WorkflowExpression>& value);
				};

				class ConstructorDeclarationBuilder
				{
				private:
					WorkflowConstructorDeclaration* node;
				public:
					ConstructorDeclarationBuilder(WorkflowConstructorDeclaration* _node) : node(_node) {}
					ConstructorDeclarationBuilder& arguments(const vl::Ptr<WorkflowFunctionArgument>& value);
					ConstructorDeclarationBuilder& baseConstructorCalls(const vl::Ptr<WorkflowBaseConstructorCall>& value);
					ConstructorDeclarationBuilder& constructorType(WorkflowConstructorType value);
					ConstructorDeclarationBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class ConstructorExpressionBuilder
				{
				private:
					WorkflowConstructorExpression* node;
				public:
					ConstructorExpressionBuilder(WorkflowConstructorExpression* _node) : node(_node) {}
					ConstructorExpressionBuilder& arguments(const vl::Ptr<WorkflowConstructorArgument>& value);
				};

				class DeclarationBuilder
				{
				private:
					WorkflowDeclaration* node;
				public:
					DeclarationBuilder(WorkflowDeclaration* _node) : node(_node) {}
					DeclarationBuilder& attributes(const vl::Ptr<WorkflowAttribute>& value);
					DeclarationBuilder& classMember(const vl::Ptr<WorkflowClassMember>& value);
					DeclarationBuilder& name(const vl::WString& value);
				};

				class DeleteStatementBuilder
				{
				private:
					WorkflowDeleteStatement* node;
				public:
					DeleteStatementBuilder(WorkflowDeleteStatement* _node) : node(_node) {}
					DeleteStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class DestructorDeclarationBuilder
				{
				private:
					WorkflowDestructorDeclaration* node;
				public:
					DestructorDeclarationBuilder(WorkflowDestructorDeclaration* _node) : node(_node) {}
					DestructorDeclarationBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class DetachEventExpressionBuilder
				{
				private:
					WorkflowDetachEventExpression* node;
				public:
					DetachEventExpressionBuilder(WorkflowDetachEventExpression* _node) : node(_node) {}
					DetachEventExpressionBuilder& event(const vl::Ptr<WorkflowExpression>& value);
					DetachEventExpressionBuilder& handler(const vl::Ptr<WorkflowExpression>& value);
				};

				class EnumDeclarationBuilder
				{
				private:
					WorkflowEnumDeclaration* node;
				public:
					EnumDeclarationBuilder(WorkflowEnumDeclaration* _node) : node(_node) {}
					EnumDeclarationBuilder& items(const vl::Ptr<WorkflowEnumItem>& value);
					EnumDeclarationBuilder& kind(WorkflowEnumKind value);
				};

				class EnumItemBuilder
				{
				private:
					WorkflowEnumItem* node;
				public:
					EnumItemBuilder(WorkflowEnumItem* _node) : node(_node) {}
					EnumItemBuilder& attributes(const vl::Ptr<WorkflowAttribute>& value);
					EnumItemBuilder& intersections(const vl::Ptr<WorkflowEnumItemIntersection>& value);
					EnumItemBuilder& kind(WorkflowEnumItemKind value);
					EnumItemBuilder& name(const vl::WString& value);
					EnumItemBuilder& number(const vl::WString& value);
				};

				class EnumItemIntersectionBuilder
				{
				private:
					WorkflowEnumItemIntersection* node;
				public:
					EnumItemIntersectionBuilder(WorkflowEnumItemIntersection* _node) : node(_node) {}
					EnumItemIntersectionBuilder& name(const vl::WString& value);
				};

				class EnumerableTypeBuilder
				{
				private:
					WorkflowEnumerableType* node;
				public:
					EnumerableTypeBuilder(WorkflowEnumerableType* _node) : node(_node) {}
					EnumerableTypeBuilder& element(const vl::Ptr<WorkflowType>& value);
				};

				class EventDeclarationBuilder
				{
				private:
					WorkflowEventDeclaration* node;
				public:
					EventDeclarationBuilder(WorkflowEventDeclaration* _node) : node(_node) {}
					EventDeclarationBuilder& arguments(const vl::Ptr<WorkflowType>& value);
				};

				class ExpectedTypeCastExpressionBuilder
				{
				private:
					WorkflowExpectedTypeCastExpression* node;
				public:
					ExpectedTypeCastExpressionBuilder(WorkflowExpectedTypeCastExpression* _node) : node(_node) {}
					ExpectedTypeCastExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					ExpectedTypeCastExpressionBuilder& strategy(WorkflowTypeCastingStrategy value);
				};

				class ExpressionStatementBuilder
				{
				private:
					WorkflowExpressionStatement* node;
				public:
					ExpressionStatementBuilder(WorkflowExpressionStatement* _node) : node(_node) {}
					ExpressionStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class FloatingExpressionBuilder
				{
				private:
					WorkflowFloatingExpression* node;
				public:
					FloatingExpressionBuilder(WorkflowFloatingExpression* _node) : node(_node) {}
					FloatingExpressionBuilder& value(const vl::WString& value);
				};

				class ForEachStatementBuilder
				{
				private:
					WorkflowForEachStatement* node;
				public:
					ForEachStatementBuilder(WorkflowForEachStatement* _node) : node(_node) {}
					ForEachStatementBuilder& collection(const vl::Ptr<WorkflowExpression>& value);
					ForEachStatementBuilder& direction(WorkflowForEachDirection value);
					ForEachStatementBuilder& name(const vl::WString& value);
					ForEachStatementBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class FormatExpressionBuilder
				{
				private:
					WorkflowFormatExpression* node;
				public:
					FormatExpressionBuilder(WorkflowFormatExpression* _node) : node(_node) {}
					FormatExpressionBuilder& value(const vl::WString& value);
				};

				class FunctionArgumentBuilder
				{
				private:
					WorkflowFunctionArgument* node;
				public:
					FunctionArgumentBuilder(WorkflowFunctionArgument* _node) : node(_node) {}
					FunctionArgumentBuilder& attributes(const vl::Ptr<WorkflowAttribute>& value);
					FunctionArgumentBuilder& name(const vl::WString& value);
					FunctionArgumentBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class FunctionDeclarationBuilder
				{
				private:
					WorkflowFunctionDeclaration* node;
				public:
					FunctionDeclarationBuilder(WorkflowFunctionDeclaration* _node) : node(_node) {}
					FunctionDeclarationBuilder& anonymity(WorkflowFunctionAnonymity value);
					FunctionDeclarationBuilder& arguments(const vl::Ptr<WorkflowFunctionArgument>& value);
					FunctionDeclarationBuilder& returnType(const vl::Ptr<WorkflowType>& value);
					FunctionDeclarationBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class FunctionExpressionBuilder
				{
				private:
					WorkflowFunctionExpression* node;
				public:
					FunctionExpressionBuilder(WorkflowFunctionExpression* _node) : node(_node) {}
					FunctionExpressionBuilder& function(const vl::Ptr<WorkflowFunctionDeclaration>& value);
				};

				class FunctionTypeBuilder
				{
				private:
					WorkflowFunctionType* node;
				public:
					FunctionTypeBuilder(WorkflowFunctionType* _node) : node(_node) {}
					FunctionTypeBuilder& arguments(const vl::Ptr<WorkflowType>& value);
					FunctionTypeBuilder& result(const vl::Ptr<WorkflowType>& value);
				};

				class GotoStatementBuilder
				{
				private:
					WorkflowGotoStatement* node;
				public:
					GotoStatementBuilder(WorkflowGotoStatement* _node) : node(_node) {}
					GotoStatementBuilder& label(const vl::WString& value);
				};

				class IfExpressionBuilder
				{
				private:
					WorkflowIfExpression* node;
				public:
					IfExpressionBuilder(WorkflowIfExpression* _node) : node(_node) {}
					IfExpressionBuilder& condition(const vl::Ptr<WorkflowExpression>& value);
					IfExpressionBuilder& falseBranch(const vl::Ptr<WorkflowExpression>& value);
					IfExpressionBuilder& trueBranch(const vl::Ptr<WorkflowExpression>& value);
				};

				class IfStatementBuilder
				{
				private:
					WorkflowIfStatement* node;
				public:
					IfStatementBuilder(WorkflowIfStatement* _node) : node(_node) {}
					IfStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					IfStatementBuilder& falseBranch(const vl::Ptr<WorkflowStatement>& value);
					IfStatementBuilder& name(const vl::WString& value);
					IfStatementBuilder& trueBranch(const vl::Ptr<WorkflowStatement>& value);
					IfStatementBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class InferExpressionBuilder
				{
				private:
					WorkflowInferExpression* node;
				public:
					InferExpressionBuilder(WorkflowInferExpression* _node) : node(_node) {}
					InferExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					InferExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class IntegerExpressionBuilder
				{
				private:
					WorkflowIntegerExpression* node;
				public:
					IntegerExpressionBuilder(WorkflowIntegerExpression* _node) : node(_node) {}
					IntegerExpressionBuilder& value(const vl::WString& value);
				};

				class LetExpressionBuilder
				{
				private:
					WorkflowLetExpression* node;
				public:
					LetExpressionBuilder(WorkflowLetExpression* _node) : node(_node) {}
					LetExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					LetExpressionBuilder& variables(const vl::Ptr<WorkflowLetVariable>& value);
				};

				class LetVariableBuilder
				{
				private:
					WorkflowLetVariable* node;
				public:
					LetVariableBuilder(WorkflowLetVariable* _node) : node(_node) {}
					LetVariableBuilder& name(const vl::WString& value);
					LetVariableBuilder& value(const vl::Ptr<WorkflowExpression>& value);
				};

				class LiteralExpressionBuilder
				{
				private:
					WorkflowLiteralExpression* node;
				public:
					LiteralExpressionBuilder(WorkflowLiteralExpression* _node) : node(_node) {}
					LiteralExpressionBuilder& value(WorkflowLiteralValue value);
				};

				class MapTypeBuilder
				{
				private:
					WorkflowMapType* node;
				public:
					MapTypeBuilder(WorkflowMapType* _node) : node(_node) {}
					MapTypeBuilder& key(const vl::Ptr<WorkflowType>& value);
					MapTypeBuilder& value(const vl::Ptr<WorkflowType>& value);
					MapTypeBuilder& writability(WorkflowMapWritability value);
				};

				class MemberExpressionBuilder
				{
				private:
					WorkflowMemberExpression* node;
				public:
					MemberExpressionBuilder(WorkflowMemberExpression* _node) : node(_node) {}
					MemberExpressionBuilder& name(const vl::WString& value);
					MemberExpressionBuilder& parent(const vl::Ptr<WorkflowExpression>& value);
				};

				class MixinCastExpressionBuilder
				{
				private:
					WorkflowMixinCastExpression* node;
				public:
					MixinCastExpressionBuilder(WorkflowMixinCastExpression* _node) : node(_node) {}
					MixinCastExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					MixinCastExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class ModuleBuilder
				{
				private:
					WorkflowModule* node;
				public:
					ModuleBuilder(WorkflowModule* _node) : node(_node) {}
					ModuleBuilder& declarations(const vl::Ptr<WorkflowDeclaration>& value);
					ModuleBuilder& moduleType(WorkflowModuleType value);
					ModuleBuilder& name(const vl::WString& value);
					ModuleBuilder& paths(const vl::Ptr<WorkflowModuleUsingPath>& value);
				};

				class ModuleUsingItemBuilder
				{
				private:
					WorkflowModuleUsingItem* node;
				public:
					ModuleUsingItemBuilder(WorkflowModuleUsingItem* _node) : node(_node) {}
					ModuleUsingItemBuilder& fragments(const vl::Ptr<WorkflowModuleUsingFragment>& value);
				};

				class ModuleUsingNameFragmentBuilder
				{
				private:
					WorkflowModuleUsingNameFragment* node;
				public:
					ModuleUsingNameFragmentBuilder(WorkflowModuleUsingNameFragment* _node) : node(_node) {}
					ModuleUsingNameFragmentBuilder& name(const vl::WString& value);
				};

				class ModuleUsingPathBuilder
				{
				private:
					WorkflowModuleUsingPath* node;
				public:
					ModuleUsingPathBuilder(WorkflowModuleUsingPath* _node) : node(_node) {}
					ModuleUsingPathBuilder& items(const vl::Ptr<WorkflowModuleUsingItem>& value);
				};

				class NamespaceDeclarationBuilder
				{
				private:
					WorkflowNamespaceDeclaration* node;
				public:
					NamespaceDeclarationBuilder(WorkflowNamespaceDeclaration* _node) : node(_node) {}
					NamespaceDeclarationBuilder& declarations(const vl::Ptr<WorkflowDeclaration>& value);
				};

				class NewClassExpressionBuilder
				{
				private:
					WorkflowNewClassExpression* node;
				public:
					NewClassExpressionBuilder(WorkflowNewClassExpression* _node) : node(_node) {}
					NewClassExpressionBuilder& arguments(const vl::Ptr<WorkflowExpression>& value);
					NewClassExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class NewCoroutineExpressionBuilder
				{
				private:
					WorkflowNewCoroutineExpression* node;
				public:
					NewCoroutineExpressionBuilder(WorkflowNewCoroutineExpression* _node) : node(_node) {}
					NewCoroutineExpressionBuilder& name(const vl::WString& value);
					NewCoroutineExpressionBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class NewInterfaceExpressionBuilder
				{
				private:
					WorkflowNewInterfaceExpression* node;
				public:
					NewInterfaceExpressionBuilder(WorkflowNewInterfaceExpression* _node) : node(_node) {}
					NewInterfaceExpressionBuilder& declarations(const vl::Ptr<WorkflowDeclaration>& value);
					NewInterfaceExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class NullableTypeBuilder
				{
				private:
					WorkflowNullableType* node;
				public:
					NullableTypeBuilder(WorkflowNullableType* _node) : node(_node) {}
					NullableTypeBuilder& element(const vl::Ptr<WorkflowType>& value);
				};

				class ObservableListTypeBuilder
				{
				private:
					WorkflowObservableListType* node;
				public:
					ObservableListTypeBuilder(WorkflowObservableListType* _node) : node(_node) {}
					ObservableListTypeBuilder& element(const vl::Ptr<WorkflowType>& value);
				};

				class ObserveExpressionBuilder
				{
				private:
					WorkflowObserveExpression* node;
				public:
					ObserveExpressionBuilder(WorkflowObserveExpression* _node) : node(_node) {}
					ObserveExpressionBuilder& events(const vl::Ptr<WorkflowExpression>& value);
					ObserveExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					ObserveExpressionBuilder& name(const vl::WString& value);
					ObserveExpressionBuilder& observeType(WorkflowObserveType value);
					ObserveExpressionBuilder& parent(const vl::Ptr<WorkflowExpression>& value);
				};

				class OrderedLambdaExpressionBuilder
				{
				private:
					WorkflowOrderedLambdaExpression* node;
				public:
					OrderedLambdaExpressionBuilder(WorkflowOrderedLambdaExpression* _node) : node(_node) {}
					OrderedLambdaExpressionBuilder& body(const vl::Ptr<WorkflowExpression>& value);
				};

				class OrderedNameExpressionBuilder
				{
				private:
					WorkflowOrderedNameExpression* node;
				public:
					OrderedNameExpressionBuilder(WorkflowOrderedNameExpression* _node) : node(_node) {}
					OrderedNameExpressionBuilder& name(const vl::WString& value);
				};

				class PredefinedTypeBuilder
				{
				private:
					WorkflowPredefinedType* node;
				public:
					PredefinedTypeBuilder(WorkflowPredefinedType* _node) : node(_node) {}
					PredefinedTypeBuilder& name(WorkflowPredefinedTypeName value);
				};

				class PropertyDeclarationBuilder
				{
				private:
					WorkflowPropertyDeclaration* node;
				public:
					PropertyDeclarationBuilder(WorkflowPropertyDeclaration* _node) : node(_node) {}
					PropertyDeclarationBuilder& getter(const vl::WString& value);
					PropertyDeclarationBuilder& setter(const vl::WString& value);
					PropertyDeclarationBuilder& type(const vl::Ptr<WorkflowType>& value);
					PropertyDeclarationBuilder& valueChangedEvent(const vl::WString& value);
				};

				class RaiseExceptionStatementBuilder
				{
				private:
					WorkflowRaiseExceptionStatement* node;
				public:
					RaiseExceptionStatementBuilder(WorkflowRaiseExceptionStatement* _node) : node(_node) {}
					RaiseExceptionStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class RangeExpressionBuilder
				{
				private:
					WorkflowRangeExpression* node;
				public:
					RangeExpressionBuilder(WorkflowRangeExpression* _node) : node(_node) {}
					RangeExpressionBuilder& begin(const vl::Ptr<WorkflowExpression>& value);
					RangeExpressionBuilder& beginBoundary(WorkflowRangeBoundary value);
					RangeExpressionBuilder& end(const vl::Ptr<WorkflowExpression>& value);
					RangeExpressionBuilder& endBoundary(WorkflowRangeBoundary value);
				};

				class RawPointerTypeBuilder
				{
				private:
					WorkflowRawPointerType* node;
				public:
					RawPointerTypeBuilder(WorkflowRawPointerType* _node) : node(_node) {}
					RawPointerTypeBuilder& element(const vl::Ptr<WorkflowType>& value);
				};

				class ReferenceExpressionBuilder
				{
				private:
					WorkflowReferenceExpression* node;
				public:
					ReferenceExpressionBuilder(WorkflowReferenceExpression* _node) : node(_node) {}
					ReferenceExpressionBuilder& name(const vl::WString& value);
				};

				class ReferenceTypeBuilder
				{
				private:
					WorkflowReferenceType* node;
				public:
					ReferenceTypeBuilder(WorkflowReferenceType* _node) : node(_node) {}
					ReferenceTypeBuilder& name(const vl::WString& value);
				};

				class ReturnStatementBuilder
				{
				private:
					WorkflowReturnStatement* node;
				public:
					ReturnStatementBuilder(WorkflowReturnStatement* _node) : node(_node) {}
					ReturnStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class SetTestingExpressionBuilder
				{
				private:
					WorkflowSetTestingExpression* node;
				public:
					SetTestingExpressionBuilder(WorkflowSetTestingExpression* _node) : node(_node) {}
					SetTestingExpressionBuilder& collection(const vl::Ptr<WorkflowExpression>& value);
					SetTestingExpressionBuilder& element(const vl::Ptr<WorkflowExpression>& value);
					SetTestingExpressionBuilder& test(WorkflowSetTesting value);
				};

				class SharedPointerTypeBuilder
				{
				private:
					WorkflowSharedPointerType* node;
				public:
					SharedPointerTypeBuilder(WorkflowSharedPointerType* _node) : node(_node) {}
					SharedPointerTypeBuilder& element(const vl::Ptr<WorkflowType>& value);
				};

				class StateDeclarationBuilder
				{
				private:
					WorkflowStateDeclaration* node;
				public:
					StateDeclarationBuilder(WorkflowStateDeclaration* _node) : node(_node) {}
					StateDeclarationBuilder& arguments(const vl::Ptr<WorkflowFunctionArgument>& value);
					StateDeclarationBuilder& name(const vl::WString& value);
					StateDeclarationBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class StateInputBuilder
				{
				private:
					WorkflowStateInput* node;
				public:
					StateInputBuilder(WorkflowStateInput* _node) : node(_node) {}
					StateInputBuilder& arguments(const vl::Ptr<WorkflowFunctionArgument>& value);
					StateInputBuilder& name(const vl::WString& value);
				};

				class StateInvokeStatementBuilder
				{
				private:
					WorkflowStateInvokeStatement* node;
				public:
					StateInvokeStatementBuilder(WorkflowStateInvokeStatement* _node) : node(_node) {}
					StateInvokeStatementBuilder& arguments(const vl::Ptr<WorkflowExpression>& value);
					StateInvokeStatementBuilder& name(const vl::WString& value);
					StateInvokeStatementBuilder& type(WorkflowStateInvokeType value);
				};

				class StateMachineDeclarationBuilder
				{
				private:
					WorkflowStateMachineDeclaration* node;
				public:
					StateMachineDeclarationBuilder(WorkflowStateMachineDeclaration* _node) : node(_node) {}
					StateMachineDeclarationBuilder& inputs(const vl::Ptr<WorkflowStateInput>& value);
					StateMachineDeclarationBuilder& states(const vl::Ptr<WorkflowStateDeclaration>& value);
				};

				class StateSwitchArgumentBuilder
				{
				private:
					WorkflowStateSwitchArgument* node;
				public:
					StateSwitchArgumentBuilder(WorkflowStateSwitchArgument* _node) : node(_node) {}
					StateSwitchArgumentBuilder& name(const vl::WString& value);
				};

				class StateSwitchCaseBuilder
				{
				private:
					WorkflowStateSwitchCase* node;
				public:
					StateSwitchCaseBuilder(WorkflowStateSwitchCase* _node) : node(_node) {}
					StateSwitchCaseBuilder& arguments(const vl::Ptr<WorkflowStateSwitchArgument>& value);
					StateSwitchCaseBuilder& name(const vl::WString& value);
					StateSwitchCaseBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class StateSwitchStatementBuilder
				{
				private:
					WorkflowStateSwitchStatement* node;
				public:
					StateSwitchStatementBuilder(WorkflowStateSwitchStatement* _node) : node(_node) {}
					StateSwitchStatementBuilder& caseBranches(const vl::Ptr<WorkflowStateSwitchCase>& value);
					StateSwitchStatementBuilder& type(WorkflowStateSwitchType value);
				};

				class StringExpressionBuilder
				{
				private:
					WorkflowStringExpression* node;
				public:
					StringExpressionBuilder(WorkflowStringExpression* _node) : node(_node) {}
					StringExpressionBuilder& value(const vl::WString& value);
				};

				class StructDeclarationBuilder
				{
				private:
					WorkflowStructDeclaration* node;
				public:
					StructDeclarationBuilder(WorkflowStructDeclaration* _node) : node(_node) {}
					StructDeclarationBuilder& members(const vl::Ptr<WorkflowStructMember>& value);
				};

				class StructMemberBuilder
				{
				private:
					WorkflowStructMember* node;
				public:
					StructMemberBuilder(WorkflowStructMember* _node) : node(_node) {}
					StructMemberBuilder& attributes(const vl::Ptr<WorkflowAttribute>& value);
					StructMemberBuilder& name(const vl::WString& value);
					StructMemberBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class SwitchCaseBuilder
				{
				private:
					WorkflowSwitchCase* node;
				public:
					SwitchCaseBuilder(WorkflowSwitchCase* _node) : node(_node) {}
					SwitchCaseBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					SwitchCaseBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				class SwitchStatementBuilder
				{
				private:
					WorkflowSwitchStatement* node;
				public:
					SwitchStatementBuilder(WorkflowSwitchStatement* _node) : node(_node) {}
					SwitchStatementBuilder& caseBranches(const vl::Ptr<WorkflowSwitchCase>& value);
					SwitchStatementBuilder& defaultBranch(const vl::Ptr<WorkflowStatement>& value);
					SwitchStatementBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class TopQualifiedExpressionBuilder
				{
				private:
					WorkflowTopQualifiedExpression* node;
				public:
					TopQualifiedExpressionBuilder(WorkflowTopQualifiedExpression* _node) : node(_node) {}
					TopQualifiedExpressionBuilder& name(const vl::WString& value);
				};

				class TopQualifiedTypeBuilder
				{
				private:
					WorkflowTopQualifiedType* node;
				public:
					TopQualifiedTypeBuilder(WorkflowTopQualifiedType* _node) : node(_node) {}
					TopQualifiedTypeBuilder& name(const vl::WString& value);
				};

				class TryStatementBuilder
				{
				private:
					WorkflowTryStatement* node;
				public:
					TryStatementBuilder(WorkflowTryStatement* _node) : node(_node) {}
					TryStatementBuilder& catchStatement(const vl::Ptr<WorkflowStatement>& value);
					TryStatementBuilder& finallyStatement(const vl::Ptr<WorkflowStatement>& value);
					TryStatementBuilder& name(const vl::WString& value);
					TryStatementBuilder& protectedStatement(const vl::Ptr<WorkflowStatement>& value);
				};

				class TypeCastingExpressionBuilder
				{
				private:
					WorkflowTypeCastingExpression* node;
				public:
					TypeCastingExpressionBuilder(WorkflowTypeCastingExpression* _node) : node(_node) {}
					TypeCastingExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					TypeCastingExpressionBuilder& strategy(WorkflowTypeCastingStrategy value);
					TypeCastingExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class TypeOfExpressionExpressionBuilder
				{
				private:
					WorkflowTypeOfExpressionExpression* node;
				public:
					TypeOfExpressionExpressionBuilder(WorkflowTypeOfExpressionExpression* _node) : node(_node) {}
					TypeOfExpressionExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
				};

				class TypeOfTypeExpressionBuilder
				{
				private:
					WorkflowTypeOfTypeExpression* node;
				public:
					TypeOfTypeExpressionBuilder(WorkflowTypeOfTypeExpression* _node) : node(_node) {}
					TypeOfTypeExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class TypeTestingExpressionBuilder
				{
				private:
					WorkflowTypeTestingExpression* node;
				public:
					TypeTestingExpressionBuilder(WorkflowTypeTestingExpression* _node) : node(_node) {}
					TypeTestingExpressionBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					TypeTestingExpressionBuilder& test(WorkflowTypeTesting value);
					TypeTestingExpressionBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class UnaryExpressionBuilder
				{
				private:
					WorkflowUnaryExpression* node;
				public:
					UnaryExpressionBuilder(WorkflowUnaryExpression* _node) : node(_node) {}
					UnaryExpressionBuilder& op(WorkflowUnaryOperator value);
					UnaryExpressionBuilder& operand(const vl::Ptr<WorkflowExpression>& value);
				};

				class VariableDeclarationBuilder
				{
				private:
					WorkflowVariableDeclaration* node;
				public:
					VariableDeclarationBuilder(WorkflowVariableDeclaration* _node) : node(_node) {}
					VariableDeclarationBuilder& expression(const vl::Ptr<WorkflowExpression>& value);
					VariableDeclarationBuilder& type(const vl::Ptr<WorkflowType>& value);
				};

				class VariableStatementBuilder
				{
				private:
					WorkflowVariableStatement* node;
				public:
					VariableStatementBuilder(WorkflowVariableStatement* _node) : node(_node) {}
					VariableStatementBuilder& variable(const vl::Ptr<WorkflowVariableDeclaration>& value);
				};

				class VirtualCfeDeclarationBuilder
				{
				private:
					WorkflowVirtualCfeDeclaration* node;
				public:
					VirtualCfeDeclarationBuilder(WorkflowVirtualCfeDeclaration* _node) : node(_node) {}
					VirtualCfeDeclarationBuilder& expandedDeclarations(const vl::Ptr<WorkflowDeclaration>& value);
				};

				class VirtualCfeExpressionBuilder
				{
				private:
					WorkflowVirtualCfeExpression* node;
				public:
					VirtualCfeExpressionBuilder(WorkflowVirtualCfeExpression* _node) : node(_node) {}
					VirtualCfeExpressionBuilder& expandedExpression(const vl::Ptr<WorkflowExpression>& value);
				};

				class VirtualCseDeclarationBuilder
				{
				private:
					WorkflowVirtualCseDeclaration* node;
				public:
					VirtualCseDeclarationBuilder(WorkflowVirtualCseDeclaration* _node) : node(_node) {}
					VirtualCseDeclarationBuilder& expandedDeclarations(const vl::Ptr<WorkflowDeclaration>& value);
				};

				class VirtualCseExpressionBuilder
				{
				private:
					WorkflowVirtualCseExpression* node;
				public:
					VirtualCseExpressionBuilder(WorkflowVirtualCseExpression* _node) : node(_node) {}
					VirtualCseExpressionBuilder& expandedExpression(const vl::Ptr<WorkflowExpression>& value);
				};

				class VirtualCseStatementBuilder
				{
				private:
					WorkflowVirtualCseStatement* node;
				public:
					VirtualCseStatementBuilder(WorkflowVirtualCseStatement* _node) : node(_node) {}
					VirtualCseStatementBuilder& expandedStatement(const vl::Ptr<WorkflowStatement>& value);
				};

				class WhileStatementBuilder
				{
				private:
					WorkflowWhileStatement* node;
				public:
					WhileStatementBuilder(WorkflowWhileStatement* _node) : node(_node) {}
					WhileStatementBuilder& condition(const vl::Ptr<WorkflowExpression>& value);
					WhileStatementBuilder& statement(const vl::Ptr<WorkflowStatement>& value);
				};

				using MakeAttachEventExpression = vl::glr::ParsingAstBuilder<WorkflowAttachEventExpression, AttachEventExpressionBuilder>;
				using MakeAttribute = vl::glr::ParsingAstBuilder<WorkflowAttribute, AttributeBuilder>;
				using MakeAutoPropertyDeclaration = vl::glr::ParsingAstBuilder<WorkflowAutoPropertyDeclaration, AutoPropertyDeclarationBuilder, VirtualCfeDeclarationBuilder, DeclarationBuilder>;
				using MakeBaseConstructorCall = vl::glr::ParsingAstBuilder<WorkflowBaseConstructorCall, BaseConstructorCallBuilder>;
				using MakeBinaryExpression = vl::glr::ParsingAstBuilder<WorkflowBinaryExpression, BinaryExpressionBuilder>;
				using MakeBindExpression = vl::glr::ParsingAstBuilder<WorkflowBindExpression, BindExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeBlockStatement = vl::glr::ParsingAstBuilder<WorkflowBlockStatement, BlockStatementBuilder>;
				using MakeBreakStatement = vl::glr::ParsingAstBuilder<WorkflowBreakStatement>;
				using MakeCallExpression = vl::glr::ParsingAstBuilder<WorkflowCallExpression, CallExpressionBuilder>;
				using MakeCastResultInterfaceDeclaration = vl::glr::ParsingAstBuilder<WorkflowCastResultInterfaceDeclaration, CastResultInterfaceDeclarationBuilder, VirtualCfeDeclarationBuilder, DeclarationBuilder>;
				using MakeChildExpression = vl::glr::ParsingAstBuilder<WorkflowChildExpression, ChildExpressionBuilder>;
				using MakeChildType = vl::glr::ParsingAstBuilder<WorkflowChildType, ChildTypeBuilder>;
				using MakeClassDeclaration = vl::glr::ParsingAstBuilder<WorkflowClassDeclaration, ClassDeclarationBuilder, DeclarationBuilder>;
				using MakeClassMember = vl::glr::ParsingAstBuilder<WorkflowClassMember, ClassMemberBuilder>;
				using MakeCoOperatorExpression = vl::glr::ParsingAstBuilder<WorkflowCoOperatorExpression, CoOperatorExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeCoOperatorStatement = vl::glr::ParsingAstBuilder<WorkflowCoOperatorStatement, CoOperatorStatementBuilder>;
				using MakeCoPauseStatement = vl::glr::ParsingAstBuilder<WorkflowCoPauseStatement, CoPauseStatementBuilder>;
				using MakeCoProviderStatement = vl::glr::ParsingAstBuilder<WorkflowCoProviderStatement, CoProviderStatementBuilder, VirtualCseStatementBuilder>;
				using MakeConstructorArgument = vl::glr::ParsingAstBuilder<WorkflowConstructorArgument, ConstructorArgumentBuilder>;
				using MakeConstructorDeclaration = vl::glr::ParsingAstBuilder<WorkflowConstructorDeclaration, ConstructorDeclarationBuilder, DeclarationBuilder>;
				using MakeConstructorExpression = vl::glr::ParsingAstBuilder<WorkflowConstructorExpression, ConstructorExpressionBuilder>;
				using MakeContinueStatement = vl::glr::ParsingAstBuilder<WorkflowContinueStatement>;
				using MakeDeleteStatement = vl::glr::ParsingAstBuilder<WorkflowDeleteStatement, DeleteStatementBuilder>;
				using MakeDestructorDeclaration = vl::glr::ParsingAstBuilder<WorkflowDestructorDeclaration, DestructorDeclarationBuilder, DeclarationBuilder>;
				using MakeDetachEventExpression = vl::glr::ParsingAstBuilder<WorkflowDetachEventExpression, DetachEventExpressionBuilder>;
				using MakeEnumDeclaration = vl::glr::ParsingAstBuilder<WorkflowEnumDeclaration, EnumDeclarationBuilder, DeclarationBuilder>;
				using MakeEnumItem = vl::glr::ParsingAstBuilder<WorkflowEnumItem, EnumItemBuilder>;
				using MakeEnumItemIntersection = vl::glr::ParsingAstBuilder<WorkflowEnumItemIntersection, EnumItemIntersectionBuilder>;
				using MakeEnumerableType = vl::glr::ParsingAstBuilder<WorkflowEnumerableType, EnumerableTypeBuilder>;
				using MakeEventDeclaration = vl::glr::ParsingAstBuilder<WorkflowEventDeclaration, EventDeclarationBuilder, DeclarationBuilder>;
				using MakeExpectedTypeCastExpression = vl::glr::ParsingAstBuilder<WorkflowExpectedTypeCastExpression, ExpectedTypeCastExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeExpressionStatement = vl::glr::ParsingAstBuilder<WorkflowExpressionStatement, ExpressionStatementBuilder>;
				using MakeFloatingExpression = vl::glr::ParsingAstBuilder<WorkflowFloatingExpression, FloatingExpressionBuilder>;
				using MakeForEachStatement = vl::glr::ParsingAstBuilder<WorkflowForEachStatement, ForEachStatementBuilder, VirtualCseStatementBuilder>;
				using MakeFormatExpression = vl::glr::ParsingAstBuilder<WorkflowFormatExpression, FormatExpressionBuilder, VirtualCfeExpressionBuilder>;
				using MakeFunctionArgument = vl::glr::ParsingAstBuilder<WorkflowFunctionArgument, FunctionArgumentBuilder>;
				using MakeFunctionDeclaration = vl::glr::ParsingAstBuilder<WorkflowFunctionDeclaration, FunctionDeclarationBuilder, DeclarationBuilder>;
				using MakeFunctionExpression = vl::glr::ParsingAstBuilder<WorkflowFunctionExpression, FunctionExpressionBuilder>;
				using MakeFunctionType = vl::glr::ParsingAstBuilder<WorkflowFunctionType, FunctionTypeBuilder>;
				using MakeGotoStatement = vl::glr::ParsingAstBuilder<WorkflowGotoStatement, GotoStatementBuilder>;
				using MakeIfExpression = vl::glr::ParsingAstBuilder<WorkflowIfExpression, IfExpressionBuilder>;
				using MakeIfStatement = vl::glr::ParsingAstBuilder<WorkflowIfStatement, IfStatementBuilder>;
				using MakeInferExpression = vl::glr::ParsingAstBuilder<WorkflowInferExpression, InferExpressionBuilder>;
				using MakeIntegerExpression = vl::glr::ParsingAstBuilder<WorkflowIntegerExpression, IntegerExpressionBuilder>;
				using MakeLetExpression = vl::glr::ParsingAstBuilder<WorkflowLetExpression, LetExpressionBuilder>;
				using MakeLetVariable = vl::glr::ParsingAstBuilder<WorkflowLetVariable, LetVariableBuilder>;
				using MakeLiteralExpression = vl::glr::ParsingAstBuilder<WorkflowLiteralExpression, LiteralExpressionBuilder>;
				using MakeMapType = vl::glr::ParsingAstBuilder<WorkflowMapType, MapTypeBuilder>;
				using MakeMemberExpression = vl::glr::ParsingAstBuilder<WorkflowMemberExpression, MemberExpressionBuilder>;
				using MakeMixinCastExpression = vl::glr::ParsingAstBuilder<WorkflowMixinCastExpression, MixinCastExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeModule = vl::glr::ParsingAstBuilder<WorkflowModule, ModuleBuilder>;
				using MakeModuleUsingItem = vl::glr::ParsingAstBuilder<WorkflowModuleUsingItem, ModuleUsingItemBuilder>;
				using MakeModuleUsingNameFragment = vl::glr::ParsingAstBuilder<WorkflowModuleUsingNameFragment, ModuleUsingNameFragmentBuilder>;
				using MakeModuleUsingPath = vl::glr::ParsingAstBuilder<WorkflowModuleUsingPath, ModuleUsingPathBuilder>;
				using MakeModuleUsingWildCardFragment = vl::glr::ParsingAstBuilder<WorkflowModuleUsingWildCardFragment>;
				using MakeNamespaceDeclaration = vl::glr::ParsingAstBuilder<WorkflowNamespaceDeclaration, NamespaceDeclarationBuilder, DeclarationBuilder>;
				using MakeNewClassExpression = vl::glr::ParsingAstBuilder<WorkflowNewClassExpression, NewClassExpressionBuilder>;
				using MakeNewCoroutineExpression = vl::glr::ParsingAstBuilder<WorkflowNewCoroutineExpression, NewCoroutineExpressionBuilder, VirtualCseExpressionBuilder>;
				using MakeNewInterfaceExpression = vl::glr::ParsingAstBuilder<WorkflowNewInterfaceExpression, NewInterfaceExpressionBuilder>;
				using MakeNullableType = vl::glr::ParsingAstBuilder<WorkflowNullableType, NullableTypeBuilder>;
				using MakeObservableListType = vl::glr::ParsingAstBuilder<WorkflowObservableListType, ObservableListTypeBuilder>;
				using MakeObserveExpression = vl::glr::ParsingAstBuilder<WorkflowObserveExpression, ObserveExpressionBuilder>;
				using MakeOrderedLambdaExpression = vl::glr::ParsingAstBuilder<WorkflowOrderedLambdaExpression, OrderedLambdaExpressionBuilder>;
				using MakeOrderedNameExpression = vl::glr::ParsingAstBuilder<WorkflowOrderedNameExpression, OrderedNameExpressionBuilder>;
				using MakePredefinedType = vl::glr::ParsingAstBuilder<WorkflowPredefinedType, PredefinedTypeBuilder>;
				using MakePropertyDeclaration = vl::glr::ParsingAstBuilder<WorkflowPropertyDeclaration, PropertyDeclarationBuilder, DeclarationBuilder>;
				using MakeRaiseExceptionStatement = vl::glr::ParsingAstBuilder<WorkflowRaiseExceptionStatement, RaiseExceptionStatementBuilder>;
				using MakeRangeExpression = vl::glr::ParsingAstBuilder<WorkflowRangeExpression, RangeExpressionBuilder>;
				using MakeRawPointerType = vl::glr::ParsingAstBuilder<WorkflowRawPointerType, RawPointerTypeBuilder>;
				using MakeReferenceExpression = vl::glr::ParsingAstBuilder<WorkflowReferenceExpression, ReferenceExpressionBuilder>;
				using MakeReferenceType = vl::glr::ParsingAstBuilder<WorkflowReferenceType, ReferenceTypeBuilder>;
				using MakeReturnStatement = vl::glr::ParsingAstBuilder<WorkflowReturnStatement, ReturnStatementBuilder>;
				using MakeSetTestingExpression = vl::glr::ParsingAstBuilder<WorkflowSetTestingExpression, SetTestingExpressionBuilder>;
				using MakeSharedPointerType = vl::glr::ParsingAstBuilder<WorkflowSharedPointerType, SharedPointerTypeBuilder>;
				using MakeStateDeclaration = vl::glr::ParsingAstBuilder<WorkflowStateDeclaration, StateDeclarationBuilder>;
				using MakeStateInput = vl::glr::ParsingAstBuilder<WorkflowStateInput, StateInputBuilder>;
				using MakeStateInvokeStatement = vl::glr::ParsingAstBuilder<WorkflowStateInvokeStatement, StateInvokeStatementBuilder>;
				using MakeStateMachineDeclaration = vl::glr::ParsingAstBuilder<WorkflowStateMachineDeclaration, StateMachineDeclarationBuilder, VirtualCseDeclarationBuilder, DeclarationBuilder>;
				using MakeStateSwitchArgument = vl::glr::ParsingAstBuilder<WorkflowStateSwitchArgument, StateSwitchArgumentBuilder>;
				using MakeStateSwitchCase = vl::glr::ParsingAstBuilder<WorkflowStateSwitchCase, StateSwitchCaseBuilder>;
				using MakeStateSwitchStatement = vl::glr::ParsingAstBuilder<WorkflowStateSwitchStatement, StateSwitchStatementBuilder>;
				using MakeStringExpression = vl::glr::ParsingAstBuilder<WorkflowStringExpression, StringExpressionBuilder>;
				using MakeStructDeclaration = vl::glr::ParsingAstBuilder<WorkflowStructDeclaration, StructDeclarationBuilder, DeclarationBuilder>;
				using MakeStructMember = vl::glr::ParsingAstBuilder<WorkflowStructMember, StructMemberBuilder>;
				using MakeSwitchCase = vl::glr::ParsingAstBuilder<WorkflowSwitchCase, SwitchCaseBuilder>;
				using MakeSwitchStatement = vl::glr::ParsingAstBuilder<WorkflowSwitchStatement, SwitchStatementBuilder, VirtualCseStatementBuilder>;
				using MakeThisExpression = vl::glr::ParsingAstBuilder<WorkflowThisExpression>;
				using MakeTopQualifiedExpression = vl::glr::ParsingAstBuilder<WorkflowTopQualifiedExpression, TopQualifiedExpressionBuilder>;
				using MakeTopQualifiedType = vl::glr::ParsingAstBuilder<WorkflowTopQualifiedType, TopQualifiedTypeBuilder>;
				using MakeTryStatement = vl::glr::ParsingAstBuilder<WorkflowTryStatement, TryStatementBuilder>;
				using MakeTypeCastingExpression = vl::glr::ParsingAstBuilder<WorkflowTypeCastingExpression, TypeCastingExpressionBuilder>;
				using MakeTypeOfExpressionExpression = vl::glr::ParsingAstBuilder<WorkflowTypeOfExpressionExpression, TypeOfExpressionExpressionBuilder>;
				using MakeTypeOfTypeExpression = vl::glr::ParsingAstBuilder<WorkflowTypeOfTypeExpression, TypeOfTypeExpressionBuilder>;
				using MakeTypeTestingExpression = vl::glr::ParsingAstBuilder<WorkflowTypeTestingExpression, TypeTestingExpressionBuilder>;
				using MakeUnaryExpression = vl::glr::ParsingAstBuilder<WorkflowUnaryExpression, UnaryExpressionBuilder>;
				using MakeVariableDeclaration = vl::glr::ParsingAstBuilder<WorkflowVariableDeclaration, VariableDeclarationBuilder, DeclarationBuilder>;
				using MakeVariableStatement = vl::glr::ParsingAstBuilder<WorkflowVariableStatement, VariableStatementBuilder>;
				using MakeWhileStatement = vl::glr::ParsingAstBuilder<WorkflowWhileStatement, WhileStatementBuilder>;
			}
		}
	}
}
#endif