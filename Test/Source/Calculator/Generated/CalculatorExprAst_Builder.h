/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ExprAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_UNITTEST_CALCULATOR_EXPRAST_AST_BUILDER
#define VCZH_PARSER2_UNITTEST_CALCULATOR_EXPRAST_AST_BUILDER

#include "CalculatorExprAst.h"

namespace calculator
{
	namespace builder
	{
		class ArgBuilder
		{
		private:
			Arg* node;
		public:
			ArgBuilder(Arg* _node) : node(_node) {}
			ArgBuilder& name(const vl::WString& value);
		};

		class BinaryBuilder
		{
		private:
			Binary* node;
		public:
			BinaryBuilder(Binary* _node) : node(_node) {}
			BinaryBuilder& left(const vl::Ptr<Expr>& value);
			BinaryBuilder& op(BinaryOp value);
			BinaryBuilder& right(const vl::Ptr<Expr>& value);
		};

		class CallBuilder
		{
		private:
			Call* node;
		public:
			CallBuilder(Call* _node) : node(_node) {}
			CallBuilder& args(const vl::Ptr<Expr>& value);
			CallBuilder& func(const vl::Ptr<Expr>& value);
		};

		class ExpandableBuilder
		{
		private:
			Expandable* node;
		public:
			ExpandableBuilder(Expandable* _node) : node(_node) {}
			ExpandableBuilder& expanded(const vl::Ptr<Expr>& value);
		};

		class FuncBuilder
		{
		private:
			Func* node;
		public:
			FuncBuilder(Func* _node) : node(_node) {}
			FuncBuilder& args(const vl::Ptr<Arg>& value);
			FuncBuilder& value(const vl::Ptr<Expr>& value);
		};

		class ImportBuilder
		{
		private:
			Import* node;
		public:
			ImportBuilder(Import* _node) : node(_node) {}
			ImportBuilder& name(const vl::WString& value);
		};

		class LetExprBuilder
		{
		private:
			LetExpr* node;
		public:
			LetExprBuilder(LetExpr* _node) : node(_node) {}
			LetExprBuilder& name(const vl::WString& value);
			LetExprBuilder& result(const vl::Ptr<Expr>& value);
			LetExprBuilder& value(const vl::Ptr<Expr>& value);
		};

		class ModuleBuilder
		{
		private:
			Module* node;
		public:
			ModuleBuilder(Module* _node) : node(_node) {}
			ModuleBuilder& exported(const vl::Ptr<Expr>& value);
			ModuleBuilder& imports(const vl::Ptr<Import>& value);
		};

		class NumExprBuilder
		{
		private:
			NumExpr* node;
		public:
			NumExprBuilder(NumExpr* _node) : node(_node) {}
			NumExprBuilder& value(const vl::WString& value);
		};

		class RefBuilder
		{
		private:
			Ref* node;
		public:
			RefBuilder(Ref* _node) : node(_node) {}
			RefBuilder& name(const vl::WString& value);
		};

		class UnaryBuilder
		{
		private:
			Unary* node;
		public:
			UnaryBuilder(Unary* _node) : node(_node) {}
			UnaryBuilder& op(UnaryOp value);
			UnaryBuilder& operand(const vl::Ptr<Expr>& value);
		};

		using MakeArg = vl::glr::ParsingAstBuilder<Arg, ArgBuilder>;
		using MakeBinary = vl::glr::ParsingAstBuilder<Binary, BinaryBuilder, ExpandableBuilder>;
		using MakeCall = vl::glr::ParsingAstBuilder<Call, CallBuilder>;
		using MakeFalse = vl::glr::ParsingAstBuilder<False>;
		using MakeFunc = vl::glr::ParsingAstBuilder<Func, FuncBuilder>;
		using MakeImport = vl::glr::ParsingAstBuilder<Import, ImportBuilder>;
		using MakeLetExpr = vl::glr::ParsingAstBuilder<LetExpr, LetExprBuilder, ExpandableBuilder>;
		using MakeModule = vl::glr::ParsingAstBuilder<Module, ModuleBuilder>;
		using MakeNumExpr = vl::glr::ParsingAstBuilder<NumExpr, NumExprBuilder>;
		using MakeRef = vl::glr::ParsingAstBuilder<Ref, RefBuilder>;
		using MakeTrue = vl::glr::ParsingAstBuilder<True>;
		using MakeUnary = vl::glr::ParsingAstBuilder<Unary, UnaryBuilder, ExpandableBuilder>;
	}
}
#endif