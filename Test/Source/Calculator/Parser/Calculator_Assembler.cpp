/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Calculator
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Calculator_Assembler.h"

namespace calculator
{

/***********************************************************************
CalculatorAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		auto cppTypeName = CalculatorCppTypeName((CalculatorClasses)type);
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
			return new calculator::Arg();
		case CalculatorClasses::Binary:
			return new calculator::Binary();
		case CalculatorClasses::Call:
			return new calculator::Call();
		case CalculatorClasses::False:
			return new calculator::False();
		case CalculatorClasses::Func:
			return new calculator::Func();
		case CalculatorClasses::Import:
			return new calculator::Import();
		case CalculatorClasses::LetExpr:
			return new calculator::LetExpr();
		case CalculatorClasses::Module:
			return new calculator::Module();
		case CalculatorClasses::NumExpr:
			return new calculator::NumExpr();
		case CalculatorClasses::Ref:
			return new calculator::Ref();
		case CalculatorClasses::True:
			return new calculator::True();
		case CalculatorClasses::Unary:
			return new calculator::Unary();
		default:
			return vl::glr::AssemblyThrowCannotCreateAbstractType(type, cppTypeName);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_left:
			return vl::glr::AssemblerSetObjectField(&calculator::Binary::left, object, field, value, cppFieldName);
		case CalculatorFields::Binary_right:
			return vl::glr::AssemblerSetObjectField(&calculator::Binary::right, object, field, value, cppFieldName);
		case CalculatorFields::Call_args:
			return vl::glr::AssemblerSetObjectField(&calculator::Call::args, object, field, value, cppFieldName);
		case CalculatorFields::Call_func:
			return vl::glr::AssemblerSetObjectField(&calculator::Call::func, object, field, value, cppFieldName);
		case CalculatorFields::Expandable_expanded:
			return vl::glr::AssemblerSetObjectField(&calculator::Expandable::expanded, object, field, value, cppFieldName);
		case CalculatorFields::Func_args:
			return vl::glr::AssemblerSetObjectField(&calculator::Func::args, object, field, value, cppFieldName);
		case CalculatorFields::Func_value:
			return vl::glr::AssemblerSetObjectField(&calculator::Func::value, object, field, value, cppFieldName);
		case CalculatorFields::LetExpr_result:
			return vl::glr::AssemblerSetObjectField(&calculator::LetExpr::result, object, field, value, cppFieldName);
		case CalculatorFields::LetExpr_value:
			return vl::glr::AssemblerSetObjectField(&calculator::LetExpr::value, object, field, value, cppFieldName);
		case CalculatorFields::Module_exported:
			return vl::glr::AssemblerSetObjectField(&calculator::Module::exported, object, field, value, cppFieldName);
		case CalculatorFields::Module_imports:
			return vl::glr::AssemblerSetObjectField(&calculator::Module::imports, object, field, value, cppFieldName);
		case CalculatorFields::Unary_operand:
			return vl::glr::AssemblerSetObjectField(&calculator::Unary::operand, object, field, value, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotObject(field, cppFieldName);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Arg_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Arg::name, object, field, token, tokenIndex, cppFieldName);
		case CalculatorFields::Import_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Import::name, object, field, token, tokenIndex, cppFieldName);
		case CalculatorFields::LetExpr_name:
			return vl::glr::AssemblerSetTokenField(&calculator::LetExpr::name, object, field, token, tokenIndex, cppFieldName);
		case CalculatorFields::NumExpr_value:
			return vl::glr::AssemblerSetTokenField(&calculator::NumExpr::value, object, field, token, tokenIndex, cppFieldName);
		case CalculatorFields::Ref_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Ref::name, object, field, token, tokenIndex, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotToken(field, cppFieldName);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_op:
			return vl::glr::AssemblerSetEnumField(&calculator::Binary::op, object, field, enumItem, weakAssignment, cppFieldName);
		case CalculatorFields::Unary_op:
			return vl::glr::AssemblerSetEnumField(&calculator::Unary::op, object, field, enumItem, weakAssignment, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotEnum(field, cppFieldName);
		}
	}

	const wchar_t* CalculatorTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"Arg",
			L"Binary",
			L"Call",
			L"Expandable",
			L"Expr",
			L"False",
			L"Func",
			L"Import",
			L"LetExpr",
			L"Module",
			L"NumExpr",
			L"Ref",
			L"True",
			L"Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorCppTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"calculator::Arg",
			L"calculator::Binary",
			L"calculator::Call",
			L"calculator::Expandable",
			L"calculator::Expr",
			L"calculator::False",
			L"calculator::Func",
			L"calculator::Import",
			L"calculator::LetExpr",
			L"calculator::Module",
			L"calculator::NumExpr",
			L"calculator::Ref",
			L"calculator::True",
			L"calculator::Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorFieldName(CalculatorFields field)
	{
		const wchar_t* results[] = {
			L"Arg::name",
			L"Binary::left",
			L"Binary::op",
			L"Binary::right",
			L"Call::args",
			L"Call::func",
			L"Expandable::expanded",
			L"Func::args",
			L"Func::value",
			L"Import::name",
			L"LetExpr::name",
			L"LetExpr::result",
			L"LetExpr::value",
			L"Module::exported",
			L"Module::imports",
			L"NumExpr::value",
			L"Ref::name",
			L"Unary::op",
			L"Unary::operand",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 19 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorCppFieldName(CalculatorFields field)
	{
		const wchar_t* results[] = {
			L"calculator::Arg::name",
			L"calculator::Binary::left",
			L"calculator::Binary::op",
			L"calculator::Binary::right",
			L"calculator::Call::args",
			L"calculator::Call::func",
			L"calculator::Expandable::expanded",
			L"calculator::Func::args",
			L"calculator::Func::value",
			L"calculator::Import::name",
			L"calculator::LetExpr::name",
			L"calculator::LetExpr::result",
			L"calculator::LetExpr::value",
			L"calculator::Module::exported",
			L"calculator::Module::imports",
			L"calculator::NumExpr::value",
			L"calculator::Ref::name",
			L"calculator::Unary::op",
			L"calculator::Unary::operand",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 19 ? results[index] : nullptr;
	}

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = CalculatorCppTypeName((CalculatorClasses)type);
		return vl::glr::AssemblyThrowTypeNotAllowAmbiguity(type, cppTypeName);
	}
}
