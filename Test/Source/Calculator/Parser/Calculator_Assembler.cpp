/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Calculator
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Calculator_Assembler.h"

namespace calculator
{

/***********************************************************************
CalculatorAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
			return new calculator::Arg();
		case CalculatorClasses::Binary:
			return new calculator::Binary();
		case CalculatorClasses::Call:
			return new calculator::Call();
		case CalculatorClasses::Expandable:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expandable\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::Expr:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expr\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::False:
			return new calculator::False();
		case CalculatorClasses::Func:
			return new calculator::Func();
		case CalculatorClasses::Import:
			return new calculator::Import();
		case CalculatorClasses::LetExpr:
			return new calculator::LetExpr();
		case CalculatorClasses::Module:
			return new calculator::Module();
		case CalculatorClasses::NumExpr:
			return new calculator::NumExpr();
		case CalculatorClasses::Ref:
			return new calculator::Ref();
		case CalculatorClasses::True:
			return new calculator::True();
		case CalculatorClasses::Unary:
			return new calculator::Unary();
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_left:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->left) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->left = typedValue;
			}
			break;
		case CalculatorFields::Binary_right:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->right) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->right = typedValue;
			}
			break;
		case CalculatorFields::Call_args:
			{
				auto typedObject = dynamic_cast<calculator::Call*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Call::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Call::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->args.Add(typedValue);
			}
			break;
		case CalculatorFields::Call_func:
			{
				auto typedObject = dynamic_cast<calculator::Call*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->func) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->func = typedValue;
			}
			break;
		case CalculatorFields::Expandable_expanded:
			{
				auto typedObject = dynamic_cast<calculator::Expandable*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->expanded) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->expanded = typedValue;
			}
			break;
		case CalculatorFields::Func_args:
			{
				auto typedObject = dynamic_cast<calculator::Func*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<calculator::Arg>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->args.Add(typedValue);
			}
			break;
		case CalculatorFields::Func_value:
			{
				auto typedObject = dynamic_cast<calculator::Func*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->value = typedValue;
			}
			break;
		case CalculatorFields::LetExpr_result:
			{
				auto typedObject = dynamic_cast<calculator::LetExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::result\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->result) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::result\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::result\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->result = typedValue;
			}
			break;
		case CalculatorFields::LetExpr_value:
			{
				auto typedObject = dynamic_cast<calculator::LetExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->value = typedValue;
			}
			break;
		case CalculatorFields::Module_exported:
			{
				auto typedObject = dynamic_cast<calculator::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->exported) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->exported = typedValue;
			}
			break;
		case CalculatorFields::Module_imports:
			{
				auto typedObject = dynamic_cast<calculator::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<calculator::Import>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->imports.Add(typedValue);
			}
			break;
		case CalculatorFields::Unary_operand:
			{
				auto typedObject = dynamic_cast<calculator::Unary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->operand) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->operand = typedValue;
			}
			break;
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Arg_name:
			{
				auto typedObject = dynamic_cast<calculator::Arg*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::Import_name:
			{
				auto typedObject = dynamic_cast<calculator::Import*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::LetExpr_name:
			{
				auto typedObject = dynamic_cast<calculator::LetExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::NumExpr_value:
			{
				auto typedObject = dynamic_cast<calculator::NumExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->value, token);
			}
			break;
		case CalculatorFields::Ref_name:
			{
				auto typedObject = dynamic_cast<calculator::Ref*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::args\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_result:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::result\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_op:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == calculator::BinaryOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (calculator::BinaryOp)enumItem;
			}
			break;
		case CalculatorFields::Unary_op:
			{
				auto typedObject = dynamic_cast<calculator::Unary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == calculator::UnaryOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (calculator::UnaryOp)enumItem;
			}
			break;
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::args\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_result:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::result\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	const wchar_t* CalculatorTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"Arg",
			L"Binary",
			L"Call",
			L"Expandable",
			L"Expr",
			L"False",
			L"Func",
			L"Import",
			L"LetExpr",
			L"Module",
			L"NumExpr",
			L"Ref",
			L"True",
			L"Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorCppTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"calculator::Arg",
			L"calculator::Binary",
			L"calculator::Call",
			L"calculator::Expandable",
			L"calculator::Expr",
			L"calculator::False",
			L"calculator::Func",
			L"calculator::Import",
			L"calculator::LetExpr",
			L"calculator::Module",
			L"calculator::NumExpr",
			L"calculator::Ref",
			L"calculator::True",
			L"calculator::Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorFieldName(CalculatorFields field)
	{
		switch(field)
		{
		case CalculatorFields::Arg_name:
			return L"Arg::name";
		case CalculatorFields::Binary_left:
			return L"Binary::left";
		case CalculatorFields::Binary_op:
			return L"Binary::op";
		case CalculatorFields::Binary_right:
			return L"Binary::right";
		case CalculatorFields::Call_args:
			return L"Call::args";
		case CalculatorFields::Call_func:
			return L"Call::func";
		case CalculatorFields::Expandable_expanded:
			return L"Expandable::expanded";
		case CalculatorFields::Func_args:
			return L"Func::args";
		case CalculatorFields::Func_value:
			return L"Func::value";
		case CalculatorFields::Import_name:
			return L"Import::name";
		case CalculatorFields::LetExpr_name:
			return L"LetExpr::name";
		case CalculatorFields::LetExpr_result:
			return L"LetExpr::result";
		case CalculatorFields::LetExpr_value:
			return L"LetExpr::value";
		case CalculatorFields::Module_exported:
			return L"Module::exported";
		case CalculatorFields::Module_imports:
			return L"Module::imports";
		case CalculatorFields::NumExpr_value:
			return L"NumExpr::value";
		case CalculatorFields::Ref_name:
			return L"Ref::name";
		case CalculatorFields::Unary_op:
			return L"Unary::op";
		case CalculatorFields::Unary_operand:
			return L"Unary::operand";
		default:
			return nullptr;
		}
	}

	const wchar_t* CalculatorCppFieldName(CalculatorFields field)
	{
		switch(field)
		{
		case CalculatorFields::Arg_name:
			return L"calculator::Arg::name";
		case CalculatorFields::Binary_left:
			return L"calculator::Binary::left";
		case CalculatorFields::Binary_op:
			return L"calculator::Binary::op";
		case CalculatorFields::Binary_right:
			return L"calculator::Binary::right";
		case CalculatorFields::Call_args:
			return L"calculator::Call::args";
		case CalculatorFields::Call_func:
			return L"calculator::Call::func";
		case CalculatorFields::Expandable_expanded:
			return L"calculator::Expandable::expanded";
		case CalculatorFields::Func_args:
			return L"calculator::Func::args";
		case CalculatorFields::Func_value:
			return L"calculator::Func::value";
		case CalculatorFields::Import_name:
			return L"calculator::Import::name";
		case CalculatorFields::LetExpr_name:
			return L"calculator::LetExpr::name";
		case CalculatorFields::LetExpr_result:
			return L"calculator::LetExpr::result";
		case CalculatorFields::LetExpr_value:
			return L"calculator::LetExpr::value";
		case CalculatorFields::Module_exported:
			return L"calculator::Module::exported";
		case CalculatorFields::Module_imports:
			return L"calculator::Module::imports";
		case CalculatorFields::NumExpr_value:
			return L"calculator::NumExpr::value";
		case CalculatorFields::Ref_name:
			return L"calculator::Ref::name";
		case CalculatorFields::Unary_op:
			return L"calculator::Unary::op";
		case CalculatorFields::Unary_operand:
			return L"calculator::Unary::operand";
		default:
			return nullptr;
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
		case CalculatorClasses::Binary:
		case CalculatorClasses::Call:
		case CalculatorClasses::Expandable:
		case CalculatorClasses::Expr:
		case CalculatorClasses::False:
		case CalculatorClasses::Func:
		case CalculatorClasses::Import:
		case CalculatorClasses::LetExpr:
		case CalculatorClasses::Module:
		case CalculatorClasses::NumExpr:
		case CalculatorClasses::Ref:
		case CalculatorClasses::True:
		case CalculatorClasses::Unary:
			throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}
}
