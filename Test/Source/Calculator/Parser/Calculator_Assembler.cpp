/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Calculator
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Calculator_Assembler.h"

namespace calculator
{

/***********************************************************************
CalculatorAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
			return new calculator::Arg();
		case CalculatorClasses::Binary:
			return new calculator::Binary();
		case CalculatorClasses::Call:
			return new calculator::Call();
		case CalculatorClasses::Expandable:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expandable\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::Expr:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expr\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::False:
			return new calculator::False();
		case CalculatorClasses::Func:
			return new calculator::Func();
		case CalculatorClasses::Import:
			return new calculator::Import();
		case CalculatorClasses::LetExpr:
			return new calculator::LetExpr();
		case CalculatorClasses::Module:
			return new calculator::Module();
		case CalculatorClasses::NumExpr:
			return new calculator::NumExpr();
		case CalculatorClasses::Ref:
			return new calculator::Ref();
		case CalculatorClasses::True:
			return new calculator::True();
		case CalculatorClasses::Unary:
			return new calculator::Unary();
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_left:
			return vl::glr::AssemblerSetObjectField(&calculator::Binary::left, object, field, value, cppFieldName);
		case CalculatorFields::Binary_right:
			return vl::glr::AssemblerSetObjectField(&calculator::Binary::right, object, field, value, cppFieldName);
		case CalculatorFields::Call_args:
			return vl::glr::AssemblerSetObjectField(&calculator::Call::args, object, field, value, cppFieldName);
		case CalculatorFields::Call_func:
			return vl::glr::AssemblerSetObjectField(&calculator::Call::func, object, field, value, cppFieldName);
		case CalculatorFields::Expandable_expanded:
			return vl::glr::AssemblerSetObjectField(&calculator::Expandable::expanded, object, field, value, cppFieldName);
		case CalculatorFields::Func_args:
			return vl::glr::AssemblerSetObjectField(&calculator::Func::args, object, field, value, cppFieldName);
		case CalculatorFields::Func_value:
			return vl::glr::AssemblerSetObjectField(&calculator::Func::value, object, field, value, cppFieldName);
		case CalculatorFields::LetExpr_result:
			return vl::glr::AssemblerSetObjectField(&calculator::LetExpr::result, object, field, value, cppFieldName);
		case CalculatorFields::LetExpr_value:
			return vl::glr::AssemblerSetObjectField(&calculator::LetExpr::value, object, field, value, cppFieldName);
		case CalculatorFields::Module_exported:
			return vl::glr::AssemblerSetObjectField(&calculator::Module::exported, object, field, value, cppFieldName);
		case CalculatorFields::Module_imports:
			return vl::glr::AssemblerSetObjectField(&calculator::Module::imports, object, field, value, cppFieldName);
		case CalculatorFields::Unary_operand:
			return vl::glr::AssemblerSetObjectField(&calculator::Unary::operand, object, field, value, cppFieldName);
		default:
			if (cppFieldName)
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not an object."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Arg_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Arg::name, object, field, token,cppFieldName);
		case CalculatorFields::Import_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Import::name, object, field, token,cppFieldName);
		case CalculatorFields::LetExpr_name:
			return vl::glr::AssemblerSetTokenField(&calculator::LetExpr::name, object, field, token,cppFieldName);
		case CalculatorFields::NumExpr_value:
			return vl::glr::AssemblerSetTokenField(&calculator::NumExpr::value, object, field, token,cppFieldName);
		case CalculatorFields::Ref_name:
			return vl::glr::AssemblerSetTokenField(&calculator::Ref::name, object, field, token,cppFieldName);
		default:
			if (cppFieldName)
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not a token."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		auto cppFieldName = CalculatorCppFieldName((CalculatorFields)field);
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_op:
			return vl::glr::AssemblerSetEnumField(&calculator::Binary::op, object, field, enumItem, cppFieldName);
		case CalculatorFields::Unary_op:
			return vl::glr::AssemblerSetEnumField(&calculator::Unary::op, object, field, enumItem, cppFieldName);
		default:
			if (cppFieldName)
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not an enum item."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	const wchar_t* CalculatorTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"Arg",
			L"Binary",
			L"Call",
			L"Expandable",
			L"Expr",
			L"False",
			L"Func",
			L"Import",
			L"LetExpr",
			L"Module",
			L"NumExpr",
			L"Ref",
			L"True",
			L"Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorCppTypeName(CalculatorClasses type)
	{
		const wchar_t* results[] = {
			L"calculator::Arg",
			L"calculator::Binary",
			L"calculator::Call",
			L"calculator::Expandable",
			L"calculator::Expr",
			L"calculator::False",
			L"calculator::Func",
			L"calculator::Import",
			L"calculator::LetExpr",
			L"calculator::Module",
			L"calculator::NumExpr",
			L"calculator::Ref",
			L"calculator::True",
			L"calculator::Unary",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 14 ? results[index] : nullptr;
	}

	const wchar_t* CalculatorFieldName(CalculatorFields field)
	{
		switch(field)
		{
		case CalculatorFields::Arg_name:
			return L"Arg::name";
		case CalculatorFields::Binary_left:
			return L"Binary::left";
		case CalculatorFields::Binary_op:
			return L"Binary::op";
		case CalculatorFields::Binary_right:
			return L"Binary::right";
		case CalculatorFields::Call_args:
			return L"Call::args";
		case CalculatorFields::Call_func:
			return L"Call::func";
		case CalculatorFields::Expandable_expanded:
			return L"Expandable::expanded";
		case CalculatorFields::Func_args:
			return L"Func::args";
		case CalculatorFields::Func_value:
			return L"Func::value";
		case CalculatorFields::Import_name:
			return L"Import::name";
		case CalculatorFields::LetExpr_name:
			return L"LetExpr::name";
		case CalculatorFields::LetExpr_result:
			return L"LetExpr::result";
		case CalculatorFields::LetExpr_value:
			return L"LetExpr::value";
		case CalculatorFields::Module_exported:
			return L"Module::exported";
		case CalculatorFields::Module_imports:
			return L"Module::imports";
		case CalculatorFields::NumExpr_value:
			return L"NumExpr::value";
		case CalculatorFields::Ref_name:
			return L"Ref::name";
		case CalculatorFields::Unary_op:
			return L"Unary::op";
		case CalculatorFields::Unary_operand:
			return L"Unary::operand";
		default:
			return nullptr;
		}
	}

	const wchar_t* CalculatorCppFieldName(CalculatorFields field)
	{
		switch(field)
		{
		case CalculatorFields::Arg_name:
			return L"calculator::Arg::name";
		case CalculatorFields::Binary_left:
			return L"calculator::Binary::left";
		case CalculatorFields::Binary_op:
			return L"calculator::Binary::op";
		case CalculatorFields::Binary_right:
			return L"calculator::Binary::right";
		case CalculatorFields::Call_args:
			return L"calculator::Call::args";
		case CalculatorFields::Call_func:
			return L"calculator::Call::func";
		case CalculatorFields::Expandable_expanded:
			return L"calculator::Expandable::expanded";
		case CalculatorFields::Func_args:
			return L"calculator::Func::args";
		case CalculatorFields::Func_value:
			return L"calculator::Func::value";
		case CalculatorFields::Import_name:
			return L"calculator::Import::name";
		case CalculatorFields::LetExpr_name:
			return L"calculator::LetExpr::name";
		case CalculatorFields::LetExpr_result:
			return L"calculator::LetExpr::result";
		case CalculatorFields::LetExpr_value:
			return L"calculator::LetExpr::value";
		case CalculatorFields::Module_exported:
			return L"calculator::Module::exported";
		case CalculatorFields::Module_imports:
			return L"calculator::Module::imports";
		case CalculatorFields::NumExpr_value:
			return L"calculator::NumExpr::value";
		case CalculatorFields::Ref_name:
			return L"calculator::Ref::name";
		case CalculatorFields::Unary_op:
			return L"calculator::Unary::op";
		case CalculatorFields::Unary_operand:
			return L"calculator::Unary::operand";
		default:
			return nullptr;
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = CalculatorCppTypeName((CalculatorClasses)type);
		if (cppTypeName)
			throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Type \"") + vl::WString::Unmanaged(cppTypeName) + vl::WString::Unmanaged(L"\" is not configured to allow ambiguity."), vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		else
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
	}
}
