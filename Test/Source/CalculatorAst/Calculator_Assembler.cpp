/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Calculator
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Calculator_Assembler.h"

namespace calculator
{

/***********************************************************************
CalculatorAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
			return new calculator::Arg();
		case CalculatorClasses::Binary:
			return new calculator::Binary();
		case CalculatorClasses::Call:
			return new calculator::Call();
		case CalculatorClasses::Expandable:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expandable\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::Expr:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expr\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::False:
			return new calculator::False();
		case CalculatorClasses::Func:
			return new calculator::Func();
		case CalculatorClasses::Import:
			return new calculator::Import();
		case CalculatorClasses::LetExpr:
			return new calculator::LetExpr();
		case CalculatorClasses::Module:
			return new calculator::Module();
		case CalculatorClasses::NumExpr:
			return new calculator::NumExpr();
		case CalculatorClasses::Ref:
			return new calculator::Ref();
		case CalculatorClasses::True:
			return new calculator::True();
		case CalculatorClasses::Unary:
			return new calculator::Unary();
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_left:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->left) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->left = typedValue;
			}
			break;
		case CalculatorFields::Binary_right:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->right) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->right = typedValue;
			}
			break;
		case CalculatorFields::Call_arg:
			{
				auto typedObject = dynamic_cast<calculator::Call*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->arg) throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->arg = typedValue;
			}
			break;
		case CalculatorFields::Call_func:
			{
				auto typedObject = dynamic_cast<calculator::Call*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->func) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->func = typedValue;
			}
			break;
		case CalculatorFields::Expandable_expanded:
			{
				auto typedObject = dynamic_cast<calculator::Expandable*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->expanded) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->expanded = typedValue;
			}
			break;
		case CalculatorFields::Func_args:
			{
				auto typedObject = dynamic_cast<calculator::Func*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<calculator::Arg>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->args.Add(typedValue);
			}
			break;
		case CalculatorFields::Func_value:
			{
				auto typedObject = dynamic_cast<calculator::Func*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->value = typedValue;
			}
			break;
		case CalculatorFields::LetExpr_value:
			{
				auto typedObject = dynamic_cast<calculator::LetExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->value = typedValue;
			}
			break;
		case CalculatorFields::Module_exported:
			{
				auto typedObject = dynamic_cast<calculator::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->exported) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->exported = typedValue;
			}
			break;
		case CalculatorFields::Module_imports:
			{
				auto typedObject = dynamic_cast<calculator::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<calculator::Import>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->imports.Add(typedValue);
			}
			break;
		case CalculatorFields::Unary_operand:
			{
				auto typedObject = dynamic_cast<calculator::Unary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->operand) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<calculator::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->operand = typedValue;
			}
			break;
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Arg_name:
			{
				auto typedObject = dynamic_cast<calculator::Arg*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::Import_name:
			{
				auto typedObject = dynamic_cast<calculator::Import*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::LetExpr_name:
			{
				auto typedObject = dynamic_cast<calculator::LetExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::NumExpr_value:
			{
				auto typedObject = dynamic_cast<calculator::NumExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->value.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->value, token);
			}
			break;
		case CalculatorFields::Ref_name:
			{
				auto typedObject = dynamic_cast<calculator::Ref*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_arg:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_op:
			{
				auto typedObject = dynamic_cast<calculator::Binary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == calculator::BinaryOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (calculator::BinaryOp)enumItem;
			}
			break;
		case CalculatorFields::Unary_op:
			{
				auto typedObject = dynamic_cast<calculator::Unary*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == calculator::UnaryOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (calculator::UnaryOp)enumItem;
			}
			break;
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_arg:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
		case CalculatorClasses::Binary:
		case CalculatorClasses::Call:
		case CalculatorClasses::Expandable:
		case CalculatorClasses::Expr:
		case CalculatorClasses::False:
		case CalculatorClasses::Func:
		case CalculatorClasses::Import:
		case CalculatorClasses::LetExpr:
		case CalculatorClasses::Module:
		case CalculatorClasses::NumExpr:
		case CalculatorClasses::Ref:
		case CalculatorClasses::True:
		case CalculatorClasses::Unary:
			throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}
}
