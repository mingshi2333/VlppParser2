/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Calculator
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "Calculator_Assembler.h"

namespace calculator
{

/***********************************************************************
CalculatorAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
			return new calculator::Arg();
		case CalculatorClasses::Binary:
			return new calculator::Binary();
		case CalculatorClasses::Call:
			return new calculator::Call();
		case CalculatorClasses::Expandable:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expandable\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::Expr:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"calculator::Expr\".", vl::glr::AstInsErrorType::UnknownType, type);
		case CalculatorClasses::False:
			return new calculator::False();
		case CalculatorClasses::Func:
			return new calculator::Func();
		case CalculatorClasses::Import:
			return new calculator::Import();
		case CalculatorClasses::LetExpr:
			return new calculator::LetExpr();
		case CalculatorClasses::Module:
			return new calculator::Module();
		case CalculatorClasses::NumExpr:
			return new calculator::NumExpr();
		case CalculatorClasses::Ref:
			return new calculator::Ref();
		case CalculatorClasses::True:
			return new calculator::True();
		case CalculatorClasses::Unary:
			return new calculator::Unary();
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_left:
			if (auto typedObject = dynamic_cast<calculator::Binary*>(object))
			{
				if (!typedObject->left)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Binary_right:
			if (auto typedObject = dynamic_cast<calculator::Binary*>(object))
			{
				if (!typedObject->right)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Call_arg:
			if (auto typedObject = dynamic_cast<calculator::Call*>(object))
			{
				if (!typedObject->arg)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Call_func:
			if (auto typedObject = dynamic_cast<calculator::Call*>(object))
			{
				if (!typedObject->func)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Expandable_expanded:
			if (auto typedObject = dynamic_cast<calculator::Expandable*>(object))
			{
				if (!typedObject->expanded)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Func_args:
			if (auto typedObject = dynamic_cast<calculator::Func*>(object))
			{
				if (auto typedValue = value.Cast<calculator::Arg>())
				{
					typedObject->args.Add(typedValue);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Func_value:
			if (auto typedObject = dynamic_cast<calculator::Func*>(object))
			{
				if (!typedObject->value)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::LetExpr_value:
			if (auto typedObject = dynamic_cast<calculator::LetExpr*>(object))
			{
				if (!typedObject->value)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Module_exported:
			if (auto typedObject = dynamic_cast<calculator::Module*>(object))
			{
				if (!typedObject->exported)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Module_imports:
			if (auto typedObject = dynamic_cast<calculator::Module*>(object))
			{
				if (auto typedValue = value.Cast<calculator::Import>())
				{
					typedObject->imports.Add(typedValue);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Unary_operand:
			if (auto typedObject = dynamic_cast<calculator::Unary*>(object))
			{
				if (!typedObject->operand)
				{
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not an object.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Arg_name:
			if (auto typedObject = dynamic_cast<calculator::Arg*>(object))
			{
				if (typedObject->name.value.Length() == 0)
				{
					AssignToken(typedObject->name, token);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Import_name:
			if (auto typedObject = dynamic_cast<calculator::Import*>(object))
			{
				if (typedObject->name.value.Length() == 0)
				{
					AssignToken(typedObject->name, token);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::LetExpr_name:
			if (auto typedObject = dynamic_cast<calculator::LetExpr*>(object))
			{
				if (typedObject->name.value.Length() == 0)
				{
					AssignToken(typedObject->name, token);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::NumExpr_value:
			if (auto typedObject = dynamic_cast<calculator::NumExpr*>(object))
			{
				if (typedObject->value.value.Length() == 0)
				{
					AssignToken(typedObject->value, token);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Ref_name:
			if (auto typedObject = dynamic_cast<calculator::Ref*>(object))
			{
				if (typedObject->name.value.Length() == 0)
				{
					AssignToken(typedObject->name, token);
					break;
				}
				else
				{
					throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				}
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_arg:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_op:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void CalculatorAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		switch((CalculatorFields)field)
		{
		case CalculatorFields::Binary_op:
			if (auto typedObject = dynamic_cast<calculator::Binary*>(object))
			{
				typedObject->op = (calculator::BinaryOp)enumItem;
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Binary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Unary_op:
			if (auto typedObject = dynamic_cast<calculator::Unary*>(object))
			{
				typedObject->op = (calculator::UnaryOp)enumItem;
			}
			else
			{
				throw vl::glr::AstInsException(L"Field \"calculator::Unary::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
			}
		case CalculatorFields::Arg_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Arg::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_left:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::left\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Binary_right:
			throw vl::glr::AstInsException(L"Field \"calculator::Binary::right\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_arg:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::arg\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Call_func:
			throw vl::glr::AstInsException(L"Field \"calculator::Call::func\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Expandable_expanded:
			throw vl::glr::AstInsException(L"Field \"calculator::Expandable::expanded\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_args:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::args\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Func_value:
			throw vl::glr::AstInsException(L"Field \"calculator::Func::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Import_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Import::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_name:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::LetExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::LetExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_exported:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::exported\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Module_imports:
			throw vl::glr::AstInsException(L"Field \"calculator::Module::imports\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::NumExpr_value:
			throw vl::glr::AstInsException(L"Field \"calculator::NumExpr::value\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Ref_name:
			throw vl::glr::AstInsException(L"Field \"calculator::Ref::name\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case CalculatorFields::Unary_operand:
			throw vl::glr::AstInsException(L"Field \"calculator::Unary::operand\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> CalculatorAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		switch((CalculatorClasses)type)
		{
		case CalculatorClasses::Arg:
		case CalculatorClasses::Binary:
		case CalculatorClasses::Call:
		case CalculatorClasses::Expandable:
		case CalculatorClasses::Expr:
		case CalculatorClasses::False:
		case CalculatorClasses::Func:
		case CalculatorClasses::Import:
		case CalculatorClasses::LetExpr:
		case CalculatorClasses::Module:
		case CalculatorClasses::NumExpr:
		case CalculatorClasses::Ref:
		case CalculatorClasses::True:
		case CalculatorClasses::Unary:
			throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}
}
