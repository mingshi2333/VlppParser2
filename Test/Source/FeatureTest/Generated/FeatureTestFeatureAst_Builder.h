/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_UNITTEST_FEATURETEST_FEATUREAST_AST_BUILDER
#define VCZH_PARSER2_UNITTEST_FEATURETEST_FEATUREAST_AST_BUILDER

#include "FeatureTestFeatureAst.h"

namespace featuretest
{
	namespace builder
	{
		class BranchedOptionalFeatureBuilder
		{
		private:
			BranchedOptionalFeature* node;
		public:
			BranchedOptionalFeatureBuilder(BranchedOptionalFeature* _node) : node(_node) {}
			BranchedOptionalFeatureBuilder& optional(const vl::Ptr<Plus>& value);
			BranchedOptionalFeatureBuilder& tails(const vl::Ptr<Plus>& value);
			BranchedOptionalFeatureBuilder& type(BranchType value);
		};

		class FeatureToResolveBuilder
		{
		private:
			FeatureToResolve* node;
		public:
			FeatureToResolveBuilder(FeatureToResolve* _node) : node(_node) {}
			FeatureToResolveBuilder& candidates(const vl::Ptr<Feature>& value);
		};

		class NestedOptionalFeatureBuilder
		{
		private:
			NestedOptionalFeature* node;
		public:
			NestedOptionalFeatureBuilder(NestedOptionalFeature* _node) : node(_node) {}
			NestedOptionalFeatureBuilder& optional(const vl::Ptr<Plus>& value);
			NestedOptionalFeatureBuilder& tail1(const vl::Ptr<Plus>& value);
			NestedOptionalFeatureBuilder& tail2(const vl::Ptr<Plus>& value);
			NestedOptionalFeatureBuilder& tail3(const vl::Ptr<Plus>& value);
			NestedOptionalFeatureBuilder& tails(const vl::Ptr<Plus>& value);
		};

		class OptionalFeatureBuilder
		{
		private:
			OptionalFeature* node;
		public:
			OptionalFeatureBuilder(OptionalFeature* _node) : node(_node) {}
			OptionalFeatureBuilder& loop(const vl::Ptr<Plus>& value);
			OptionalFeatureBuilder& optional(const vl::Ptr<Plus>& value);
			OptionalFeatureBuilder& priority(OptionalProprity value);
		};

		class PbaFeatureBuilder
		{
		private:
			PbaFeature* node;
		public:
			PbaFeatureBuilder(PbaFeature* _node) : node(_node) {}
			PbaFeatureBuilder& gts(const vl::Ptr<Gt>& value);
			PbaFeatureBuilder& lts(const vl::Ptr<Lt>& value);
			PbaFeatureBuilder& optional(const vl::Ptr<Plus>& value);
			PbaFeatureBuilder& tail(const vl::Ptr<Plus>& value);
			PbaFeatureBuilder& tails(const vl::Ptr<Plus>& value);
		};

		class Pwa1FeatureBuilder
		{
		private:
			Pwa1Feature* node;
		public:
			Pwa1FeatureBuilder(Pwa1Feature* _node) : node(_node) {}
			Pwa1FeatureBuilder& gts(const vl::Ptr<Gt>& value);
			Pwa1FeatureBuilder& lts(const vl::Ptr<Lt>& value);
			Pwa1FeatureBuilder& pba(const vl::Ptr<Feature>& value);
		};

		class PwlFeatureBuilder
		{
		private:
			PwlFeature* node;
		public:
			PwlFeatureBuilder(PwlFeature* _node) : node(_node) {}
			PwlFeatureBuilder& lt(const vl::Ptr<Lt>& value);
			PwlFeatureBuilder& prefix(const vl::Ptr<Plus>& value);
			PwlFeatureBuilder& prev(const vl::Ptr<PwlFeature>& value);
		};

		using MakeBranchedOptionalFeature = vl::glr::ParsingAstBuilder<BranchedOptionalFeature, BranchedOptionalFeatureBuilder>;
		using MakeFeatureToResolve = vl::glr::ParsingAstBuilder<FeatureToResolve, FeatureToResolveBuilder>;
		using MakeGt = vl::glr::ParsingAstBuilder<Gt>;
		using MakeLt = vl::glr::ParsingAstBuilder<Lt>;
		using MakeNestedOptionalFeature = vl::glr::ParsingAstBuilder<NestedOptionalFeature, NestedOptionalFeatureBuilder>;
		using MakeOptionalFeature = vl::glr::ParsingAstBuilder<OptionalFeature, OptionalFeatureBuilder>;
		using MakePbaFeature = vl::glr::ParsingAstBuilder<PbaFeature, PbaFeatureBuilder>;
		using MakePlus = vl::glr::ParsingAstBuilder<Plus>;
		using MakePwa1Feature = vl::glr::ParsingAstBuilder<Pwa1Feature, Pwa1FeatureBuilder>;
		using MakePwlFeature = vl::glr::ParsingAstBuilder<PwlFeature, PwlFeatureBuilder>;
	}
}
#endif