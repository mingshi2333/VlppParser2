/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTestModuleParser.h"

namespace featuretest
{
	void FeatureTestModuleParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 1013; // 7546 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 245;
		static const vl::vint dataSolidRows = 3;
		static const vl::vint dataRows = 4;
		static const char* compressed[] = {
			"\x7A\x1D\x00\x00\xED\x03\x00\x00\x05\x00\x01\x82\x80\x00\x83\x81\x81\x82\x06\x89\x81\x83\x0A\x81\x06\x85\x07\x0A\x95\x0A\x96\x5A\x87\x7E\x8B\x8B\x16\x8A\x80\x18\x88\x8A\x8C\x8F\x8B\x1E\x9F\xBF\x61\x9F\x8A\x8E\x8D\x00\x15\xA2\xA4\x9C\x8B\x95\x8D\x95\x92\x2F\xAC\xB1\x8E\x99\x82\x93\x91\x99\x20\x8A\xA8\x89\x8B\x9E\x82\x9B\x96\x39\xB5\xAA\x98\x99\x8C\xA3\x9A\xA1\x30\xC8\xB2\x8A\xA4\x9E\x82\x00\x9D\x46\xC0\x85\xAC\xA1\xA6\x9F\xA0\xAA\x53\xD6\x89\xBA\xAB\xA4\xAD\xA7\x81\x3F\xD1\xA2\xB8\xA7\xA6\xAD\xAA\xB0\x57\xE6\x99\xA8\xBB\xAB\x80\x87\x84\x4F\xE4\x92\xA5\xBC\xB5\xAD\xBB\xAF\x02\xE1\xB2\xAA\x88\x83\x81\x9F\xBB\x67\x82\x86\x10\xAB\xBD\xC2\xB4\xBA\x79\xE9\x83\x87\x04\xC7\xC2\x8C\x04\x8D\x80\xEB\xA9\xCD\xB4\xCA\xBA\xCB\x78\x81\x8E\x9C\x93\xB6\xC5\xCE\xC9\x88\x81\x8A\x11\xC8\xC9\xC1\x80\xBD\x9E\x86\xE0\xD3\xBC\xD7\xCD\xD3\xC9\xA7\x8A\xEF\xC1\xDB\x8A\xD9\xD9\xCA\xB7\x97\xF9\xD9\xC0\x03\x06\x85\xB8\xA9\xC1\xEB\xCE\xDB\xDE\xD1\xDA\xDC\x00\x0D\x24\xC5\xE0\xD8\x02\x07\xE5\xC7\xBA\xD1\xFC\xD8\xD3\xE1\x84\x88\x9C\xAA\xC2\x90",
			"\x00\xED\xEB\xD9\xD6\xDA\x81\x91\x1D\xE6\xDB\xEA\xE2\xEF\xCC\xB4\xE8\xE0\x02\x0C\xF0\xE5\xF5\xF0\xE5\xF1\xEF\xF2\xFD\xF8\xFB\xFB\xD2\xF3\xF9\xE5\xF3\x0F\xDC\xE2\xF3\xCD\x7A\x74\x76\x7D\xD2\x52\x49\x76\x70\x02\x56\x0E\x7B\x7E\xF8\x43\x88\x73\x05\x0B\xBC\x68\x05\x84\xE7\x44\x8E\x82\x74\x19\x14\x81\x82\x85\xC6\x5A\x00\x77\x06\xD0\x5C\x0A\x86\x7A\x1C\x9B\x8D\x81\x85\x27\xA6\x8C\x82\x74\x1D\x23\x80\x78\x82\xE9\x6F\x86\x76\x41\x1E\x2E\x8F\x7E\x80\x28\xAB\x8C\x6F\x07\x36\xA1\x70\x80\x89\x29\x80\x92\x76\x0C\xFE\x49\x4F\x5B\x61\x7D\x73\x66\x4C\x70\x03\x4C\x93\x6E\x93\x0B\x46\x5F\x5E\x49\xE9\x4C\x66\x92\x51\x49\xA9\x7B\x92\x42\x47\xA0\x63\x94\x95\x36\x56\x96\x41\x97\xB3\x59\x9F\x8F\x96\x57\xA4\x50\x94\x00\x6B\xA8\x93\x9A\x94\x23\xA2\x9E\x58\x96\x46\x6E\x93\x9C\x59\x5F\x80\x09\x9D\x98\x5C\xB4\x94\x5A\x9D\x02\x64\x99\x7B\x9A\x6D\xA2\x4B\x9A\xA0\x3F\xB9\x95\xA3\x47\x72\x81\xAE\x9F\x61\x80\x91\x98\x9D\x91\x87\x4D\xA2\xA4\x92\x75\x86\xAD\x9E\x9A\x94\xA0\x64\xA2\x51\x9F\xA4\x56\x9A\x4D\x36\x63\xA4\xAB\x47\xA6\xA7\xA8\x46\xA5",
			"\x6C\x86\x5C\xAB\x9E\x22\x6F\xAE\xA9\xA7\xB3\x72\xA4\x5A\xAD\x95\xB4\xA5\x95\x9C\x23\x84\x09\xA7\x47\xBE\xBF\x92\x49\xB0\x90\xA2\x4C\x00\x95\x06\x4A\xAB\xA6\x41\xC4\x83\x46\x9B\x60\x09\x6C\xA0\x65\x42\x9B\x46\x43\x69\x42\xBE\x49\x47\xB0\xB2\x82\x5C\xB2\x42\x09\xD0\x4F\x6E\xB5\x40\x27\x21\xBA\x43\xB4\xDE\xA8\x06\xBA\xB6\xD0\x69\x0B\xBA\x41\xCF\x63\xBA\x0B\xBB\x03\x71\xBE\xB7\x0A\xF4\x82\x4D\x78\x5C\x0A\x6C\x09\xBD\x40\x14\x23\xB0\x01\x0B\xFF\x80\x01\xC3\xB8\x2E\x10\x79\x9C\x84\xE3\xAF\x00\x77\x9A\x19\xA3\xB0\x0C\x74\x88\x93\x83\xB9\x0C\xD0\x60\x02\xC3\x9A\x02\xFA\x97\x8D\x79\x6B\xB9\x97\x49\x8F\x30\x80\x08\xA2\x99\x1A\x61\xCF\xC4\x72\x66\x9C\xCB\xB2\x5F\xFF\x63\xC9\x42\x99\xAC\xB2\x8F\x77\x7F\xD0\x86\x45\xCF\xCA\x3A\x86\x7C\xA9\xB3\xC8\x80\xD7\xA7\x8C\x44\xC2\x4C\xAA\xCB\xD1\xA4\xC0\xCF\x81\x03\x68\xB3\x42\xD0\x26\x4E\xDE\xA2\x8F\xEB\x52\xD1\x40\xD2\x06\x59\xB9\xB3\x7F\x2A\xD4\xBA\x42\xD6\xDC\x9B\xBB\xD4\xD5\xE5\x60\xD2\x40\xD6\x03\x4A\x7C\xD3\xCD\x69\xA3\xD9\xD6\x42\x6A\xCE\x5C\xCF\x85\xBC\x62\xD9\xDA\xC0\x38",
			"\xAA\x8C\x6D\xDC\x03\x57\xBE\xB6\xBD\x77\xA5\xCB\x78\xDF\x67\xC2\xC3\x7B\xDA\x31\x8A\x40\xD5\x9E\x80\xC2\x4E\xDC\xB7\xFB\xAF\x94\xD8\x72\x8D\xD7\xD2\xC2\x81\x6E\xC5\xD7\x40\x74\xD8\x46\x47\xE2\xB7\x0A\x88\xEF\x8E\xCD\xE2\x7A\xA6\x48\xC3\x99\xEC\xD6\x41\xCE\x4B\xDE\xEA\x41\x7F\xA2\xF9\xD2\x90\x6F\x91\xC3\x40\xEE\xB7\xB2\xE4\xE0\x03\xED\x03\x5C\x73\xBA\xC5\x92\xC2\xEC\x7E\xE9\x1A\x60\x81\xED\x79\xB8\x83\x47\xC2\x41\xBE\xDE\xB2\x89\xDB\x9A\xE3\xEA\x43\xF2\x4D\x82\xCC\x8F\xF1\xC8\x56\xDE\xC5\x42\x98\xCE\xB2\xC2\xC6\xD8\xD2\x75\xB5\xEB\x03\x5D\xF2\x42\xD9\x54\xA1\x0A\xD2\xE3\xD0\x66\xF5\xEB\xB8\x22\x2B\xF1\x40\xFA\xDB\xC6\x48\xEB\x40\xA1\xDE\xB3\x0A\xFC\xD2\xC9\x40\xF0\xFE\x02\x64\x04\xFF\x6B\x31\x62\x83\x39\x7C\x5B\x25\x03\x81\x79\x1E\x43\x5D\xF5\x27\x4D\x63\xF5\x6B\x34\xAC\x22\x22\x64\x99\x63\x5D\x82\x05\x6D\x56\x5C\x0B\x5F\x22\xB4\x55\x7B\x63\x1D\x7E\x83\xD4\x0E\x38\x50\x52\x48\x56\x24\x27\x9A\x21\x0A\xAF\x6C\x5A\xA8\x7F\x26\x85\x36\x30\x6A\x49\x50\x6C\x63\xC5\x5A\x20",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ModuleParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"Plus",
			L"EqualOptional",
			L"PositiveOptional",
			L"NegativeOptional",
			L"Module",
		};
		return results[index];
	}

	const wchar_t* ModuleParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][Plus] BEGIN ",
			L"[1][Plus] END [ENDING]",
			L"[2][Plus]< \"+\" @ >",
			L"[3][EqualOptional] BEGIN ",
			L"[4][EqualOptional] END [ENDING]",
			L"[5][EqualOptional]< \"optional\" @ [ Plus ] \"+\" { Plus } >",
			L"[6][EqualOptional]< \"optional\" [ Plus @ ] \"+\" { Plus } >",
			L"[7][EqualOptional]< \"optional\" [ Plus ] \"+\" @ { Plus } >",
			L"[8][EqualOptional]< \"optional\" [ Plus ] \"+\" { Plus @ } >",
			L"[9][PositiveOptional] BEGIN ",
			L"[10][PositiveOptional] END [ENDING]",
			L"[11][PositiveOptional]< \"positive_optional\" @ [ Plus ] \"+\" { Plus } >",
			L"[12][PositiveOptional]< \"positive_optional\" [ Plus @ ] \"+\" { Plus } >",
			L"[13][PositiveOptional]< \"positive_optional\" [ Plus ] \"+\" @ { Plus } >",
			L"[14][PositiveOptional]< \"positive_optional\" [ Plus ] \"+\" { Plus @ } >",
			L"[15][NegativeOptional] BEGIN ",
			L"[16][NegativeOptional] END [ENDING]",
			L"[17][NegativeOptional]< \"negative_optional\" @ [ Plus ] \"+\" { Plus } >",
			L"[18][NegativeOptional]< \"negative_optional\" [ Plus @ ] \"+\" { Plus } >",
			L"[19][NegativeOptional]< \"negative_optional\" [ Plus ] \"+\" @ { Plus } >",
			L"[20][NegativeOptional]< \"negative_optional\" [ Plus ] \"+\" { Plus @ } >",
			L"[21][Module] BEGIN ",
			L"[22][Module] END [ENDING]",
			L"[23][Module]<< !EqualOptional @ >>",
			L"[24][Module]<< !NegativeOptional @ >>",
			L"[25][Module]<< !PositiveOptional @ >>",
		};
		return results[index];
	}

	ModuleParser::ModuleParser()
		: vl::glr::ParserBase<FeatureTestTokens, ModuleParserStates, FeatureTestAstInsReceiver, ModuleParserStateTypes>(&FeatureTestTokenDeleter, &FeatureTestLexerData, &FeatureTestModuleParserData)
	{
	};

	vl::vint32_t ModuleParser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2)
	{
		static vl::vint32_t results[4][4] = {
			{0, 0, 0, -1, },
			{0, 1, 0, -1, },
			{0, 0, 2, -1, },
			{-1, -1, -1, 3, },
		};
		return vl::glr::AssemblerFindCommonBaseClass(class1, class2, results);
	};

	vl::Ptr<featuretest::OptionalFeature> ModuleParser::ParseModule(const vl::WString & input, vl::vint codeIndex)
	{
		 return Parse<ModuleParserStates::Module>(input, this, codeIndex);
	};
}
