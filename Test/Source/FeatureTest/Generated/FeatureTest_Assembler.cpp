/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTest_Assembler.h"

namespace featuretest
{

/***********************************************************************
FeatureTestAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> FeatureTestAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		auto cppTypeName = FeatureTestCppTypeName((FeatureTestClasses)type);
		switch((FeatureTestClasses)type)
		{
		case FeatureTestClasses::BranchedOptionalFeature:
			return vl::Ptr(new featuretest::BranchedOptionalFeature);
		case FeatureTestClasses::ClFeature:
			return vl::Ptr(new featuretest::ClFeature);
		case FeatureTestClasses::FaFeature:
			return vl::Ptr(new featuretest::FaFeature);
		case FeatureTestClasses::FeatureToResolve:
			return vl::Ptr(new featuretest::FeatureToResolve);
		case FeatureTestClasses::Gt:
			return vl::Ptr(new featuretest::Gt);
		case FeatureTestClasses::Lt:
			return vl::Ptr(new featuretest::Lt);
		case FeatureTestClasses::NestedOptionalFeature:
			return vl::Ptr(new featuretest::NestedOptionalFeature);
		case FeatureTestClasses::OptionalFeature:
			return vl::Ptr(new featuretest::OptionalFeature);
		case FeatureTestClasses::PbaFeature:
			return vl::Ptr(new featuretest::PbaFeature);
		case FeatureTestClasses::Plus:
			return vl::Ptr(new featuretest::Plus);
		case FeatureTestClasses::Pwa1Feature:
			return vl::Ptr(new featuretest::Pwa1Feature);
		case FeatureTestClasses::PwlFeature:
			return vl::Ptr(new featuretest::PwlFeature);
		default:
			return vl::glr::AssemblyThrowCannotCreateAbstractType(type, cppTypeName);
		}
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		switch((FeatureTestFields)field)
		{
		case FeatureTestFields::BranchedOptionalFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::BranchedOptionalFeature::optional, object, field, value, cppFieldName);
		case FeatureTestFields::BranchedOptionalFeature_tails:
			return vl::glr::AssemblerSetObjectField(&featuretest::BranchedOptionalFeature::tails, object, field, value, cppFieldName);
		case FeatureTestFields::FeatureToResolve_candidates:
			return vl::glr::AssemblerSetObjectField(&featuretest::FeatureToResolve::candidates, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::optional, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail1:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail1, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail2:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail2, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail3:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail3, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tails:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tails, object, field, value, cppFieldName);
		case FeatureTestFields::OptionalFeature_loop:
			return vl::glr::AssemblerSetObjectField(&featuretest::OptionalFeature::loop, object, field, value, cppFieldName);
		case FeatureTestFields::OptionalFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::OptionalFeature::optional, object, field, value, cppFieldName);
		case FeatureTestFields::PbaFeature_gts:
			return vl::glr::AssemblerSetObjectField(&featuretest::PbaFeature::gts, object, field, value, cppFieldName);
		case FeatureTestFields::PbaFeature_lts:
			return vl::glr::AssemblerSetObjectField(&featuretest::PbaFeature::lts, object, field, value, cppFieldName);
		case FeatureTestFields::PbaFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::PbaFeature::optional, object, field, value, cppFieldName);
		case FeatureTestFields::PbaFeature_tail:
			return vl::glr::AssemblerSetObjectField(&featuretest::PbaFeature::tail, object, field, value, cppFieldName);
		case FeatureTestFields::PbaFeature_tails:
			return vl::glr::AssemblerSetObjectField(&featuretest::PbaFeature::tails, object, field, value, cppFieldName);
		case FeatureTestFields::Pwa1Feature_gts:
			return vl::glr::AssemblerSetObjectField(&featuretest::Pwa1Feature::gts, object, field, value, cppFieldName);
		case FeatureTestFields::Pwa1Feature_lts:
			return vl::glr::AssemblerSetObjectField(&featuretest::Pwa1Feature::lts, object, field, value, cppFieldName);
		case FeatureTestFields::Pwa1Feature_pba:
			return vl::glr::AssemblerSetObjectField(&featuretest::Pwa1Feature::pba, object, field, value, cppFieldName);
		case FeatureTestFields::PwlFeature_one:
			return vl::glr::AssemblerSetObjectField(&featuretest::PwlFeature::one, object, field, value, cppFieldName);
		case FeatureTestFields::PwlFeature_prefix:
			return vl::glr::AssemblerSetObjectField(&featuretest::PwlFeature::prefix, object, field, value, cppFieldName);
		case FeatureTestFields::PwlFeature_prev:
			return vl::glr::AssemblerSetObjectField(&featuretest::PwlFeature::prev, object, field, value, cppFieldName);
		case FeatureTestFields::PwlFeature_two:
			return vl::glr::AssemblerSetObjectField(&featuretest::PwlFeature::two, object, field, value, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotObject(field, cppFieldName);
		}
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		switch((FeatureTestFields)field)
		{
		case FeatureTestFields::ClFeature_id:
			return vl::glr::AssemblerSetTokenField(&featuretest::ClFeature::id, object, field, token, tokenIndex, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotToken(field, cppFieldName);
		}
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		switch((FeatureTestFields)field)
		{
		case FeatureTestFields::BranchedOptionalFeature_type:
			return vl::glr::AssemblerSetEnumField(&featuretest::BranchedOptionalFeature::type, object, field, enumItem, weakAssignment, cppFieldName);
		case FeatureTestFields::FaFeature_fa:
			return vl::glr::AssemblerSetEnumField(&featuretest::FaFeature::fa, object, field, enumItem, weakAssignment, cppFieldName);
		case FeatureTestFields::OptionalFeature_priority:
			return vl::glr::AssemblerSetEnumField(&featuretest::OptionalFeature::priority, object, field, enumItem, weakAssignment, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotEnum(field, cppFieldName);
		}
	}

	const wchar_t* FeatureTestTypeName(FeatureTestClasses type)
	{
		const wchar_t* results[] = {
			L"BranchedOptionalFeature",
			L"ClFeature",
			L"FaFeature",
			L"Feature",
			L"FeatureToResolve",
			L"Gt",
			L"Lt",
			L"NestedOptionalFeature",
			L"OptionalFeature",
			L"PbaFeature",
			L"Plus",
			L"Pwa1Feature",
			L"PwlFeature",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 13 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestCppTypeName(FeatureTestClasses type)
	{
		const wchar_t* results[] = {
			L"featuretest::BranchedOptionalFeature",
			L"featuretest::ClFeature",
			L"featuretest::FaFeature",
			L"featuretest::Feature",
			L"featuretest::FeatureToResolve",
			L"featuretest::Gt",
			L"featuretest::Lt",
			L"featuretest::NestedOptionalFeature",
			L"featuretest::OptionalFeature",
			L"featuretest::PbaFeature",
			L"featuretest::Plus",
			L"featuretest::Pwa1Feature",
			L"featuretest::PwlFeature",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 13 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestFieldName(FeatureTestFields field)
	{
		const wchar_t* results[] = {
			L"BranchedOptionalFeature::optional",
			L"BranchedOptionalFeature::tails",
			L"BranchedOptionalFeature::type",
			L"ClFeature::id",
			L"FaFeature::fa",
			L"FeatureToResolve::candidates",
			L"NestedOptionalFeature::optional",
			L"NestedOptionalFeature::tail1",
			L"NestedOptionalFeature::tail2",
			L"NestedOptionalFeature::tail3",
			L"NestedOptionalFeature::tails",
			L"OptionalFeature::loop",
			L"OptionalFeature::optional",
			L"OptionalFeature::priority",
			L"PbaFeature::gts",
			L"PbaFeature::lts",
			L"PbaFeature::optional",
			L"PbaFeature::tail",
			L"PbaFeature::tails",
			L"Pwa1Feature::gts",
			L"Pwa1Feature::lts",
			L"Pwa1Feature::pba",
			L"PwlFeature::one",
			L"PwlFeature::prefix",
			L"PwlFeature::prev",
			L"PwlFeature::two",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 26 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestCppFieldName(FeatureTestFields field)
	{
		const wchar_t* results[] = {
			L"featuretest::BranchedOptionalFeature::optional",
			L"featuretest::BranchedOptionalFeature::tails",
			L"featuretest::BranchedOptionalFeature::type",
			L"featuretest::ClFeature::id",
			L"featuretest::FaFeature::fa",
			L"featuretest::FeatureToResolve::candidates",
			L"featuretest::NestedOptionalFeature::optional",
			L"featuretest::NestedOptionalFeature::tail1",
			L"featuretest::NestedOptionalFeature::tail2",
			L"featuretest::NestedOptionalFeature::tail3",
			L"featuretest::NestedOptionalFeature::tails",
			L"featuretest::OptionalFeature::loop",
			L"featuretest::OptionalFeature::optional",
			L"featuretest::OptionalFeature::priority",
			L"featuretest::PbaFeature::gts",
			L"featuretest::PbaFeature::lts",
			L"featuretest::PbaFeature::optional",
			L"featuretest::PbaFeature::tail",
			L"featuretest::PbaFeature::tails",
			L"featuretest::Pwa1Feature::gts",
			L"featuretest::Pwa1Feature::lts",
			L"featuretest::Pwa1Feature::pba",
			L"featuretest::PwlFeature::one",
			L"featuretest::PwlFeature::prefix",
			L"featuretest::PwlFeature::prev",
			L"featuretest::PwlFeature::two",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 26 ? results[index] : nullptr;
	}

	vl::Ptr<vl::glr::ParsingAstBase> FeatureTestAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = FeatureTestCppTypeName((FeatureTestClasses)type);
		switch((FeatureTestClasses)type)
		{
		case FeatureTestClasses::BranchedOptionalFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::BranchedOptionalFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::ClFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::ClFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::FaFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::FaFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::Feature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::Feature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::FeatureToResolve:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::FeatureToResolve, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::NestedOptionalFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::NestedOptionalFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::OptionalFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::OptionalFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::PbaFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::PbaFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::Pwa1Feature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::Pwa1Feature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::PwlFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::PwlFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		default:
			return vl::glr::AssemblyThrowTypeNotAllowAmbiguity(type, cppTypeName);
		}
	}
}
