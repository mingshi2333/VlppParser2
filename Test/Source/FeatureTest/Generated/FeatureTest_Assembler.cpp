/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTest_Assembler.h"

namespace featuretest
{

/***********************************************************************
FeatureTestAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> FeatureTestAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		auto cppTypeName = FeatureTestCppTypeName((FeatureTestClasses)type);
		switch((FeatureTestClasses)type)
		{
		case FeatureTestClasses::FeatureToResolve:
			return new featuretest::FeatureToResolve();
		case FeatureTestClasses::NestedOptionalFeature:
			return new featuretest::NestedOptionalFeature();
		case FeatureTestClasses::OptionalFeature:
			return new featuretest::OptionalFeature();
		case FeatureTestClasses::Plus:
			return new featuretest::Plus();
		default:
			return vl::glr::AssemblyThrowCannotCreateAbstractType(type, cppTypeName);
		}
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		switch((FeatureTestFields)field)
		{
		case FeatureTestFields::FeatureToResolve_candidates:
			return vl::glr::AssemblerSetObjectField(&featuretest::FeatureToResolve::candidates, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::optional, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail1:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail1, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail2:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail2, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tail3:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tail3, object, field, value, cppFieldName);
		case FeatureTestFields::NestedOptionalFeature_tails:
			return vl::glr::AssemblerSetObjectField(&featuretest::NestedOptionalFeature::tails, object, field, value, cppFieldName);
		case FeatureTestFields::OptionalFeature_loop:
			return vl::glr::AssemblerSetObjectField(&featuretest::OptionalFeature::loop, object, field, value, cppFieldName);
		case FeatureTestFields::OptionalFeature_optional:
			return vl::glr::AssemblerSetObjectField(&featuretest::OptionalFeature::optional, object, field, value, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotObject(field, cppFieldName);
		}
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		return vl::glr::AssemblyThrowFieldNotToken(field, cppFieldName);
	}

	void FeatureTestAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		auto cppFieldName = FeatureTestCppFieldName((FeatureTestFields)field);
		switch((FeatureTestFields)field)
		{
		case FeatureTestFields::OptionalFeature_priority:
			return vl::glr::AssemblerSetEnumField(&featuretest::OptionalFeature::priority, object, field, enumItem, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotEnum(field, cppFieldName);
		}
	}

	const wchar_t* FeatureTestTypeName(FeatureTestClasses type)
	{
		const wchar_t* results[] = {
			L"Feature",
			L"FeatureToResolve",
			L"NestedOptionalFeature",
			L"OptionalFeature",
			L"Plus",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 5 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestCppTypeName(FeatureTestClasses type)
	{
		const wchar_t* results[] = {
			L"featuretest::Feature",
			L"featuretest::FeatureToResolve",
			L"featuretest::NestedOptionalFeature",
			L"featuretest::OptionalFeature",
			L"featuretest::Plus",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 5 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestFieldName(FeatureTestFields field)
	{
		const wchar_t* results[] = {
			L"FeatureToResolve::candidates",
			L"NestedOptionalFeature::optional",
			L"NestedOptionalFeature::tail1",
			L"NestedOptionalFeature::tail2",
			L"NestedOptionalFeature::tail3",
			L"NestedOptionalFeature::tails",
			L"OptionalFeature::loop",
			L"OptionalFeature::optional",
			L"OptionalFeature::priority",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 9 ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestCppFieldName(FeatureTestFields field)
	{
		const wchar_t* results[] = {
			L"featuretest::FeatureToResolve::candidates",
			L"featuretest::NestedOptionalFeature::optional",
			L"featuretest::NestedOptionalFeature::tail1",
			L"featuretest::NestedOptionalFeature::tail2",
			L"featuretest::NestedOptionalFeature::tail3",
			L"featuretest::NestedOptionalFeature::tails",
			L"featuretest::OptionalFeature::loop",
			L"featuretest::OptionalFeature::optional",
			L"featuretest::OptionalFeature::priority",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 9 ? results[index] : nullptr;
	}

	vl::Ptr<vl::glr::ParsingAstBase> FeatureTestAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = FeatureTestCppTypeName((FeatureTestClasses)type);
		switch((FeatureTestClasses)type)
		{
		case FeatureTestClasses::Feature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::Feature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::FeatureToResolve:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::FeatureToResolve, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::NestedOptionalFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::NestedOptionalFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		case FeatureTestClasses::OptionalFeature:
			return vl::glr::AssemblerResolveAmbiguity<featuretest::OptionalFeature, featuretest::FeatureToResolve>(type, candidates, cppTypeName);
		default:
			return vl::glr::AssemblyThrowTypeNotAllowAmbiguity(type, cppTypeName);
		}
	}
}
