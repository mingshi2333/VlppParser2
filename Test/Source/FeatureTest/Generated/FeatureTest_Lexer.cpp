/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTest_Lexer.h"

namespace featuretest
{
	bool FeatureTestTokenDeleter(vl::vint token)
	{
		switch((FeatureTestTokens)token)
		{
		case FeatureTestTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* FeatureTestTokenId(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"OPTIONAL",
			L"POSITIVE_OPTIONAL",
			L"NEGATIVE_OPTIONAL",
			L"NESTED_OPTIONAL",
			L"NESTED_POSITIVE_OPTIONAL",
			L"NESTED_NEGATIVE_OPTIONAL",
			L"BRANCHED_OPTIONAL",
			L"BRANCHED_OPTIONAL_2",
			L"PLUS",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenDisplayText(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"nested_optional",
			L"nested_positive_optional",
			L"nested_negative_optional",
			L"branched_optional",
			L"branched_optional_2",
			L"+",
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenRegex(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"nested_optional",
			L"nested_positive_optional",
			L"nested_negative_optional",
			L"branched_optional",
			L"branched_optional_2",
			L"/+",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	void FeatureTestLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 706; // 11418 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 194;
		static const vl::vint dataSolidRows = 2;
		static const vl::vint dataRows = 3;
		static const char* compressed[] = {
			"\x9A\x2C\x00\x00\xBA\x02\x00\x00\x70\x00\x01\x98\x01\x84\x81\x83\x0A\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x8B\x14\x88\x82\x19\x17\x84\x9F\x3A\x84\x81\x31\x8E\x82\x62\x20\x84\x83\x33\x94\x80\x32\x93\x04\xE5\x29\x84\x87\x34\x94\x82\x34\x2F\x84\xA9\x32\x94\x84\x35\x9A\x82\x6E\x38\x84\x8F\x3B\x9C\x80\x81\x80\x3F\x80\x32\x24\x83\xA1\x83\x38\x82\x47\x81\xB4\x24\x8B\xA1\x82\x3A\x82\x4F\x81\x86\x04\x83\xAA\xA8\xAA\x82\x05\x04\xBF\x7B\xAC\xAD\xAF\xAC\x02\x5A\xDE\xA2\xA3\xB4\xB7\x7F\x00\x82\x01\x04\x82\x01\xB5\xB5\xB6\xB7\xB7\x70\xF1\xB2\xA2\xB7\x04\xB7\xB9\xBB\x78\xF9\xB2\xA8\x06\xBA\xBE\xBF\xBF\xFF\x09\x81\x80\xC4\xC5\xC2\xC2\xC3\x0C\x83\xC7\xCB\xCC\xC7\xC3\x04\x82\x8F\x81\x91\xC0\x03\xCD\xC6\xCB\xCB\x98\x99\xDD\xAC\x0D\xBA\xCE\xCF\xB7\x0F\x8A\xDF\xDE\xBE\x05\xCF\xBF\x07\xA6\x98\xD0\x09\xD3\xD0\xBF\xC9\xD7\x90\xAC\xED\xD3\xD4\xDB\xB1\x08\xD9\xB5\xB3\xD2\x18\xD9\xDD\xB7\x08\xDE\xBD\xC1\xC2\xFF\x74\x08\xE3\xE1\xB7\x15\x46\xC7\xF9\xC6\x0A\xE7\xE5\xDE\x07\xA2\xCF\xED\xD3\x82\xEB\xE3\x0C\xCE\xD3\xF7\xBA",
			"\x09\xEA\xEF\xE9\x0D\xDD\xDE\xF0\xBC\x01\xF2\xF1\xBD\x0E\xE5\xE6\xFF\x7E\x09\xF2\xF7\xC3\x0F\xED\xC2\xD2\x96\xEE\xF5\xFB\xCB\x10\xF1\xF6\xED\xA2\x19\xFD\xAF\x11\xFE\xFA\x47\x64\x08\x80\x01\xBE\x55\x08\x81\xCB\x66\x08\x81\x81\x5B\x67\x0B\x80\x83\x7A\x6A\x04\x40\x0A\x04\x69\x0F\x81\x63\x15\x74\x70\x87\x86\x9F\x6C\x07\x85\x80\x2D\x1F\x8C\x85\x6D\x2E\x22\x86\x7B\x0B\x26\x99\x60\x0D\x8A\x9F\x71\x0C\x8B\x88\x98\x58\x4A\x84\x8C\x77\x73\x0F\x88\x8D\x5B\x74\x07\x8F\x73\x35\x3B\x8E\x5E\x0D\x3E\xB8\x8B\x57\x0D\x41\xA6\x78\x0D\x91\xCF\x79\x08\x90\x66\x3A\x0B\x97\x73\x0E\x4E\xB9\x5C\x0D\x94\x42\xB9\x5D\x0C\x95\xEE\x7E\x08\x95\x6F\x3F\x1B\x97\x60\x10\x5E\xB5\x71\x11\x98\xB4\x42\x14\x9B\x6C\x43\x27\x9E\x58\x11\x6A\xA3\x65\x11\x9B\xC1\x46\x10\x9F\x62\x47\x33\x9A\x64\x12\x76\x99\x69\x11\x9E\xC1\x4A\x1C\x9F\x65\x4B\x24\x9C\x13\x9F\x55\xB9\x5D\x10\xA1\x8D\x4E\x18\xA1\x59\x4F\x0B\xA4\x60\x14\x8E\x87\x61\x15\xA4\x7F\x52\x14\xA5\x59\x53\x17\xA4\x60\x15\x9A\xB9\x65\x14\x9C\x56\x1D\xAF\x5F\x15\xA2\x85\xA3\x6C\x16\xA5\xBA\x59\x15\xAA",
			"\x80\x5A\x1C\xAB\x73\x5B\x2F\xA7\x5C\x17\xB2\x84\x6D\x15\xAD\x72\x5E\x18\xAE\x58\x1B\x73\x86\xAB\xAF\xC0\x8C\x80\x1B\xAE\x70\x5E\x4E\xAE\x66\x21\x47\xB1\xB3\x86\x24\x4A\xBB\xB0\x57\x27\x4E\xB3\x5E\x4A\xD2\x8F\xBE\x66\x19\xC4\xAF\x5D\x49\xB5\xD6\x9D\xB5\x60\x4C\xDC\x81\xB3\x4D\xB8\x55\xAA\x19\xB6\x5B\x6B\x30\x96\x4C\xB9\xBF\xAD\x17\xB9\x6D\x39\x6C\xB6\xA8\x4F\xF2\x9E\xB6\xBF\x6C\x60\x3C\x50\x03\x7C\x04\x44\x08\x24\x08\xC0\x01\x55\x41\x62\x00\x04\xC6\xC0\x41\xFA\x80\x02\x61\xC1\x0D\x41\x47\xC1\x40\x0B\xCF\xCC\xC2\xC3\x0D\xD3\xC6\xC6\xC4\x18\xD5\xC9\xC4\xC5\x1C\xD7\xCA\xC7\xC7\x1D\xC3\xC0\xCA\xC7\x1D\xDB\xC4\xCB\xC9\x26\xE9\xC3\xCA\xCA\x25\xEB\xCE\xC9\xCB\x30\xE8\xCF\xC8\x00\x67\x71\xCC\xCB\xC9\x69\x41\x4B\x59\xCC\x55\x72\xC1\xCD\x5D\x36\xF3\xC2\xC4\x58\x01\x59\x51\x40",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
