/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTest_Lexer.h"

namespace featuretest
{
	bool FeatureTestTokenDeleter(vl::vint token)
	{
		switch((FeatureTestTokens)token)
		{
		case FeatureTestTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* FeatureTestTokenId(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"OPTIONAL",
			L"POSITIVE_OPTIONAL",
			L"NEGATIVE_OPTIONAL",
			L"ALTERNATIVE",
			L"PLUS",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenDisplayText(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"alternative",
			L"+",
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenRegex(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"alternative",
			L"/+",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	void FeatureTestLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 416; // 4732 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 160;
		static const vl::vint dataSolidRows = 1;
		static const vl::vint dataRows = 2;
		static const char* compressed[] = {
			"\x7C\x12\x00\x00\x98\x01\x00\x00\x39\x00\x01\x93\x01\x84\x81\x82\x08\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x8B\x14\x88\x83\x2F\x17\x84\xA1\x3A\x84\x85\x31\x8E\x82\x67\x20\x84\x89\x33\x94\x80\x36\x93\x04\xEE\x29\x84\x8F\x34\x94\x82\x38\x2F\x84\xB2\x32\x94\x83\x39\x9A\x82\x74\x38\x84\x96\x3B\x9C\x82\x02\x9F\x40\x81\xBF\x81\x85\x04\x83\x7F\xA3\xFF\x04\x06\xA8\xAC\xA5\xA4\xA5\x01\x04\x81\x04\x82\x0B\xA6\xA6\xAB\xAB\x58\xD9\x9A\xBB\xA6\xAF\x01\xAA\xAE\x60\xE1\xA2\xB6\xA8\x07\xAF\xB1\xB3\x5C\x89\x81\x88\xBC\xB5\xB6\xB7\xA3\x0C\xEB\xAF\xB3\xB4\xBD\xB8\xAD\x05\x04\xF8\x81\x9A\xB0\x04\xBE\xBB\xBF\x80\x81\xD9\xAC\x06\xB2\xC2\xC3\x87\x72\x86\xD9\xAE\x05\xC2\xC6\xC6\xC1\x0F\x0D\xFF\x7C\xB4\xC9\xBE\xC9\xC7\x98\xE3\x90\x17\xC9\xCD\xB9\x08\xCE\x9D\xDB\x87\x89\xC1\xD6\xC7\x80\xD2\xA5\xA9\xD6\xB4\x00\xD2\xD7\xC7\x0A\xAD\xAE\xE3\xB6\x01\xDA\xDA\xAB\x0B\xB5\xB6\xFF\x78\x09\xDA\xDC\xA5\x0C\xBD\xBE\xD8\xBA\x01\xE2\xE1\xB1\x0D\xC5\x8E\xDC\x09\xE6\xE2\xE1\x0E\xE6\xCD\xC7\x9E\x10\xE6\xAF\x0C\xEB\xE8\x61\x92\xA8\xD8",
			"\xE8\xA1\x13\xEA\xE3\x22\x5F\xDC\xE2\xC3\x12\xF3\xF0\xBA\x24\x66\xFA\xC5\x1A\xF7\xF2\xA6\x13\xED\xEE\xE7\x11\xFE\xD0\x14\xFA\xF7\x4E\xA9\x37\xF4\xBA\x13\xFD\xD3\x8A\xDB\x6A\x6C\x0A\x7F\xF8\x67\x5D\x08\x81\x9D\x6E\x08\x81\x81\x76\x6F\x0B\x80\x66\x30\x0F\x8E\x6D\x0C\x12\x8E\x62\x0D\x85\x80\x73\x08\x86\x61\x34\x1B\x8A\x55\x0D\x1E\x81\x66\x0D\x88\xB6\x77\x04\x8B\x5F\x38\x27\x8C\x83\x8A\x6C\x60\x15\x58\x00\x01\x10\x00\x21\x00\x00\x45\x42\x51\x50\x00\x03\x59\x8C\x41\x4A\x44\x58\x8E\x8E\x40\x84\x45\x53\x8D\x44\xBB\x85\x91\x90\x47\xBF\x8A\x91\x92\x4C\x86\x9E\x90\x92\x36\x90\x92\x97\x92\x4F\x94\x90\x55\x93\x53\x98\x94\x96\x54\x01\x54\x51\x40",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
