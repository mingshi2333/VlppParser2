/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:FeatureTest
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "FeatureTest_Lexer.h"

namespace featuretest
{
	bool FeatureTestTokenDeleter(vl::vint token)
	{
		switch((FeatureTestTokens)token)
		{
		case FeatureTestTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* FeatureTestTokenId(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"OPTIONAL",
			L"POSITIVE_OPTIONAL",
			L"NEGATIVE_OPTIONAL",
			L"PLUS",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenDisplayText(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"+",
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	const wchar_t* FeatureTestTokenRegex(FeatureTestTokens token)
	{
		static const wchar_t* results[] = {
			L"optional",
			L"positive_optional",
			L"negative_optional",
			L"/+",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < FeatureTestTokenCount ? results[index] : nullptr;
	}

	void FeatureTestLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 352; // 3658 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 96;
		static const vl::vint dataSolidRows = 1;
		static const vl::vint dataRows = 2;
		static const char* compressed[] = {
			"\x4A\x0E\x00\x00\x58\x01\x00\x00\x2E\x00\x01\x92\x01\x84\x81\x81\x08\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x8B\x14\x88\x83\x2F\x17\x84\xA1\x3A\x84\x85\x31\x8E\x82\x67\x20\x84\x89\x33\x94\x80\x36\x93\x04\xEE\x29\x84\x8F\x34\x94\x82\x38\x2F\x84\xB3\x32\x94\x84\x39\x9A\x82\x76\x38\x84\x85\x0B\x9D\x9D\x80\x9E\x01\x84\x04\x9F\x74\xA5\xA2\xA3\xA3\x48\xC5\x83\x04\x81\x04\x82\x01\xA1\x49\xD1\x92\xB3\xA4\xAD\xAB\xA8\x03\x50\xD6\x9A\xBB\xAC\xAE\xA3\x03\xAC\x5D\xE1\x93\xA8\x00\xB2\xB2\xB3\xB3\x68\xE9\x85\xA9\x81\x84\xB4\x00\xB7\x6E\xEA\xB2\xB3\xB4\xBA\xAC\x87\x80\x75\xF9\x89\xAB\x05\xB2\xBE\xA8\x06\x7D\xFA\xB0\xAA\x8D\xB1\xC2\xBF\xC3\x68\x8F\xB8\xA8\xCC\xC6\x06\xC2\xC6\x5A\x8F\x0F\xD0\xC4\xCD\xA8\x09\xC9\x95\x88\xC7\x8B\xC9\xCD\xBB\x80\xCE\x9D\xD3\x93\x18\xC1\xD2\xA8\x0A\xD2\xA5\xDB\x95\x08\xD9\xD7\x7E\x0A\xD6\xAD\xB1\xC9\xB7\x00\xDA\xD9\xA8\x0C\xB5\xF5\x99\x19\xDD\xCA\x0C\xDE\xDB\x46\x9B\x3F\xC0\xE4\xE1\xB0\x0F\xE1\xC4\x9D\x08\xE5\xE3\xBE\x0F\xE4\xDB\x1F\x4F\xC5\xF2\x80\xD4\xE6\xAD\x10\xD2\xD6\xFF\x62",
			"\x19\xED\xD7\x11\xEE\x61\xA4\x20\xE5\xD5\x13\xF2\xEC\x13\xE6\x9D\xE7\x09\xFC\xC0\x14\xF7\xCA\x29\x6F\xDC\xAA\x12\xF8\xC9\x8B\xEA\xDA\xF4\xAC\x15\xFC\xC5\x14\xFF\xFC\x00\xBA\x50\x0F\x53\x4F\x70\x00\x41\x41\x3F\x7E\x40\x00\x50\x00\x0B\x51\x52\x82\x0C\x8C\x82\x51\x82\x14\x8B\x80\x87\x85\x15\x91\x88\x86\x85\x19\x88\x8D\x87\x87\x1C\xA1\x8A\x84\x88\x23\xA2\x8B\x85\x89\x4D\x41\x4F\x51\x40",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
