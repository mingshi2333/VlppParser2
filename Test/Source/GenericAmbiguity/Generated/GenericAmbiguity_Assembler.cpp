/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GenericAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "GenericAmbiguity_Assembler.h"

namespace genericambiguity
{

/***********************************************************************
GenericAmbiguityAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> GenericAmbiguityAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((GenericAmbiguityClasses)type)
		{
		case GenericAmbiguityClasses::BinaryExpr:
			return new genericambiguity::BinaryExpr();
		case GenericAmbiguityClasses::CallExpr:
			return new genericambiguity::CallExpr();
		case GenericAmbiguityClasses::DecrementExpr:
			return new genericambiguity::DecrementExpr();
		case GenericAmbiguityClasses::Expr:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"genericambiguity::Expr\".", vl::glr::AstInsErrorType::UnknownType, type);
		case GenericAmbiguityClasses::ExprToResolve:
			return new genericambiguity::ExprToResolve();
		case GenericAmbiguityClasses::GenericExpr:
			return new genericambiguity::GenericExpr();
		case GenericAmbiguityClasses::Module:
			return new genericambiguity::Module();
		case GenericAmbiguityClasses::PostfixExpr:
			return new genericambiguity::PostfixExpr();
		case GenericAmbiguityClasses::RefExpr:
			return new genericambiguity::RefExpr();
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void GenericAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		switch((GenericAmbiguityFields)field)
		{
		case GenericAmbiguityFields::BinaryExpr_left:
			{
				auto typedObject = dynamic_cast<genericambiguity::BinaryExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::left\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->left) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::left\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::left\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->left = typedValue;
			}
			break;
		case GenericAmbiguityFields::BinaryExpr_right:
			{
				auto typedObject = dynamic_cast<genericambiguity::BinaryExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::right\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->right) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::right\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::right\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->right = typedValue;
			}
			break;
		case GenericAmbiguityFields::CallExpr_args:
			{
				auto typedObject = dynamic_cast<genericambiguity::CallExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::CallExpr::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::CallExpr::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->args.Add(typedValue);
			}
			break;
		case GenericAmbiguityFields::CallExpr_func:
			{
				auto typedObject = dynamic_cast<genericambiguity::CallExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::CallExpr::func\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->func) throw vl::glr::AstInsException(L"Field \"genericambiguity::CallExpr::func\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::CallExpr::func\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->func = typedValue;
			}
			break;
		case GenericAmbiguityFields::DecrementExpr_expr:
			{
				auto typedObject = dynamic_cast<genericambiguity::DecrementExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::DecrementExpr::expr\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->expr) throw vl::glr::AstInsException(L"Field \"genericambiguity::DecrementExpr::expr\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::DecrementExpr::expr\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->expr = typedValue;
			}
			break;
		case GenericAmbiguityFields::ExprToResolve_candidates:
			{
				auto typedObject = dynamic_cast<genericambiguity::ExprToResolve*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::ExprToResolve::candidates\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::ExprToResolve::candidates\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->candidates.Add(typedValue);
			}
			break;
		case GenericAmbiguityFields::GenericExpr_args:
			{
				auto typedObject = dynamic_cast<genericambiguity::GenericExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::GenericExpr::args\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::GenericExpr::args\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->args.Add(typedValue);
			}
			break;
		case GenericAmbiguityFields::Module_expr:
			{
				auto typedObject = dynamic_cast<genericambiguity::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::Module::expr\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->expr) throw vl::glr::AstInsException(L"Field \"genericambiguity::Module::expr\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::Module::expr\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->expr = typedValue;
			}
			break;
		case GenericAmbiguityFields::PostfixExpr_expr:
			{
				auto typedObject = dynamic_cast<genericambiguity::PostfixExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::PostfixExpr::expr\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->expr) throw vl::glr::AstInsException(L"Field \"genericambiguity::PostfixExpr::expr\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<genericambiguity::Expr>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"genericambiguity::PostfixExpr::expr\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->expr = typedValue;
			}
			break;
		default:
			if (auto cppFieldName = GenericAmbiguityCppFieldName((GenericAmbiguityFields)field))
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not an object."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void GenericAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		switch((GenericAmbiguityFields)field)
		{
		case GenericAmbiguityFields::GenericExpr_name:
			{
				auto typedObject = dynamic_cast<genericambiguity::GenericExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::GenericExpr::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"genericambiguity::GenericExpr::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		case GenericAmbiguityFields::RefExpr_name:
			{
				auto typedObject = dynamic_cast<genericambiguity::RefExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::RefExpr::name\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->name.value.Length() != 0) throw vl::glr::AstInsException(L"Field \"genericambiguity::RefExpr::name\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				AssignToken(typedObject->name, token);
			}
			break;
		default:
			if (auto cppFieldName = GenericAmbiguityCppFieldName((GenericAmbiguityFields)field))
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not a token."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void GenericAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		switch((GenericAmbiguityFields)field)
		{
		case GenericAmbiguityFields::BinaryExpr_op:
			{
				auto typedObject = dynamic_cast<genericambiguity::BinaryExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == genericambiguity::BinaryOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"genericambiguity::BinaryExpr::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (genericambiguity::BinaryOp)enumItem;
			}
			break;
		case GenericAmbiguityFields::PostfixExpr_op:
			{
				auto typedObject = dynamic_cast<genericambiguity::PostfixExpr*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"genericambiguity::PostfixExpr::op\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->op == genericambiguity::PostfixOp::UNDEFINED_ENUM_ITEM_VALUE) throw vl::glr::AstInsException(L"Field \"genericambiguity::PostfixExpr::op\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				typedObject->op = (genericambiguity::PostfixOp)enumItem;
			}
			break;
		default:
			if (auto cppFieldName = GenericAmbiguityCppFieldName((GenericAmbiguityFields)field))
				throw vl::glr::AstInsException(vl::WString::Unmanaged(L"Field \"") + vl::WString::Unmanaged(cppFieldName) + vl::WString::Unmanaged(L"\" is not an enum item."), vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
			else
				throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	const wchar_t* GenericAmbiguityTypeName(GenericAmbiguityClasses type)
	{
		const wchar_t* results[] = {
			L"BinaryExpr",
			L"CallExpr",
			L"DecrementExpr",
			L"Expr",
			L"ExprToResolve",
			L"GenericExpr",
			L"Module",
			L"PostfixExpr",
			L"RefExpr",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 9 ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityCppTypeName(GenericAmbiguityClasses type)
	{
		const wchar_t* results[] = {
			L"genericambiguity::BinaryExpr",
			L"genericambiguity::CallExpr",
			L"genericambiguity::DecrementExpr",
			L"genericambiguity::Expr",
			L"genericambiguity::ExprToResolve",
			L"genericambiguity::GenericExpr",
			L"genericambiguity::Module",
			L"genericambiguity::PostfixExpr",
			L"genericambiguity::RefExpr",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 9 ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityFieldName(GenericAmbiguityFields field)
	{
		switch(field)
		{
		case GenericAmbiguityFields::BinaryExpr_left:
			return L"BinaryExpr::left";
		case GenericAmbiguityFields::BinaryExpr_op:
			return L"BinaryExpr::op";
		case GenericAmbiguityFields::BinaryExpr_right:
			return L"BinaryExpr::right";
		case GenericAmbiguityFields::CallExpr_args:
			return L"CallExpr::args";
		case GenericAmbiguityFields::CallExpr_func:
			return L"CallExpr::func";
		case GenericAmbiguityFields::DecrementExpr_expr:
			return L"DecrementExpr::expr";
		case GenericAmbiguityFields::ExprToResolve_candidates:
			return L"ExprToResolve::candidates";
		case GenericAmbiguityFields::GenericExpr_args:
			return L"GenericExpr::args";
		case GenericAmbiguityFields::GenericExpr_name:
			return L"GenericExpr::name";
		case GenericAmbiguityFields::Module_expr:
			return L"Module::expr";
		case GenericAmbiguityFields::PostfixExpr_expr:
			return L"PostfixExpr::expr";
		case GenericAmbiguityFields::PostfixExpr_op:
			return L"PostfixExpr::op";
		case GenericAmbiguityFields::RefExpr_name:
			return L"RefExpr::name";
		default:
			return nullptr;
		}
	}

	const wchar_t* GenericAmbiguityCppFieldName(GenericAmbiguityFields field)
	{
		switch(field)
		{
		case GenericAmbiguityFields::BinaryExpr_left:
			return L"genericambiguity::BinaryExpr::left";
		case GenericAmbiguityFields::BinaryExpr_op:
			return L"genericambiguity::BinaryExpr::op";
		case GenericAmbiguityFields::BinaryExpr_right:
			return L"genericambiguity::BinaryExpr::right";
		case GenericAmbiguityFields::CallExpr_args:
			return L"genericambiguity::CallExpr::args";
		case GenericAmbiguityFields::CallExpr_func:
			return L"genericambiguity::CallExpr::func";
		case GenericAmbiguityFields::DecrementExpr_expr:
			return L"genericambiguity::DecrementExpr::expr";
		case GenericAmbiguityFields::ExprToResolve_candidates:
			return L"genericambiguity::ExprToResolve::candidates";
		case GenericAmbiguityFields::GenericExpr_args:
			return L"genericambiguity::GenericExpr::args";
		case GenericAmbiguityFields::GenericExpr_name:
			return L"genericambiguity::GenericExpr::name";
		case GenericAmbiguityFields::Module_expr:
			return L"genericambiguity::Module::expr";
		case GenericAmbiguityFields::PostfixExpr_expr:
			return L"genericambiguity::PostfixExpr::expr";
		case GenericAmbiguityFields::PostfixExpr_op:
			return L"genericambiguity::PostfixExpr::op";
		case GenericAmbiguityFields::RefExpr_name:
			return L"genericambiguity::RefExpr::name";
		default:
			return nullptr;
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> GenericAmbiguityAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		switch((GenericAmbiguityClasses)type)
		{
		case GenericAmbiguityClasses::BinaryExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::BinaryExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::CallExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::CallExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::DecrementExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::DecrementExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::Expr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::Expr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::ExprToResolve:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::ExprToResolve>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::GenericExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::GenericExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::PostfixExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::PostfixExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::RefExpr:
			{
				vl::Ptr<genericambiguity::ExprToResolve> ast = new genericambiguity::ExprToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<genericambiguity::RefExpr>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case GenericAmbiguityClasses::Module:
			throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}
}
