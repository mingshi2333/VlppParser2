/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GenericAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "GenericAmbiguity_Lexer.h"

namespace genericambiguity
{
	bool GenericAmbiguityTokenDeleter(vl::vint token)
	{
		switch((GenericAmbiguityTokens)token)
		{
		case GenericAmbiguityTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* GenericAmbiguityTokenId(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"OPEN_ROUND",
			L"CLOSE_ROUND",
			L"OPEN_ANGLE",
			L"CLOSE_ANGLE",
			L"COMMA",
			L"ID",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenDisplayText(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"(",
			L")",
			L"<",
			L">",
			L",",
			nullptr,
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenRegex(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"/(",
			L"/)",
			L"/<",
			L"/>",
			L",",
			L"[a-zA-Z_]/w*",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	void GenericAmbiguityLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 174; // 726 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 174;
		static const vl::vint dataSolidRows = 0;
		static const vl::vint dataRows = 1;
		static const char* compressed[] = {
			"\xD6\x02\x00\x00\xA6\x00\x00\x00\x0A\x00\x01\x8E\x01\x84\x81\x81\x06\x82\x09\x08\x84\x80\x81\x84\x84\x01\x83\x06\x84\xA0\x12\x84\x80\x15\x8A\x82\x29\x18\x84\x8C\x1B\x8C\x80\x18\x82\x39\x04\xBC\x02\x94\x86\x1D\x92\x82\x41\x04\x9A\x24\x8F\x2C\x94\x83\x30\x04\xFA\x04\x87\x03\x9D\x99\x80\x9A\x01\x81\x04\x82\x04\x85\x00\x83\x7F\x40\xFF\x43\x04\x84\x04\x82\x02\xA3\x48\x81\x81\xAB\xAC\xA5\xA6\xA7\xA7\x50\xD1\x92\xB3\xA4\xAD\xAA\xAB\xAB\x58\xD9\x9A\xBB\xAC\xAD\xAE\xAF\xAF\x56\x88\x3F\x8E\xA2\xB1\x81\xB2\x00\x67\xCB\x89\x81\x8B\xB0\x01\xB7\xB6\x60\xF1\x98\xA9\xB4\xB4\x83\xB2\xBA\x40\xEF\x8A\x8C\xB3\xB2\xBA\xA8\x7F\x03\x0E\x85\x85\x8A\x99\x80\x9F\x80\x43\x81\x85\xA1\x8E\x99\x83\xA2\xC6\x49\x80\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
