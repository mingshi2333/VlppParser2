/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GenericAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "GenericAmbiguity_Lexer.h"

namespace genericambiguity
{
	bool GenericAmbiguityTokenDeleter(vl::vint token)
	{
		switch((GenericAmbiguityTokens)token)
		{
		case GenericAmbiguityTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* GenericAmbiguityTokenId(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"OPEN_ROUND",
			L"CLOSE_ROUND",
			L"OPEN_ANGLE",
			L"CLOSE_ANGLE",
			L"COMMA",
			L"ADD",
			L"ID",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenDisplayText(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"(",
			L")",
			L"<",
			L">",
			L",",
			L"+",
			nullptr,
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenRegex(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"/(",
			L"/)",
			L"/<",
			L"/>",
			L",",
			L"/+",
			L"[a-zA-Z_]/w*",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	void GenericAmbiguityLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 184; // 838 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 184;
		static const vl::vint dataSolidRows = 0;
		static const vl::vint dataRows = 1;
		static const char* compressed[] = {
			"\x46\x03\x00\x00\xB0\x00\x00\x00\x0B\x00\x01\x8F\x01\x84\x81\x82\x06\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x88\x14\x88\x83\x14\x17\x84\xAB\x1A\x84\x84\x15\x8E\x82\x30\x04\xB9\x04\x8C\x1C\x90\x82\x1F\x27\x84\x81\x24\x8A\x2C\x83\x2E\x97\x04\xE1\x04\x9A\x34\x80\x05\x9B\x9B\x01\xB6\x81\x81\x04\x82\x00\x82\x03\x04\x85\x04\x9F\x74\xA7\x7F\x00\x82\x04\x04\x87\x0A\xAC\xA1\x81\xA3\xA7\x50\xD1\x92\xB3\xA4\xAD\xAA\xAB\xAB\x58\xD9\x9A\xBB\xAC\xAD\xAE\xAF\xAF\x60\xE1\xA2\xA3\xB4\xB5\xB2\xB2\xB0\x09\xCE\x92\xA9\xB0\x04\xB4\xB7\xA7\x0C\x81\xB1\xA0\x03\xBB\xBB\xB3\xBB\x5E\xEF\xAB\xAA\x81\x82\xBC\xA3\xBA\x0D\xF2\x83\xB8\xB8\xAE\x7F\x02\x80\x05\x89\xC0\x1C\x91\x86\x9D\x81\xA3\x01\xC9\x81\x82\xA1\x80\xA1\x81\xA5\x95\xCD\x80\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
