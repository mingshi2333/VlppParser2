/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GenericAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "GenericAmbiguity_Lexer.h"

namespace genericambiguity
{
	bool GenericAmbiguityTokenDeleter(vl::vint token)
	{
		switch((GenericAmbiguityTokens)token)
		{
		case GenericAmbiguityTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* GenericAmbiguityTokenId(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"OPEN_ROUND",
			L"CLOSE_ROUND",
			L"OPEN_ANGLE",
			L"CLOSE_ANGLE",
			L"COMMA",
			L"ADD",
			L"SUB",
			L"ID",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenDisplayText(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"(",
			L")",
			L"<",
			L">",
			L",",
			L"+",
			L"-",
			nullptr,
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	const wchar_t* GenericAmbiguityTokenRegex(GenericAmbiguityTokens token)
	{
		static const wchar_t* results[] = {
			L"/(",
			L"/)",
			L"/<",
			L"/>",
			L",",
			L"/+",
			L"-",
			L"[a-zA-Z_]/w*",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < GenericAmbiguityTokenCount ? results[index] : nullptr;
	}

	void GenericAmbiguityLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 193; // 958 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 193;
		static const vl::vint dataSolidRows = 0;
		static const vl::vint dataRows = 1;
		static const char* compressed[] = {
			"\xBE\x03\x00\x00\xB9\x00\x00\x00\x0C\x00\x01\x90\x01\x84\x81\x83\x06\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x88\x14\x88\x83\x14\x17\x84\xAB\x1A\x84\x84\x15\x8E\x82\x2D\x20\x84\x90\x14\x81\x1C\x82\x1E\x27\x84\xBE\x0A\x94\x81\x20\x82\x2D\x04\xDF\x31\x84\x81\x34\x82\x3C\x85\x01\x89\xB9\x98\x90\x01\x00\x82\x01\x04\x86\x04\x85\x04\x87\x00\x83\x7F\x48\xFF\x43\x04\x84\x04\x80\x04\xA7\x50\x81\x89\xB3\xA4\xAD\xAA\xAB\xAB\x58\xD9\x9A\xBB\xAC\xAD\xAE\xAF\xAF\x60\xE1\xA2\xA3\xB4\xB5\xB2\xB3\xB3\x68\xE9\xAA\xAB\xBC\xB5\xB5\xB4\x86\x52\xD6\xB0\xA0\x03\xBB\xBB\xA9\x05\x04\xF8\x81\x9A\xB0\x04\xBE\xB7\xBF\x64\xF6\xB2\xAD\x81\x82\xC0\xA4\xBE\x88\xF9\x87\xA0\xCD\xAE\x7F\x06\x80\x05\x91\xFD\x9F\x94\x83\xA5\x81\xA6\x01\xC4\x81\x82\xA1\x86\xA1\x81\xA7\x9D\xD1\x80\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
