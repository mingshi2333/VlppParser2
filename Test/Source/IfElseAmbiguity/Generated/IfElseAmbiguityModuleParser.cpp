/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseAmbiguityModuleParser.h"

namespace ifelseambiguity
{
	void IfElseAmbiguityModuleParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 1122; // 8945 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 98;
		static const vl::vint dataSolidRows = 4;
		static const vl::vint dataRows = 5;
		static const char* compressed[] = {
			"\xF1\x22\x00\x00\x5A\x04\x00\x00\x09\x00\x01\x82\x80\x05\x03\x82\x81\x82\x06\x89\x82\x84\x0A\x80\x81\x85\x08\x0A\x96\x0A\x93\x01\x01\x87\x7F\x8B\x18\x97\x8A\x80\x09\x89\x8F\x8D\x8E\x18\x9F\xA0\x9F\x72\x90\x91\x93\x8E\x27\x9E\x8A\x83\x94\x93\x97\x91\x8D\x1B\x95\x96\x8F\x9E\x96\x91\x9A\x94\x37\xAA\xB3\x96\x9B\x98\x9D\x9E\x9D\x06\xAC\xA9\x81\x99\x9C\xA3\x9E\xA3\x41\xB4\x89\x92\x96\x84\xA7\x80\xA1\x45\x9A\x91\xAD\x97\xA2\xA9\xAA\xAA\x49\xBC\x99\xBE\x9B\xA8\xA3\xA6\xA5\x5D\xC8\x9F\xBA\xA3\xB4\xAD\xB2\xAF\x02\xD0\x89\x82\x0A\x86\xA5\xB4\xB0\x67\xE2\xAF\xA4\xB3\xBE\xB1\xBA\xB4\x01\xEA\xA1\xB6\xAB\xB8\xAF\x81\x01\x6D\xD3\x83\xBC\xB1\xBC\xC3\xBA\xB9\x79\xF0\x87\xC6\xC9\xC4\xB9\xC6\xBB\x8F\xF8\x9C\x8A\xC1\xC8\xC7\xC8\xC7\x97\x90\xD9\xD2\xCA\xBD\xC2\xBF\xC5\x9F\x95\xCC\xDB\xC6\xCD\xCC\xD1\x8D\x0C\xCB\x8A\x88\x8D\xA2\xC2\x84\x03\x81\xD7\x83\xC1\xD4\xD3\xD3\x03\xD8\x7D\xB3\xFA\xCA\x88\x00\xDF\x80\x87\xAD\xB2\xCA\x8A\x0E\xDF\xD2\xD6\xE1\x09\x8B\x05\xE2\xD4\xDC\x07\xE5\xDA\xB4\xA6\xCC\xFB\xD8\xE1\xDF\xE2\xEB\xD5\x9E\xD4\xF8",
			"\xEC\xEA\xEF\xEB\x81\x0D\x4F\xD2\xF0\xEB\xEE\xED\xEC\xE3\xE7\xD3\xDF\xE8\xFD\xEC\xF6\xF3\xF6\xEA\xE9\xE4\xEB\xF1\x86\x06\xF0\xCA\xF3\x89\x8F\x17\xF8\xCB\xF3\xF0\x08\xFC\x5A\x60\x46\x6A\xF2\x7E\x78\x7E\x81\xFD\x47\x88\x7E\x04\x01\x9C\x6A\x81\x82\x98\x53\x0D\x81\x69\xF8\x54\x03\x87\x68\x08\x9A\x65\x07\x85\xB4\x52\x44\x80\x7C\xF9\x60\x89\x86\x83\x10\x9A\x63\x88\x85\x25\xA4\x86\x8B\x83\x2B\xA9\x88\x8A\x66\x17\x1C\x85\x7A\x7B\x34\xB1\x72\x88\x8B\x2A\x92\x68\x06\x8C\xF4\x61\x8F\x7B\x8F\x35\x80\x09\x04\x8F\xF2\x5A\x04\x93\x8D\x98\x5B\x07\x90\x90\x36\x8C\x9E\x8D\x90\x27\x98\x88\x8F\x8B\x39\x96\x6C\x07\x92\x50\x93\x92\x96\x8B\x5B\xAD\x8E\x95\x95\xA3\x5D\x08\x95\x93\x59\x9C\x91\x76\x96\x67\xA6\x93\x8D\x40\x1E\x23\x9F\x90\x99\x70\xAF\x92\x9D\x94\x69\x9F\x94\x97\x9D\xA3\x5F\x0E\x9B\x78\x20\x3B\x98\x9B\x46\x21\x3E\x9A\x99\x8F\x74\xAB\x93\x9F\x9F\x84\xB8\x72\x0A\xA0\x76\x9D\x90\x99\x9D\x8F\x86\xA5\xA2\x42\x2E\x0A\x4C\x5B\x87\x9E\x6C\x6E\x64\x4B\x97\xB0\x4E\x65\xA7\x9E\x8C\x70\xAB\x41\x53\x63\xA1\x40\x60\x57\x66\xA0\x02\x5B",
			"\xA2\xA1\xAF\xA7\x6A\xA5\x8A\x48\xA9\x5F\xAA\xAC\xA0\x76\xA6\xA0\x5C\xA2\xAD\xAC\xAE\xAD\xA9\x40\xAE\xBE\x86\x43\xAF\xAB\x98\xA0\x60\xB0\x74\xBA\xBD\xA0\x76\xAA\xC7\x89\xB2\xB0\xAF\xC1\x7D\x5D\xB0\x4B\x23\x6A\xA3\x6C\xB3\xD0\xBF\x59\xB6\x40\xB6\xAC\x43\xB4\xB5\x1D\x5F\xB0\xB8\x46\xE2\xA3\xBF\x3E\xAA\xB0\x69\xAA\xB3\xB2\xAF\x5B\xB1\x41\xB9\x18\x6A\xA3\xB0\x68\xE8\xAE\xBB\xAB\x54\xF0\xA0\xB7\x6E\xB2\x2C\x69\x6D\x5C\x4B\xFB\xBF\xA7\x56\xBF\x9B\xA3\x41\xC2\xAB\x00\xED\x53\xBC\x74\x07\xDA\xBD\x5D\xC3\x02\x69\xBE\x65\xA0\xCA\xB6\xAB\x46\xB5\xBB\x89\x44\xC0\xB7\x0A\x5B\xC1\x42\xAA\x1E\xC0\x0B\xC0\x41\xCF\x47\xB8\xB5\x42\x23\xD2\xC3\x42\xAD\x2A\xC2\x45\xBC\xCA\xCF\x72\xBA\x40\xC4\xF7\x89\x44\xCE\xAA\x34\xE3\xCD\x6C\xCC\x36\xEB\xB6\x0B\x73\xB6\x96\x8A\xB3\x09\x31\xD3\x4B\xB8\x0A\xCF\x5B\x4B\x86\xB2\x29\x0F\x73\xC8\xCD\x1B\x6A\x0E\xD2\x42\xCE\x4A\xBB\x0B\xD4\x09\x76\x7A\xB0\x0B\x58\xC6\x4B\x8E\xB2\x2D\x0F\x73\x0B\xBA\x23\xEB\xB5\xCC\x92\x9A\x75\xAB\xBA\xAD\xDD\x88\xAC\xCE\x41\x18\xC5\x8E\xDA\x41\x21\xED\xCE\xA6\xDA\x72",
			"\xD8\x66\xDC\x00\x7B\xDB\x43\xC9\xDB\x98\x57\xCD\xB9\x42\x3B\xFD\xA3\xA6\x7C\x7B\xC0\x8A\xB1\xC8\xAA\xA3\x7A\xAB\xCB\xCF\x8A\xBB\xDC\xE0\x9A\x4C\xE3\xCF\xE0\xBD\xB4\xC4\xE6\x64\x7B\xF8\xCC\x6F\xBA\x87\xE0\x84\xCE\xE2\xBD\x85\xE3\x41\xE3\xF8\x66\xEE\xCB\xE5\x6F\xEE\xA4\x71\xB1\x71\xAF\xE0\xDF\xE7\x02\xCA\xBA\x70\xEC\x87\x98\x60\x73\x40\xA4\xEE\xA5\xD5\xB4\x4E\xA3\x77\xEE\x41\x7D\xCA\x41\x78\xEE\xE3\x7F\xE7\xEA\x42\xC3\xFC\xEB\xBA\xD6\xB3\xF2\x70\xF7\xF2\xC9\x59\xCD\xAD\xEF\x1C\xF2\x78\xF7\xC7\x54\xC3\x7B\xBB\x80\xC0\xE5\x9A\x66\xF2\x02\x47\xF6\xE3\xDC\x4E\xA6\xF3\x41\xF1\x09\x4C\x88\xF3\x82\x96\x86\xFA\x43\xF6\x30\x52\x8B\x59\x8F\x42\xD1\xF6\x42\xFA\x02\x65\xDA\x43\xD2\xE1\x71\x4E\x87\x7A\x73\x21\xE9\x42\x22\x76\xAE\x43\x83\xCA\x09\x58\x33\xFD\x15\x7C\x5F\xE8\x61\x48\xFD\x0E\x87\x7D\x41\x72\x38\x7C\xEB\x6B\x5D\x8C\x6F\x78\x33\xAF\x41\x80\x00\x18\x82\x20\xFD\x1B\x2E\x82\xEA\x60\x43\x48\xB8\x61\x87\xA9\x6B\x56\x48\x0E\x9A\x35\x85\x1F\x96\x7E\x41\x6E\x7D\x56\x25\x6E\x81\x52\x0A\x39\x7F\x40\x34\x8E\x55\x2B\x77\x80",
			"\x4F\xB4\x20\x83\x0E\xEB\x52\x4D\x1F\x8E\x56\x32\x0A\x91\x63\xBA\x6D\x47\x7E\xF9\x36\x84\x80\x02\x29\x89\x40\x23\x8A\x21\x3E\x6D\x71\x48\x45\x90\x89\x40\x52\x82\x65\x75\x63\x6D\x89\x20\x5A\x4C\x18\x83\x25\x84\x81\x1B\x85\x57\x25\x0C\x52\x64\x28\x86\x6C\x8B\x2D\x8F\x6C\x1F\x9F\x1E\xC5\x73\x82\x71\xF8\x56\x26\x5A\x78\x95\x8F\x18\xA6\x81\x73\x2B\xB9\x2D\x6C\x80\x88\x36\x20\x96\x21\x64\x00\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ModuleParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"Do",
			L"Block",
			L"IfContent",
			L"Stat",
			L"Module",
		};
		return results[index];
	}

	const wchar_t* ModuleParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][Do] BEGIN ",
			L"[1][Do] END [ENDING]",
			L"[2][Do]< \"do\" \";\" @ >",
			L"[3][Do]< \"do\" @ \";\" >",
			L"[4][Block] BEGIN ",
			L"[5][Block] END [ENDING]",
			L"[6][Block]< \"{\" @ { Stat } \"}\" >",
			L"[7][Block]< \"{\" { Stat @ } \"}\" >",
			L"[8][Block]< \"{\" { Stat } \"}\" @ >",
			L"[9][IfContent] BEGIN ",
			L"[10][IfContent] END [ENDING]",
			L"[11][IfContent]< \"if\" \"cond\" \"then\" @ Stat [ \"else\" Stat ] >",
			L"[12][IfContent]< \"if\" \"cond\" \"then\" Stat @ [ \"else\" Stat ] >",
			L"[13][IfContent]< \"if\" \"cond\" \"then\" Stat [ \"else\" @ Stat ] >",
			L"[14][IfContent]< \"if\" \"cond\" \"then\" Stat [ \"else\" Stat @ ] >",
			L"[15][IfContent]< \"if\" \"cond\" @ \"then\" Stat [ \"else\" Stat ] >",
			L"[16][IfContent]< \"if\" @ \"cond\" \"then\" Stat [ \"else\" Stat ] >",
			L"[17][Stat] BEGIN ",
			L"[18][Stat] END [ENDING]",
			L"[19][Stat]< IfContent @ >",
			L"[20][Stat]<< !Block @ >>",
			L"[21][Stat]<< !Do @ >>",
			L"[22][Module] BEGIN ",
			L"[23][Module] END [ENDING]",
			L"[24][Module]< Stat @ >",
		};
		return results[index];
	}

	ModuleParser::ModuleParser()
		: vl::glr::ParserBase<IfElseAmbiguityTokens, ModuleParserStates, IfElseAmbiguityAstInsReceiver, ModuleParserStateTypes>(&IfElseAmbiguityTokenDeleter, &IfElseAmbiguityLexerData, &IfElseAmbiguityModuleParserData)
	{
	};

	vl::vint32_t ModuleParser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2)
	{
		if (class1 < 0 || class1 >= 8) throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, class1);
		if (class2 < 0 || class2 >= 8) throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, class2);
		static vl::vint32_t results[8][8] = {
			{0, 7, -1, -1, -1, 7, -1, 7, },
			{7, 1, -1, -1, -1, 7, -1, 7, },
			{-1, -1, 2, 2, 2, -1, -1, -1, },
			{-1, -1, 2, 3, 2, -1, -1, -1, },
			{-1, -1, 2, 2, 4, -1, -1, -1, },
			{7, 7, -1, -1, -1, 5, -1, 7, },
			{-1, -1, -1, -1, -1, -1, 6, -1, },
			{7, 7, -1, -1, -1, 7, -1, 7, },
		};
		return results[class1][class2];
	};

	vl::Ptr<ifelseambiguity::Module> ModuleParser::ParseModule(const vl::WString & input, vl::vint codeIndex)
	{
		 return Parse<ModuleParserStates::Module>(input, this, codeIndex);
	};
}
