/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseAmbiguityModuleParser.h"

namespace ifelseambiguity
{
	void IfElseAmbiguityModuleParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 1232; // 10641 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 208;
		static const vl::vint dataSolidRows = 4;
		static const vl::vint dataRows = 5;
		static const char* compressed[] = {
			"\x91\x29\x00\x00\xC8\x04\x00\x00\x09\x00\x01\x82\x80\x05\x03\x82\x81\x82\x06\x89\x82\x84\x0A\x80\x81\x85\x08\x0A\x96\x0A\x93\x01\x01\x87\x7F\x8B\x18\x97\x8A\x80\x09\x89\x8F\x8D\x8E\x18\x9F\xA0\x9F\x72\x90\x91\x93\x8E\x27\x9E\x8A\x83\x94\x93\x97\x91\x8D\x1B\x95\x96\x8F\x9E\x96\x91\x9A\x94\x37\xAA\xB3\x96\x9B\x98\x9D\x9E\x9D\x06\xAC\xA9\x81\x99\x9C\xA3\x9E\xA3\x41\xB4\x89\x92\x96\x84\xA7\x80\xA1\x45\x9A\x91\xAD\x97\xA2\xA9\xAA\xAA\x49\xBC\x99\xBE\x9B\xA8\xA3\xA6\xA5\x5D\xC8\x9F\xBA\xA3\xB4\xAD\xB2\xAF\x02\xD0\x89\x82\x0A\x86\xA5\xB4\xB0\x67\xE2\xAF\xA4\xB3\xBE\xB1\xBA\xB4\x01\xEA\xA1\xB6\xAB\xB8\xAF\x81\x01\x6D\xD3\x83\xBC\xB1\xBC\xC3\xBA\xB9\x79\xF0\x87\xC6\xC9\xC4\xB9\xC6\xBB\x8F\xF8\x9C\x8A\xC1\xC8\xC7\xC8\xC7\x97\x90\xD9\xD2\xCA\xBD\xC2\xBF\xC5\x9F\x95\xCC\xDB\xC6\xCD\xCC\xD1\x8D\x0C\xCB\x8A\x88\x8D\xA2\xC2\x84\x03\x81\xD7\x83\xC1\xD4\xD3\xD3\x03\xD8\x7D\xB3\xFA\xCA\x88\x00\xDF\x80\x87\xAD\xB2\xCA\x8A\x0E\xDF\xD2\xD6\xE1\x09\x8B\x05\xE2\xD4\xDC\x07\xE5\xDA\xB4\xA6\xCC\xFB\xD8\xE1\xDF\xE2\xEB\xD5\x9E\xD4\xF8",
			"\xEC\xEA\xEF\xEB\x81\x0D\x4F\xD2\xF0\xEB\xEE\xED\xEC\xE3\xE7\xD3\xDF\xE8\xFD\xEC\xF6\xF3\xF6\xEA\xE9\xE4\xEB\xF1\x86\x06\xF0\xCA\xF3\x89\x8F\x17\xF8\xCB\xF3\xF0\x08\xFC\x5A\x60\x46\x6A\xF2\x7E\x78\x7E\x81\xFD\x47\x88\x7E\x04\x01\x9C\x6A\x81\x82\x98\x53\x0D\x81\x69\xF8\x54\x03\x87\x68\x08\x9A\x65\x07\x85\xB4\x52\x44\x80\x7C\xF9\x60\x89\x86\x83\x10\x9A\x63\x88\x85\x25\xA4\x86\x8B\x83\x2B\xA9\x88\x8A\x66\x17\x1C\x85\x7A\x7B\x34\xB1\x72\x88\x8B\x2A\x92\x68\x06\x8C\xF4\x61\x8F\x7B\x8F\x35\x80\x09\x04\x8F\xF2\x5A\x04\x93\x8D\x98\x5B\x07\x90\x90\x36\x8C\x9E\x8D\x90\x27\x98\x88\x8F\x8B\x39\x96\x6C\x07\x92\x50\x93\x92\x96\x8B\x5B\xAD\x8E\x95\x95\xA3\x5D\x08\x95\x93\x59\x9C\x91\x76\x96\x67\xA6\x93\x8D\x40\x1E\x23\x9F\x90\x99\x70\xAF\x92\x9D\x94\x69\x9F\x94\x97\x9D\xA3\x5F\x0E\x9B\x78\x20\x3B\x98\x9B\x46\x21\x3E\x9A\x99\x8F\x74\xAB\x93\x9F\x9F\x84\xB8\x72\x0A\xA0\x76\x9D\x90\x99\x9D\x8F\x86\xA5\xA2\x42\x3A\x0A\x4C\x5B\x87\x9E\x70\x67\x54\x4B\x97\xB0\x4E\x65\x6A\x7D\x5C\xAE\xA5\x5F\x9D\x83\x4C\x6A\x67\xA5\x82\x40\x63\x55",
			"\xA0\x9E\x62\xA8\xA6\xA0\x6D\xA0\x6B\xAB\xA3\x8C\x79\xA9\x40\xA7\xA0\x67\xAC\x00\xAB\xBD\x52\xAC\x73\xB4\x83\x4E\x58\x73\x9A\xA1\xA3\x4B\xAE\xBD\x9F\xA3\x55\xB0\xA3\x8C\xB8\xAF\x54\xC8\x93\x5F\xAC\x74\xCE\x80\x03\xB0\x74\xC5\xAE\xA3\x4B\xB4\x2C\x55\xB3\x6F\xAE\xB9\xB6\xAA\x41\xB2\xB1\x8B\xB7\xB0\x87\xD9\xB3\xAB\xB6\xB9\x20\x7B\xAF\xB7\x6A\xD0\xA3\xB2\xB4\xBB\x1D\x7B\xA7\xB4\x4B\xE9\x80\xB3\x49\xBE\xD4\xBB\xB4\xBD\x46\xBB\xBC\xBC\x48\xB7\xDD\xAD\xB5\xAE\xAE\xAF\x71\xB9\x41\xB8\xD0\x51\xB7\x55\xC0\xF3\x9B\xA7\xB8\xAC\xC4\xBF\xB8\x45\x6F\x07\xD0\x7C\xC1\xC1\x20\x58\xC6\x40\xC1\x20\x5B\xCC\xC5\x46\x1E\xF5\xAC\x49\xC9\x02\x7B\xA7\xC8\x87\x28\xCF\xB2\x7D\xA0\x19\xD7\xBB\x46\xBB\xF2\x89\x43\xB7\xB5\xD3\xBB\xA3\xB4\xB9\x2E\xC1\x76\x40\xC3\xE0\xB5\xC6\x40\xBF\xD7\xBC\xB0\xC5\x42\x3C\xD6\xB6\xA6\xD0\x03\x77\x64\xC4\x00\x4E\xC6\x4B\xAD\xD4\x7F\x7C\x6C\xD2\x40\x54\xD9\xC6\x42\x0C\xCF\x57\xB6\x85\xC6\x49\xF3\x0F\x73\xAE\x12\x9A\xDA\x40\x0D\xCF\x5B\x4B\x84\xD8\x0A\x75\x0F\x71\xD2\x59\xE6\xD1\x42\x0D\x6F\xCA\x4E\x72\xDC\x06",
			"\x77\x05\xDD\x42\xF6\x78\xD3\x40\x0E\x7B\xC6\x4B\x8E\xDF\x02\x79\x0F\x73\x08\x5A\xC9\xD3\x7A\xA1\x31\x49\xA8\x66\xBD\x3D\x86\xA7\xB7\xBD\x88\x88\xDB\xD2\x7C\x92\x95\xE0\x8B\xB4\x02\xF8\x76\xA0\xE4\x05\xB8\x7C\xBD\xE7\x98\x46\xA9\xD2\xCA\x9E\xD7\xE3\xD2\xD5\x98\xCE\xED\xA0\xA4\x96\x7C\xB0\x81\xEB\xF2\x40\xDD\x8F\xAE\x47\xC6\x4A\xE1\xEA\xF2\x71\xD0\x00\xEA\x98\x79\xCA\x42\xEF\xA4\xDA\x66\xA0\x70\x03\x40\xFA\x66\xD1\xC3\xEC\xE0\x89\xE6\x83\xBD\xEA\x43\xEC\xCF\xFD\x8A\x73\x5A\x3D\xAD\xCF\xED\xF3\x96\xF4\xE0\x89\x78\xD8\xF2\x74\x71\xF8\x06\x5A\xF2\xC9\xE9\x3D\xBB\x7F\xD3\xA4\x09\x48\xF2\x40\xF5\x4E\x86\xA0\xFE\x40\x94\xD1\xF6\x43\xF5\xAB\xDE\xFE\x93\x80\x52\xFD\x87\xDD\xFF\xC9\x33\x79\xE4\x3D\x45\x6C\x00\xA0\x45\x6F\x06\x83\x20\xFE\x55\x6A\x7F\x20\x6B\x69\x81\x41\x53\x7D\x40\x3B\x5F\x7F\x81\x23\x7D\x7A\xF2\x31\x47\xFA\x1A\x73\x21\x0A\x82\x20\x7C\x18\x88\x4B\xEB\x06\x50\x85\x81\x05\x7A\x32\x86\x43\x70\x04\xF1\x4C\x40\xF2\x60\x3A\x80\x0D\x91\x4E\x91\x2E\x81\x49\xAF\x6B\x80\x00\x25\x8A\x57\x00\xF2\x37\x4A\x1A\xB1\x4E",
			"\x43\x37\x88\x82\x05\xBB\x80\x45\x36\x5B\x86\x7E\x03\x2A\x7F\xFD\x44\x8E\x48\xF6\x60\x42\x82\x00\x0A\x89\xFC\x2E\x71\x53\x1E\x7C\x7E\x84\x4C\x81\x4A\x9E\x3E\x82\x4E\x15\x82\x5A\x21\x57\x8F\x7D\x16\xF1\x40\x67\x1B\xA3\x3B\x48\x4F\x61\x8D\x40\x3B\x78\x7C\xF9\x08\x74\x8B\xE3\x33\x86\xCF\x03\x25\x81\x81\x2D\x81\x84\x4E\x45\x04\xA3\x12\x36\x86\x3B\xA3\x8A\x4E\x26\x1B\x8E\x65\x0F\x8E\x8F\x18\xB2\x4F\x04\x82\x83\x34\x10\xD8\x86\x91\xF1\x28\x07\x6A\x71\x4A\x48\x17\x8B\x92\x8D\x46\xB8\x3B\x05\x90\x92\x4E\x98\x13\x99\x93\xC5\x7D\x46\x05\x9D\x98\x3F\x16\xB7\x8E\x8A\x81\x1A\x80\x8F\x41\x51\x05\x22\xB4\x38\x8D\x83\x4B\x75\x5B\x84\x71\x66\x60\x75\x70\x24\x99\x4D\x72\x6B\xB6\x8A\x76\x76\x4A\x75\x5E\xB3\x74\x62\x97\xB5\x5F\x94\x17\xB0\x22\x98\xDD\x42\x34\x8D\x20\x27\x77\x46\x49\x62\x67\xA4\x70\x20\x64\x28\x30\x99\x47\x53\x51\x97\x81\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ModuleParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"Do",
			L"Block",
			L"IfContent",
			L"Stat",
			L"Module",
		};
		return results[index];
	}

	const wchar_t* ModuleParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][Do] BEGIN ",
			L"[1][Do] END [ENDING]",
			L"[2][Do]< \"do\" \";\" @ >",
			L"[3][Do]< \"do\" @ \";\" >",
			L"[4][Block] BEGIN ",
			L"[5][Block] END [ENDING]",
			L"[6][Block]< \"{\" @ { Stat } \"}\" >",
			L"[7][Block]< \"{\" { Stat @ } \"}\" >",
			L"[8][Block]< \"{\" { Stat } \"}\" @ >",
			L"[9][IfContent] BEGIN ",
			L"[10][IfContent] END [ENDING]",
			L"[11][IfContent]< \"if\" \"cond\" \"then\" @ Stat [ \"else\" Stat ] >",
			L"[12][IfContent]< \"if\" \"cond\" \"then\" Stat @ [ \"else\" Stat ] >",
			L"[13][IfContent]< \"if\" \"cond\" \"then\" Stat [ \"else\" @ Stat ] >",
			L"[14][IfContent]< \"if\" \"cond\" \"then\" Stat [ \"else\" Stat @ ] >",
			L"[15][IfContent]< \"if\" \"cond\" @ \"then\" Stat [ \"else\" Stat ] >",
			L"[16][IfContent]< \"if\" @ \"cond\" \"then\" Stat [ \"else\" Stat ] >",
			L"[17][Stat] BEGIN ",
			L"[18][Stat] END [ENDING]",
			L"[19][Stat]< IfContent @ >",
			L"[20][Stat]<< !Block @ >>",
			L"[21][Stat]<< !Do @ >>",
			L"[22][Module] BEGIN ",
			L"[23][Module] END [ENDING]",
			L"[24][Module]< Stat @ >",
		};
		return results[index];
	}

	const wchar_t* ModuleParserSwitchName(vl::vint index)
	{
		return nullptr;
	}

	ModuleParser::ModuleParser()
		: vl::glr::ParserBase<IfElseAmbiguityTokens, ModuleParserStates, IfElseAmbiguityAstInsReceiver>(&IfElseAmbiguityTokenDeleter, &IfElseAmbiguityLexerData, &IfElseAmbiguityModuleParserData)
	{
	};

	vl::vint32_t ModuleParser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const
	{
		static vl::vint32_t results[8][8] = {
			{0, 7, -1, -1, -1, 7, -1, 7, },
			{7, 1, -1, -1, -1, 7, -1, 7, },
			{-1, -1, 2, 2, 2, -1, -1, -1, },
			{-1, -1, 2, 3, 2, -1, -1, -1, },
			{-1, -1, 2, 2, 4, -1, -1, -1, },
			{7, 7, -1, -1, -1, 5, -1, 7, },
			{-1, -1, -1, -1, -1, -1, 6, -1, },
			{7, 7, -1, -1, -1, 7, -1, 7, },
		};
		return vl::glr::AssemblerFindCommonBaseClass(class1, class2, results);
	};

	vl::Ptr<ifelseambiguity::Module> ModuleParser::ParseModule(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<ifelseambiguity::Module, ModuleParserStates::Module>(input, this, codeIndex);
	};

	vl::Ptr<ifelseambiguity::Module> ModuleParser::ParseModule(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<ifelseambiguity::Module, ModuleParserStates::Module>(tokens, this, codeIndex);
	};
}
