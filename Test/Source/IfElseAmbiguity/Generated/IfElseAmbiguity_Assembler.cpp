/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseAmbiguity
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseAmbiguity_Assembler.h"

namespace ifelseambiguity
{

/***********************************************************************
IfElseAmbiguityAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> IfElseAmbiguityAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		switch((IfElseAmbiguityClasses)type)
		{
		case IfElseAmbiguityClasses::BlockStat:
			return new ifelseambiguity::BlockStat();
		case IfElseAmbiguityClasses::DoStat:
			return new ifelseambiguity::DoStat();
		case IfElseAmbiguityClasses::IfContent:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"ifelseambiguity::IfContent\".", vl::glr::AstInsErrorType::UnknownType, type);
		case IfElseAmbiguityClasses::IfContentCandidate:
			return new ifelseambiguity::IfContentCandidate();
		case IfElseAmbiguityClasses::IfContentToResolve:
			return new ifelseambiguity::IfContentToResolve();
		case IfElseAmbiguityClasses::IfStat:
			return new ifelseambiguity::IfStat();
		case IfElseAmbiguityClasses::Module:
			return new ifelseambiguity::Module();
		case IfElseAmbiguityClasses::Stat:
			throw vl::glr::AstInsException(L"Unable to create abstract class \"ifelseambiguity::Stat\".", vl::glr::AstInsErrorType::UnknownType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}

	void IfElseAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		switch((IfElseAmbiguityFields)field)
		{
		case IfElseAmbiguityFields::BlockStat_stats:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::BlockStat*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::BlockStat::stats\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<ifelseambiguity::Stat>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::BlockStat::stats\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->stats.Add(typedValue);
			}
			break;
		case IfElseAmbiguityFields::IfContentCandidate_elseBranch:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::IfContentCandidate*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::elseBranch\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->elseBranch) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::elseBranch\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<ifelseambiguity::Stat>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::elseBranch\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->elseBranch = typedValue;
			}
			break;
		case IfElseAmbiguityFields::IfContentCandidate_thenBranch:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::IfContentCandidate*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::thenBranch\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->thenBranch) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::thenBranch\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<ifelseambiguity::Stat>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::thenBranch\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->thenBranch = typedValue;
			}
			break;
		case IfElseAmbiguityFields::IfContentToResolve_candidates:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::IfContentToResolve*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentToResolve::candidates\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				auto typedValue = value.Cast<ifelseambiguity::IfContent>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentToResolve::candidates\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->candidates.Add(typedValue);
			}
			break;
		case IfElseAmbiguityFields::IfStat_content:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::IfStat*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfStat::content\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->content) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfStat::content\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<ifelseambiguity::IfContent>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfStat::content\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->content = typedValue;
			}
			break;
		case IfElseAmbiguityFields::Module_stat:
			{
				auto typedObject = dynamic_cast<ifelseambiguity::Module*>(object);
				if (!typedObject) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::Module::stat\" does not exist in the current object.", vl::glr::AstInsErrorType::FieldNotExistsInType, field);
				if (typedObject->stat) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::Module::stat\" has already been assigned.", vl::glr::AstInsErrorType::FieldReassigned, field);
				auto typedValue = value.Cast<ifelseambiguity::Stat>();
				if (!typedValue) throw vl::glr::AstInsException(L"Field \"ifelseambiguity::Module::stat\" cannot be assigned with an uncompatible value.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
				typedObject->stat = typedValue;
			}
			break;
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void IfElseAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token)
	{
		switch((IfElseAmbiguityFields)field)
		{
		case IfElseAmbiguityFields::BlockStat_stats:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::BlockStat::stats\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentCandidate_elseBranch:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::elseBranch\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentCandidate_thenBranch:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::thenBranch\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentToResolve_candidates:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentToResolve::candidates\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfStat_content:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfStat::content\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::Module_stat:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::Module::stat\" is not a token.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	void IfElseAmbiguityAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem)
	{
		switch((IfElseAmbiguityFields)field)
		{
		case IfElseAmbiguityFields::BlockStat_stats:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::BlockStat::stats\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentCandidate_elseBranch:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::elseBranch\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentCandidate_thenBranch:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentCandidate::thenBranch\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfContentToResolve_candidates:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfContentToResolve::candidates\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::IfStat_content:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::IfStat::content\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		case IfElseAmbiguityFields::Module_stat:
			throw vl::glr::AstInsException(L"Field \"ifelseambiguity::Module::stat\" is not an enum item.", vl::glr::AstInsErrorType::ObjectTypeMismatchedToField, field);
		default:
			throw vl::glr::AstInsException(L"The field id does not exist.", vl::glr::AstInsErrorType::UnknownField, field);
		}
	}

	const wchar_t* IfElseAmbiguityTypeName(IfElseAmbiguityClasses type)
	{
		const wchar_t* results[] = {
			L"BlockStat",
			L"DoStat",
			L"IfContent",
			L"IfContentCandidate",
			L"IfContentToResolve",
			L"IfStat",
			L"Module",
			L"Stat",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 8 ? results[index] : nullptr;
	}

	const wchar_t* IfElseAmbiguityFieldName(IfElseAmbiguityFields field)
	{
		switch(field)
		{
		case IfElseAmbiguityFields::BlockStat_stats:
			return L"BlockStat::stats";
		case IfElseAmbiguityFields::IfContentCandidate_elseBranch:
			return L"IfContentCandidate::elseBranch";
		case IfElseAmbiguityFields::IfContentCandidate_thenBranch:
			return L"IfContentCandidate::thenBranch";
		case IfElseAmbiguityFields::IfContentToResolve_candidates:
			return L"IfContentToResolve::candidates";
		case IfElseAmbiguityFields::IfStat_content:
			return L"IfStat::content";
		case IfElseAmbiguityFields::Module_stat:
			return L"Module::stat";
		default:
			return nullptr;
		}
	}

	vl::Ptr<vl::glr::ParsingAstBase> IfElseAmbiguityAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		switch((IfElseAmbiguityClasses)type)
		{
		case IfElseAmbiguityClasses::IfContentCandidate:
			{
				vl::Ptr<ifelseambiguity::IfContentToResolve> ast = new ifelseambiguity::IfContentToResolve();
				for (auto candidate : candidates)
				{
					auto typedAst = candidate.Cast<ifelseambiguity::IfContentCandidate>();
					if (!typedAst) throw vl::glr::AstInsException(L"The type of the ambiguous candidate is not compatible to the required type", vl::glr::AstInsErrorType::UnexpectedAmbiguousCandidate, type);
					ast->candidates.Add(typedAst);
				}
				return ast;
			}
		case IfElseAmbiguityClasses::BlockStat:
		case IfElseAmbiguityClasses::DoStat:
		case IfElseAmbiguityClasses::IfContent:
		case IfElseAmbiguityClasses::IfContentToResolve:
		case IfElseAmbiguityClasses::IfStat:
		case IfElseAmbiguityClasses::Module:
		case IfElseAmbiguityClasses::Stat:
			throw vl::glr::AstInsException(L"The type is not configured to allow ambiguity.", vl::glr::AstInsErrorType::UnsupportedAmbiguityType, type);
		default:
			throw vl::glr::AstInsException(L"The type id does not exist.", vl::glr::AstInsErrorType::UnknownType, type);
		}
	}
}
