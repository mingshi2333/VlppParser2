/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseAmbiguityOnStat
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseAmbiguityOnStatModuleParser.h"

namespace ifelseambiguityonstat
{
	void IfElseAmbiguityOnStatModuleParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 1232; // 10641 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 208;
		static const vl::vint dataSolidRows = 4;
		static const vl::vint dataRows = 5;
		static const char* compressed[] = {
			"\x91\x29\x00\x00\xC8\x04\x00\x00\x09\x00\x01\x82\x80\x05\x03\x82\x81\x82\x06\x89\x82\x84\x0A\x80\x81\x85\x08\x0A\x96\x0A\x93\x01\x01\x87\x7F\x8B\x18\x97\x8A\x80\x09\x89\x8F\x8D\x8E\x18\x9F\xA0\x9F\x72\x90\x91\x93\x8E\x27\x9E\x8A\x83\x94\x93\x97\x91\x8D\x1B\x95\x96\x8F\x9E\x96\x91\x9A\x94\x37\xAA\xB3\x96\x9B\x98\x9D\x9E\x9D\x06\xAC\xA9\x81\x99\x9C\xA3\x9E\xA3\x41\xB4\x89\x92\x96\x84\xA7\x80\xA1\x45\x9A\x91\xAD\x97\xA2\xA9\xAA\xAA\x49\xBC\x99\xBE\x9B\xA8\xA3\xA6\xA5\x5D\xC8\x9F\xBA\xA3\xB4\xAD\xB2\xAF\x02\xD0\x89\x82\x0A\x86\xA5\xB4\xB0\x67\xE2\xAF\xA4\xB3\xBE\xB1\xBA\xB4\x01\xEA\xA1\xB6\xAB\xB8\xAF\x81\x01\x6D\xD3\x83\xBC\xB1\xBC\xC3\xBA\xB9\x79\xF0\x87\xC6\xC9\xC4\xB9\xC6\xBB\x8F\xF8\x9C\x8A\xC1\xC8\xC7\xC8\xC7\x97\x90\xD9\xD2\xCA\xBD\xC2\xBF\xC5\x9F\x95\xCC\xDB\xC6\xCD\xCC\xD1\x8D\x0C\xCB\x8A\x88\x8D\xA2\xC2\x84\x03\x81\xD7\x83\xC1\xD4\xD3\xD3\x03\xD8\x7D\xB3\xFA\xCA\x88\x00\xDF\x80\x87\xAD\xB2\xCA\x8A\x0E\xDF\xD2\xD6\xE1\x09\x8B\x05\xE2\xD4\xDC\x07\xE5\xDA\xB4\xA6\xCC\xFB\xD8\xE1\xDF\xE2\xEB\xD5\x9E\xD4\xF8",
			"\xEC\xEA\xEF\xEB\x81\x0D\x4F\xD2\xF0\xEB\xEE\xED\xEC\xE3\xE7\xD3\xDF\xE8\xFD\xEC\xF6\xF3\xF6\xEA\xE9\xE4\xEB\xF1\x86\x06\xF0\xCA\xF3\x89\x8F\x17\xF8\xCB\xF3\xF0\x08\xFC\x5A\x60\x46\x6A\xF2\x7E\x78\x7E\x81\xFD\x47\x88\x7E\x04\x01\x9C\x6A\x81\x82\x98\x53\x0D\x81\x69\xF8\x54\x03\x87\x68\x08\x9A\x65\x07\x85\xB4\x52\x44\x80\x7C\xF9\x60\x89\x86\x83\x10\x9A\x63\x88\x85\x25\xA4\x86\x8B\x83\x2B\xA9\x88\x8A\x66\x17\x1C\x85\x7A\x7B\x34\xB1\x72\x88\x8B\x2A\x92\x68\x06\x8C\xF4\x61\x8F\x7B\x8F\x35\x80\x09\x04\x8F\xF2\x5A\x04\x93\x8D\x98\x5B\x07\x90\x90\x36\x8C\x9E\x8D\x90\x27\x98\x88\x8F\x8B\x39\x96\x6C\x07\x92\x50\x93\x92\x96\x8B\x5B\xAD\x8E\x95\x95\xA3\x5D\x08\x95\x93\x59\x9C\x91\x76\x96\x67\xA6\x93\x8D\x40\x1E\x23\x9F\x90\x99\x70\xAF\x92\x9D\x94\x69\x9F\x94\x97\x9D\xA3\x5F\x0E\x9B\x78\x20\x3B\x98\x9B\x46\x21\x3E\x9A\x99\x8F\x74\xAB\x93\x9F\x9F\x84\xB8\x72\x0A\xA0\x76\x9D\x90\x99\x9D\x8F\x86\xA5\xA2\x42\x3A\x0A\x4C\x5B\x87\x9E\x70\x67\x54\x4B\x97\xB0\x4E\x65\x6A\x7D\x5C\xAE\xA5\x5F\xA0\x9E\x62\xAB\x5A\x53\x65\xA0\x6B\xA9",
			"\xC1\x64\xA3\x54\xAB\xA3\x90\x7A\xA8\x73\xB0\x82\x4D\xA7\xA7\xAF\xA3\x47\xAE\x40\x6E\x4C\x7A\xA5\xA8\xBA\x96\xA9\xA9\xAE\x20\x7B\xAE\xA4\x4B\xB3\x90\x75\xAD\x40\xC6\xB2\xA4\xB1\x47\xCD\xBD\xA0\x77\xAF\xA6\xA3\x49\xB0\x4B\xCB\xB0\x48\xB3\xB3\x19\x4D\xBD\xB3\xB6\x9B\x81\xB8\xA4\x68\xD4\xAB\xA6\xB4\xB7\x18\x4D\xB3\x6F\xB5\xD8\x85\xB2\xB3\x55\xEC\xAD\xBD\xB4\x87\xAC\x55\xB0\x49\xB9\xB4\xA3\x45\xBE\xB9\xF7\xA8\xB7\x47\xBE\xF9\xBD\xB1\xBA\xBB\x09\x40\x60\xBE\xBF\xFF\x2A\xB3\x55\xB3\x06\xEE\xA3\xC0\xB4\xEF\xBD\x5C\xC3\xB0\x0F\xF3\xB3\xB8\x73\xC4\x45\xC3\x54\xBE\xCA\xA3\x49\xC5\xAC\xD0\x5F\xC1\xAC\x4B\x22\xF6\xA3\x55\xC9\x01\x52\xB3\x79\xA0\x20\xC0\x02\xB7\x46\x0A\xDA\xC9\x41\xB2\xD2\x89\xBD\xB1\xB2\x0D\xC3\x40\xC2\xCB\xAB\x51\xCA\xCE\x42\x39\xC2\x4C\xC6\xB4\x1C\xCD\xBC\xC5\xD0\x29\xFE\xC2\x40\xD2\x00\x37\x67\xC5\xD3\x4A\xC1\x4E\xD2\x41\x4C\xFD\x62\xCE\x41\x53\xED\xC9\x42\x0D\xCF\x52\xB2\x85\xCB\x4C\xE3\x7D\xB3\x86\x60\xFD\x8B\x46\x85\x65\xF2\x7C\xD1\xD6\x5A\xC3\x47\x0F\x73\x4C\xCE\x7D\xD9\x42\x38\x30\xDA\x42\x7D\x73",
			"\xC6\x49\x0E\xDD\x09\x7B\x89\xDE\x93\x23\x1A\xD1\xD8\x7E\x86\xB1\x49\xA0\x66\xD1\xA6\xDD\x8E\xB4\x2A\xC8\xA7\xD7\x40\xDF\x84\xE7\xE1\xA3\x90\x96\x69\xB0\xC7\xE3\x46\xA9\xE1\x81\xF8\x5C\xC8\xE6\xE4\x6A\xD1\xD2\x9C\xCC\xAF\x7C\x6A\xE0\xE7\x83\xB2\x7C\xC4\x80\xF2\x46\xAB\xCD\xE4\x88\xE2\xE7\xD3\xE9\x20\xAC\xDC\xB1\x8F\x36\xCA\x46\xEC\x00\x9F\xD8\x66\xA0\x70\x90\xFD\x85\xD2\xEE\xA6\xED\xE3\xE5\xA4\x3D\xBB\xEC\xE8\x88\x86\x8A\x78\xAA\x7C\x56\xC6\x4D\xB3\xEE\x83\xFE\xED\x8D\x78\xCF\xE0\x88\xC8\x00\xCD\x91\xFF\xCE\xF1\xF2\x7B\x7F\xD3\xA4\x09\x40\xF2\x43\xF2\x4E\x86\xA8\xF8\xAF\xC7\xD6\x6E\xF2\x41\xBD\xDA\x66\xA3\x80\xD2\xFD\x82\xDD\xFD\xC9\x4A\x4B\xF9\x9C\x86\x9F\xD8\xFC\x88\x78\x7F\x7F\x40\x6F\x7F\x2E\xDA\x4E\x4C\x6C\x02\x81\x4B\xFE\x5C\x7A\x21\xFB\x43\x23\x7B\x99\x7D\x45\x8C\x63\x7E\x70\x83\x0E\x82\x20\xD8\x6C\x79\xFB\x0E\x58\x4E\xDA\x19\x83\x20\xF1\x72\x32\xA1\x7E\x69\x81\x38\x4C\x41\x7B\xE0\x3A\x7E\x01\xC1\x46\x48\x14\x81\x48\x6D\x25\x80\x03\x07\xCB\x6B\x85\x38\x57\x4E\x85\x71\x5E\x41\x0C\x81\x8F\x81\x1A\xB2\x4D",
			"\x4D\x14\x89\x76\x41\x62\x76\x20\x02\x81\x4A\x52\x15\x8E\x4B\x02\xC4\x89\x7D\x0D\x95\x74\x83\xA3\x34\x7C\x08\xBE\x83\x3C\x3D\x78\x82\x4E\x24\x83\x22\xB4\x52\x87\x7C\x2A\xB8\x3C\x65\x31\x83\x3F\x90\x4F\x6C\x8B\x80\x15\x7A\x7E\x3D\x41\x73\x15\xE3\x3D\x85\x56\x43\x26\x7F\x03\x27\x86\x06\xF2\x35\x04\xD1\x64\x7E\x20\x30\x91\x8E\x17\x98\x37\x04\x3B\x89\x8A\x20\x08\x9A\x8C\xF8\x20\x49\x04\x3F\x82\x8B\x20\x3A\x93\x8B\x20\xCE\x4B\x04\xA0\x7D\x42\x49\x57\x89\x91\x17\x8B\x91\x48\x17\x0E\x92\x3E\x62\x51\x93\x25\xF3\x80\x45\x18\x1B\x96\x49\x56\x91\x85\x16\x82\x23\x82\x4E\x8E\x4C\x06\x86\x94\x73\x46\x63\x80\x65\xCC\x58\x5F\x6F\x5A\x6D\x72\x49\x32\x90\x25\x97\x46\x71\x96\x6D\x70\x74\x4A\x3A\x90\x62\xAD\x71\x67\x8A\x30\x3F\x95\x0C\xC1\x9D\x6D\x33\x9E\x26\x98\x19\x2C\x6B\xCB\x4C\x60\x26\xA6\x6A\x59\x5E\x28\x30\x99\x47\x49\x50\x96\x83\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ModuleParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"Do",
			L"Block",
			L"If",
			L"Stat",
			L"Module",
		};
		return results[index];
	}

	const wchar_t* ModuleParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][Do] BEGIN ",
			L"[1][Do] END [ENDING]",
			L"[2][Do]< \"do\" \";\" @ >",
			L"[3][Do]< \"do\" @ \";\" >",
			L"[4][Block] BEGIN ",
			L"[5][Block] END [ENDING]",
			L"[6][Block]< \"{\" @ { Stat } \"}\" >",
			L"[7][Block]< \"{\" { Stat @ } \"}\" >",
			L"[8][Block]< \"{\" { Stat } \"}\" @ >",
			L"[9][If] BEGIN ",
			L"[10][If] END [ENDING]",
			L"[11][If]< \"if\" \"cond\" \"then\" @ Stat [ \"else\" Stat ] >",
			L"[12][If]< \"if\" \"cond\" \"then\" Stat @ [ \"else\" Stat ] >",
			L"[13][If]< \"if\" \"cond\" \"then\" Stat [ \"else\" @ Stat ] >",
			L"[14][If]< \"if\" \"cond\" \"then\" Stat [ \"else\" Stat @ ] >",
			L"[15][If]< \"if\" \"cond\" @ \"then\" Stat [ \"else\" Stat ] >",
			L"[16][If]< \"if\" @ \"cond\" \"then\" Stat [ \"else\" Stat ] >",
			L"[17][Stat] BEGIN ",
			L"[18][Stat] END [ENDING]",
			L"[19][Stat]<< !Block @ >>",
			L"[20][Stat]<< !Do @ >>",
			L"[21][Stat]<< !If @ >>",
			L"[22][Module] BEGIN ",
			L"[23][Module] END [ENDING]",
			L"[24][Module]< Stat @ >",
		};
		return results[index];
	}

	const wchar_t* ModuleParserSwitchName(vl::vint index)
	{
		return nullptr;
	}

	ModuleParser::ModuleParser()
		: vl::glr::ParserBase<IfElseAmbiguityOnStatTokens, ModuleParserStates, IfElseAmbiguityOnStatAstInsReceiver>(&IfElseAmbiguityOnStatTokenDeleter, &IfElseAmbiguityOnStatLexerData, &IfElseAmbiguityOnStatModuleParserData)
	{
	};

	vl::vint32_t ModuleParser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const
	{
		static vl::vint32_t results[6][6] = {
			{0, 4, 4, -1, 4, 4, },
			{4, 1, 4, -1, 4, 4, },
			{4, 4, 2, -1, 4, 4, },
			{-1, -1, -1, 3, -1, -1, },
			{4, 4, 4, -1, 4, 4, },
			{4, 4, 4, -1, 4, 5, },
		};
		return vl::glr::AssemblerFindCommonBaseClass(class1, class2, results);
	};

	vl::Ptr<ifelseambiguityonstat::Module> ModuleParser::ParseModule(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<ifelseambiguityonstat::Module, ModuleParserStates::Module>(input, this, codeIndex);
	};

	vl::Ptr<ifelseambiguityonstat::Module> ModuleParser::ParseModule(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<ifelseambiguityonstat::Module, ModuleParserStates::Module>(tokens, this, codeIndex);
	};
}
