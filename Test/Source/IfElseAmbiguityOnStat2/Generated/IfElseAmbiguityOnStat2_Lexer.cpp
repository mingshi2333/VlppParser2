/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseAmbiguityOnStat2
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseAmbiguityOnStat2_Lexer.h"

namespace ifelseambiguityonstat2
{
	bool IfElseAmbiguityOnStat2TokenDeleter(vl::vint token)
	{
		switch((IfElseAmbiguityOnStat2Tokens)token)
		{
		case IfElseAmbiguityOnStat2Tokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* IfElseAmbiguityOnStat2TokenId(IfElseAmbiguityOnStat2Tokens token)
	{
		static const wchar_t* results[] = {
			L"OPEN_BRACE",
			L"CLOSE_BRACE",
			L"SEMICOLON",
			L"IF",
			L"CONDITION",
			L"THEN",
			L"ELSE",
			L"DO",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < IfElseAmbiguityOnStat2TokenCount ? results[index] : nullptr;
	}

	const wchar_t* IfElseAmbiguityOnStat2TokenDisplayText(IfElseAmbiguityOnStat2Tokens token)
	{
		static const wchar_t* results[] = {
			L"{",
			L"}",
			L";",
			L"if",
			L"cond",
			L"then",
			L"else",
			L"do",
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < IfElseAmbiguityOnStat2TokenCount ? results[index] : nullptr;
	}

	const wchar_t* IfElseAmbiguityOnStat2TokenRegex(IfElseAmbiguityOnStat2Tokens token)
	{
		static const wchar_t* results[] = {
			L"/{",
			L"/}",
			L";",
			L"if",
			L"cond",
			L"then",
			L"else",
			L"do",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < IfElseAmbiguityOnStat2TokenCount ? results[index] : nullptr;
	}

	void IfElseAmbiguityOnStat2LexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 251; // 1927 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 251;
		static const vl::vint dataSolidRows = 0;
		static const vl::vint dataRows = 1;
		static const char* compressed[] = {
			"\x87\x07\x00\x00\xF3\x00\x00\x00\x16\x00\x01\x93\x01\x84\x81\x82\x08\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x8B\x1C\x88\x83\x31\x17\x84\xA4\x3A\x84\x85\x31\x8E\x82\x66\x20\x84\x88\x33\x94\x81\x34\x93\x04\xEC\x29\x84\x8E\x34\x94\x83\x37\x2F\x84\xB3\x32\x94\x84\x39\x9A\x82\x7B\x38\x84\x9D\x3B\x9A\x85\x81\x84\x3F\xBE\x80\x03\x04\x85\x00\x82\x04\x04\x87\x04\x9F\x7C\xA5\xA4\xA6\x02\x4B\xCE\x92\xB3\xA6\x04\x81\x00\x82\x02\x51\x93\xBB\xAC\xAD\xAE\xAF\xAF\x60\xE1\xA2\xA3\xB4\xB5\xB2\xB3\xB3\x68\xE9\xAA\xAB\xBF\x7C\x85\x80\xB6\x70\xF1\xA5\xAB\x0A\xAA\xB9\xB8\x06\x75\xF6\xBA\xA7\xBF\x87\xB7\xBD\xBF\x66\x8E\x39\xA3\xBF\x04\x81\xC3\x80\x87\x80\x09\xC0\xCC\xC5\xC6\xC7\xC7\x62\x90\x03\xD0\xCD\xA9\x0B\xC8\xCA\x98\xE4\x87\x9E\xB9\xCD\xCD\xAF\xC4\xA0\x86\xD7\xDE\xCD\xC3\x80\xCE\xD2\xA8\xD3\x94\x03\xD4\xD5\x08\xD7\xD4\xB0\xB1\xF2\xD3\xD2\xBE\x06\x62\x1C\x00\x85\xBA\xC0\x07\xA9\x81\xAD\xA0\xC0\x80\x00\xA2\xE2\xA0\xA5\x80\xA2\xC1\xC3\xC3\xEA\xA1\x86\xE0\xE3\xE4\x04\xD0\x81\x86\xA1\x85\xA9\x80",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
