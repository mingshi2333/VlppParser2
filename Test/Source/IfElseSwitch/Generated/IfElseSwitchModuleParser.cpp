/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:IfElseSwitch
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "IfElseSwitchModuleParser.h"

namespace ifelseswitch
{
	void IfElseSwitchModuleParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 1754; // 15428 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 218;
		static const vl::vint dataSolidRows = 6;
		static const vl::vint dataRows = 7;
		static const char* compressed[] = {
			"\x44\x3C\x00\x00\xD2\x06\x00\x00\x09\x00\x01\x82\x80\x07\x03\x82\x81\x82\x06\x89\x82\x84\x0A\x80\x81\x84\x09\x0A\x98\x0A\x9C\x0A\x80\x12\x85\x40\x01\x09\xBF\x7B\x8C\x8B\x8E\x84\x00\x1D\x9D\x9F\x81\x9C\x8B\x90\x93\x7F\x26\xA4\xA9\x81\x9B\x92\x92\x85\x93\x28\xAF\xA7\x9F\x8F\x89\x8E\x8D\x99\x32\xAA\xB9\x8C\x9B\x9E\x97\x9A\x9D\x3F\xBC\x81\xBE\x96\x80\x99\x97\x92\x3D\xC8\x83\xAA\xA5\xA0\x9D\x84\x9B\x06\xD0\x83\x86\xA9\xA6\x8D\xAB\x98\x4B\xD6\x99\xB8\xAD\xA0\xA1\xAE\xA1\x5F\xC4\x93\xAE\xA1\xB4\xA7\xB0\xAF\x67\xE0\xA9\xA2\xB2\x84\xA9\x84\x01\x0A\xD2\xAD\xA4\xBB\xB6\xB3\xB8\xB4\x77\xEA\xB9\xAC\xB1\x86\xB5\xB2\xAD\x7F\xDC\x83\x83\x01\xBF\xAB\xA2\xC0\x75\x88\xFB\xB6\xBD\xBC\xBB\xC4\xC5\x8D\xF8\x91\xDA\xB3\xCC\xBC\x90\xC7\x95\x8C\xD7\xD2\xCB\xCC\xC9\xCE\xCB\x7E\x89\xC2\xCF\xC3\xD1\xCC\xC9\xCF\x9A\xA1\xE4\xDF\x8C\x87\xA6\x85\x02\x85\xDB\x9F\x86\x01\xD9\xC3\xC3\xD2\xA8\xA7\xC8\x91\xA6\xC5\xDE\xD8\x85\x08\x35\xC3\x8E\x8C\xDF\xDD\x84\x05\xC2\xAB\xFE\xD6\xDA\x83\x05\xE4\xD3\xB8\x8C\x0F\xF9\xD8\xDA\xD4\xE9\xDB\xD8\xCB\xE2\xD9",
			"\xE6\xE4\xE5\xEF\xED\x0A\x8D\x13\xF6\xE4\xEF\x8E\x07\xF1\x98\xE5\xDA\xE2\x8F\x00\xF4\xCE\xF2\xF0\xE9\xF1\xEF\xF2\xFD\xF8\xFB\xFB\x9E\xF3\xF9\xF6\xFB\xF8\xFC\xD0\xFE\xFF\x5C\x60\x06\x7B\xFD\x45\x81\x82\x67\x11\x04\x87\x82\x65\x10\x6E\x6F\x76\x72\x0F\x81\x43\x06\x82\x9A\x54\x04\x87\x69\xFA\x4B\x89\x68\x80\x1B\xBE\x7D\x86\x81\x9A\x55\x03\x76\x05\x17\x95\x7C\x84\x86\x27\xA6\x8E\x84\x8A\x2B\xAA\x80\x8B\x69\x17\x25\x8C\x76\x41\x12\x4E\x8E\x77\x8D\xE0\x49\x49\x06\x8C\x0A\x5A\x0C\x8D\x84\xEA\x40\x99\x87\x87\x1A\xAC\x8F\x88\x6E\x1B\x3F\x88\x8C\x84\x4B\x97\x7B\x7A\x93\x09\x54\x46\x8D\x8E\x4D\x81\x95\x97\x90\x46\x96\x6D\x06\x92\x54\x9D\x9C\x92\x97\x50\x97\x99\x8B\x8C\x60\x96\x95\x98\x96\x2E\x85\x99\x9A\x66\x1E\x1C\x9F\x96\x40\x1F\x2E\x91\x99\x99\x16\x53\x9F\x99\x40\x21\x32\x96\x9B\x9D\x7B\xB3\x9C\x9C\x9A\x64\xBF\x93\x9B\x93\x7D\x85\xA0\xA2\x42\x22\x3A\x97\xA2\x90\x83\x8C\xAD\x8B\x47\x23\x0A\xAD\xA2\x98\x8F\x8A\x44\x0A\xA4\x95\x8E\xA7\x93\x47\x25\x18\xAB\xA4\xA1\x8B\x94\xAF\xA6\xA6\x6A\x9F\x46\x0A\xA7\xA5\xA0\xA3\xA7\x99",
			"\xAB\xBC\x97\x08\xAA\x44\xB1\xA9\x96\xAC\x6B\xB3\xA6\xAD\xAD\xB8\x81\xA1\x40\x0A\xB0\xA7\x69\x09\xAF\xB9\x8A\x4A\x08\xB0\xBA\x86\xAD\xAA\x9F\xC8\x86\xB9\xA5\x95\x2B\x04\xBA\xAB\xB2\xAC\x90\xB2\xA0\x67\x2C\x0E\xB4\xA8\xAD\xC5\xA1\xA1\xB7\xA8\x55\xAD\x06\xB6\x41\x2E\x1F\xB5\x9B\x0B\xE2\x93\xBC\xB7\xB6\xA9\x97\xB7\xAD\xB1\x30\x25\xB9\xB2\xB6\xE6\xA9\xB2\xAA\x65\x58\x0A\x40\x5E\x9D\xD0\x74\x6B\x54\x4C\xF7\xB4\x42\x69\x6B\x81\x70\x40\xC2\x68\xFC\xBE\xB1\x63\xC0\xA4\x45\xCF\x5B\x55\x08\xD0\x72\xC3\x55\x0A\xC5\x77\xC0\xC4\x27\x4D\xC4\x75\xC4\x06\xD4\x76\xC4\x4C\x18\xC2\x4D\xBF\xBF\x14\xE4\x4B\xC4\xC7\x24\x5F\xC2\x42\x5C\xF9\xA1\xC1\x4B\xC8\x24\xDD\x46\xCA\xBF\x1D\xC1\x4F\xCA\xC6\x2A\xEE\xC5\x88\xCB\x2D\xDB\x48\xCD\xCE\x33\xF7\x6B\xCD\xCB\x33\xF3\xCF\xC3\xBE\x15\xF5\xCC\x47\xCC\x28\xD4\x71\x73\xC2\x5B\x7F\xC4\xCA\xD3\x1C\xFD\xCC\xC2\xD1\x1B\x41\xD3\xD4\xD1\x22\xD4\xDF\x3C\xD2\x57\x56\xDD\xD2\xD6\x52\xDB\x5E\xD7\xC4\x58\xE1\x4C\xD7\x56\xFA\x81\xC5\xD1\xD9\x36\xD9\xC0\x74\xD4\x31\xC0\x09\xD0\x4C\x69\xC4\xC7\x49\xDD\x09",
			"\xEB\xDA\xD9\xD6\x6C\xC7\xDE\xDB\xDB\x60\xF6\xB7\xD7\xDE\x2B\xC1\xE8\xBC\x75\x78\xCE\xC7\xDE\xE1\x06\x44\x6F\xD5\xDF\x3A\xCC\xE9\xC5\xDC\x8E\xE4\xD4\xE1\xDB\x06\x42\xD7\x4B\xCC\x95\xE0\xC0\xE7\x3F\x70\xDB\xE5\x89\xE2\x17\xE7\x4B\xD2\xDB\x30\x70\x6F\xE6\xEA\x97\xDC\x4C\xEA\xDD\x24\x6F\xE9\xDC\x49\xA7\xD3\xE6\xEA\xE0\x5B\x75\xEE\xC7\x55\xBA\xC1\x43\xDF\xED\x87\xF0\x4D\xEC\x00\x9D\xE4\x64\x8B\xDF\x30\x49\xDF\xDC\x74\xCA\xCA\x46\xC7\x47\xC3\xF0\x45\xF3\xBB\x27\x4D\xF8\xF2\xE8\xCB\xD7\x56\xF6\x41\xCF\xC0\x73\xE1\xC6\xD1\xE9\x8B\xF7\x60\xCF\xA1\x43\xFA\x40\x3C\x0B\xF9\xD1\xD8\x8D\xEA\xFE\xF3\x6B\xD3\x73\xC2\xED\x40\xD3\xC0\x03\xFE\xDC\xEF\xC9\x44\xEB\xCC\xBB\x43\x44\xEA\xC5\xC3\x6B\x7E\xF7\x09\x25\x7F\x00\xB9\x7E\x20\xC4\x23\x22\x00\x89\x29\x80\x81\x35\x7D\x81\xBE\x67\x83\x40\x48\x3A\x7E\xDC\x46\x24\x82\x06\x3D\x7E\x40\x18\x8E\x7E\x09\xBB\x71\x21\x16\x6B\x81\xFB\x07\x76\x62\xE7\x07\x73\x66\x26\x83\x86\x41\x29\x8A\x80\x0F\x81\x22\x3A\x09\x37\x7E\x06\xFE\x5D\x09\xE9\x16\x61\x4E\x7F\x6E\x0B\x74\x49\x6E\x47\xBF\x4F\x0B",
			"\x3A\xF5\x6D\x4F\xDF\x50\x03\x3B\x8F\x09\x4F\x6F\x51\x13\x3A\x0C\xCB\x72\x0A\x1B\x8A\x21\x41\x7F\x73\x08\x10\x8A\x27\x3D\xBF\x54\x0A\x89\xE1\x2B\x79\x15\x58\x89\x21\x01\x7F\x6E\x0A\xF1\x6A\x22\x88\x57\x7C\x33\xFB\x49\x57\x6F\x57\x13\x39\x0C\x4B\x75\x7E\xF2\x05\x5D\x26\xE5\x76\x33\xD9\x55\x45\x59\xA4\x7F\x72\x5A\xF4\x76\x81\x99\x59\x57\x59\x42\x56\x64\x74\x6E\x84\x53\x1C\xE8\x5A\x32\xD2\x40\x91\x3D\xC5\x55\x7D\x1B\x88\x9A\x21\xFA\x64\x71\x7C\x9C\x3C\x8C\x1E\x85\x54\x75\x18\x40\x49\x7B\x33\x7B\x7C\xA1\x75\x79\x93\x46\x84\x55\x58\xC3\x6B\x91\x19\x9E\x99\x21\x19\x80\x07\x90\x91\x84\x50\x0B\x8E\x84\x51\x50\x8A\x26\x94\x90\x9E\x32\x24\xE7\x5C\x4E\x53\x96\x94\x8E\x7A\x9F\x82\x41\x55\x89\x72\x55\xB9\x91\x20\xA6\x82\x96\x2C\x84\x5E\x8A\x15\xA5\x4A\x3C\x04\x83\x82\x41\x77\x71\x90\x20\x53\x41\x78\x7D\x90\x83\x29\x9F\x94\x50\x0B\x4C\x6D\x4A\xC5\x83\x23\xCC\x52\x97\x97\x3D\xAE\x80\x00\x33\x67\x7A\xC4\x65\x4D\x41\x71\x82\x22\x9A\xC2\x96\x31\xB1\x5D\x9A\x97\x32\x4F\x9D\x97\x09\x2B\x97\x0B\xD4\x95\x82\x68\x93\x94\x3C\x30\x86",
			"\x20\x2A\xC3\x90\x49\x1D\x49\x98\x48\x63\x86\x9A\x40\x79\x93\x20\x76\x89\x5F\x23\xA6\x93\x66\x94\x70\x95\x4B\x1A\x4C\xA3\x20\x04\xAC\x97\x25\x84\x52\x88\x81\x89\x5D\x87\x16\xA0\x00\x32\x97\x84\x9F\x79\x58\x5C\x50\xBC\x93\x81\x47\x84\x9B\x5C\x90\x8D\x3B\xA4\xE7\x9F\x95\xA1\x79\x46\x9E\xCF\x2D\x3D\x9E\xB8\x80\x4B\x19\x99\xA4\x3D\x2D\x7F\x9E\x20\x2F\xA6\x22\x41\x85\x5F\x22\x79\xA0\x9A\x21\x9D\x57\x98\x9D\x2A\xA9\xA6\xF2\x53\xA0\x48\xAF\x57\xA5\x99\x33\xA6\xA8\x83\x19\x9B\x83\x28\xB4\x7B\x3D\xE9\x30\x8A\x8E\x87\xAE\x20\x1B\xBA\x99\x1C\x9F\xA9\x21\xAA\x83\x25\xA8\x7C\x53\x96\xBC\x64\x9A\x21\x9D\x8D\x9D\x4A\xC3\x4D\xA7\x58\x82\x26\x9A\x7D\x91\xAD\x50\xCD\x42\xA8\x9F\x41\xA9\xA3\xB6\x85\xA7\xAD\x60\xB2\x66\x42\x5E\x5A\xAC\xCD\x3C\x52\xAE\x01\x36\xAE\x44\xB1\xA5\x4B\x70\x40\xB5\x50\x69\xB9\xA1\x40\x83\x2F\x9C\x6F\x80\x4D\x5D\x7D\xA5\xA5\x42\x62\x93\x20\xC1\x87\xA3\xAB\x92\xB5\x4B\x4E\x94\xB1\xAC\xCC\x81\x58\x48\x0E\xBD\x83\x55\xE5\x4B\x8D\xC3\xA4\x3C\xAF\xE6\x81\x21\x68\x83\xBE\xB1\x2A\x73\x02\xA5\xE4\x26\xB1\x6A\x80",
			"\x08\xA3\x81\x3E\x9C\xB0\x65\x55\x06\xBB\x00\x07\x88\x83\x37\xB5\xB5\x65\x56\x07\x6E\x8B\xA2\xB4\xDC\xBC\x4F\x06\xA4\x95\x48\xB9\x07\xB4\xB8\x81\x26\xAC\x91\x5D\xAA\xA6\x0E\x30\xB9\x3D\xD2\xB3\xB5\xB9\x79\x83\xB4\x9F\x69\x7A\xA8\x3E\x72\x02\xA5\x15\xA3\x22\x4D\xC6\xB2\x43\xE9\x3F\x03\xB7\x38\x86\x23\x78\xC0\xBC\x4E\x20\x3B\xB5\x4E\x6E\xBA\xB9\xB2\x41\x0F\x9A\xF2\x34\x01\xB9\x03\x30\xBF\x5D\xF2\xB0\x00\xCB\xBF\xA1\x21\x45\x18\xBF\x71\xAA\xAA\xBE\xD6\x9D\xB0\x48\x48\x15\xBD\x7A\x39\x02\xC1\x80\x0C\xAA\x20\x2C\xA4\xBD\xA1\x4C\x0B\xB7\x48\x64\x8A\x96\x1C\x79\x7A\x86\xF8\x72\x37\x3B\xA4\x27\x7C\x27\x79\x78\x88\xFA\xA2\x36\xCD\x58\x7B\xB6\xFF\xA8\xC7\x20\xDA\xA7\xB1\x14\xEE\x6C\x7D\x0F\xB9\x61\x3A\xA5\x23\xC6\x8E\x35\x7C\x26\x37\xDF\x21\x8E\x8D\xCE\x5E\xA8\x40\x00\x6E\x21\x8C\x35\xF6\x4C\x93\x26\x22\xE7\x27\x7E\xCA\x77\x7C\x4D\x7B\x92\x24\x26\xDD\x24\x74\x1A\xD3\x6C",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ModuleParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"Do",
			L"Block",
			L"IfTail",
			L"If",
			L"OtherStat",
			L"Stat",
			L"Module",
		};
		return results[index];
	}

	const wchar_t* ModuleParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][Do] BEGIN ",
			L"[1][Do] END [ENDING]",
			L"[2][Do]< \"do\" \";\" @ >",
			L"[3][Do]< \"do\" @ \";\" >",
			L"[4][Block] BEGIN ",
			L"[5][Block] END [ENDING]",
			L"[6][Block]< \"{\" @ { Stat } \"}\" >",
			L"[7][Block]< \"{\" { Stat @ } \"}\" >",
			L"[8][Block]< \"{\" { Stat } \"}\" @ >",
			L"[9][IfTail] BEGIN ",
			L"[10][IfTail] END [ENDING]",
			L"[11][IfTail]!(!0;If @) \"else\" Stat",
			L"[12][IfTail]!(!0;If) \"else\" @ Stat",
			L"[13][IfTail]!(!0;If) \"else\" Stat @",
			L"[14][IfTail]( ([0]? If @) )",
			L"[15][IfTail]OtherStat ( \"else\" @ Stat | ( ([0]? ) ) )",
			L"[16][IfTail]OtherStat ( \"else\" Stat @ | ( ([0]? ) ) )",
			L"[17][IfTail]OtherStat @ ( \"else\" Stat | ( ([0]? ) ) )",
			L"[18][If] BEGIN ",
			L"[19][If] END [ENDING]",
			L"[20][If]< \"if\" \"cond\" \"then\" @ IfTail >",
			L"[21][If]< \"if\" \"cond\" \"then\" IfTail @ >",
			L"[22][If]< \"if\" \"cond\" @ \"then\" IfTail >",
			L"[23][If]< \"if\" @ \"cond\" \"then\" IfTail >",
			L"[24][OtherStat] BEGIN ",
			L"[25][OtherStat] END [ENDING]",
			L"[26][OtherStat]<< !Block @ >>",
			L"[27][OtherStat]<< !Do @ >>",
			L"[28][Stat] BEGIN ",
			L"[29][Stat] END [ENDING]",
			L"[30][Stat]<< !(0;!If @) >>",
			L"[31][Stat]<< !OtherStat @ >>",
			L"[32][Module] BEGIN ",
			L"[33][Module] END [ENDING]",
			L"[34][Module]< Stat @ >",
		};
		return results[index];
	}

	const wchar_t* ModuleParserSwitchName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"allow_half_if",
		};
		return results[index];
	}

	ModuleParser::ModuleParser()
		: vl::glr::ParserBase<IfElseSwitchTokens, ModuleParserStates, IfElseSwitchAstInsReceiver>(&IfElseSwitchTokenDeleter, &IfElseSwitchLexerData, &IfElseSwitchModuleParserData)
	{
	};

	vl::vint32_t ModuleParser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const
	{
		return -1;
	};

	vl::Ptr<ifelseswitch::Module> ModuleParser::ParseModule(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<ifelseswitch::Module, ModuleParserStates::Module>(input, this, codeIndex);
	};

	vl::Ptr<ifelseswitch::Module> ModuleParser::ParseModule(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<ifelseswitch::Module, ModuleParserStates::Module>(tokens, this, codeIndex);
	};
}
