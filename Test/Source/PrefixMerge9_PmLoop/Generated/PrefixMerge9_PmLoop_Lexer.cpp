/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:PrefixMerge9_PmLoop
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "PrefixMerge9_PmLoop_Lexer.h"

namespace prefixmerge9_pmloop
{
	bool PrefixMerge9_PmLoopTokenDeleter(vl::vint token)
	{
		switch((PrefixMerge9_PmLoopTokens)token)
		{
		case PrefixMerge9_PmLoopTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* PrefixMerge9_PmLoopTokenId(PrefixMerge9_PmLoopTokens token)
	{
		static const wchar_t* results[] = {
			L"CLASS",
			L"INT",
			L"COMMA",
			L"DOT",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixMerge9_PmLoopTokenCount ? results[index] : nullptr;
	}

	const wchar_t* PrefixMerge9_PmLoopTokenDisplayText(PrefixMerge9_PmLoopTokens token)
	{
		static const wchar_t* results[] = {
			L"class",
			L"int",
			L",",
			L".",
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixMerge9_PmLoopTokenCount ? results[index] : nullptr;
	}

	const wchar_t* PrefixMerge9_PmLoopTokenRegex(PrefixMerge9_PmLoopTokens token)
	{
		static const wchar_t* results[] = {
			L"class",
			L"int",
			L",",
			L".",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixMerge9_PmLoopTokenCount ? results[index] : nullptr;
	}

	void PrefixMerge9_PmLoopLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 187; // 906 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 187;
		static const vl::vint dataSolidRows = 0;
		static const vl::vint dataRows = 1;
		static const char* compressed[] = {
			"\x8A\x03\x00\x00\xB3\x00\x00\x00\x0D\x00\x01\x8E\x01\x84\x81\x80\x81\x80\x09\x04\x89\x81\x8A\x04\x81\x86\x83\x04\x87\x80\x00\x14\x84\x89\x80\x16\x04\x98\x81\x8E\x14\x84\x8D\x81\x30\x04\xA0\x81\x83\x34\x84\x91\x81\x34\x04\xA8\x81\x8C\x34\x84\x95\x80\x37\x04\xB0\x81\x93\x34\x84\x99\x80\x3A\x04\xB8\x81\x85\x04\x84\x9F\x9D\x9E\x04\x83\x04\x84\x04\x87\x7E\xA3\x7F\x01\x04\x82\x05\xA7\xA5\xA6\xA7\xA7\x50\xD1\x92\xB3\xA7\xA6\x00\xA6\xAA\x58\xD9\x9A\xAD\xA7\x07\xAB\xAD\xAF\x60\xE1\xA2\xA3\xBF\xA8\x04\x82\xB3\x01\xE8\x80\x0A\xB4\xB5\xB4\xB3\x85\x00\x6E\xB2\xB3\xBD\xA7\x85\xB9\xA3\x6A\xF9\xA7\xBE\xA4\xBD\xBD\xBF\x05\x7C\xFE\x82\xC3\xCF\xAC\x05\xC0\xC2\x7D\xB8\x15\x12\x85\x86\x9C\x00\xC7\x4B\x81\x82\xA1\x84\xA7\x9E\xCA\x00\x95\x8F\xC4\x89\xA7\xCD\x80",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
