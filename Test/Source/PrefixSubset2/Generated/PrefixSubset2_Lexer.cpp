/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:PrefixSubset2
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#include "PrefixSubset2_Lexer.h"

namespace prefixsubset2
{
	bool PrefixSubset2TokenDeleter(vl::vint token)
	{
		switch((PrefixSubset2Tokens)token)
		{
		case PrefixSubset2Tokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* PrefixSubset2TokenId(PrefixSubset2Tokens token)
	{
		static const wchar_t* results[] = {
			L"OPEN_ROUND",
			L"CLOSE_ROUND",
			L"COMMA",
			L"DOT",
			L"CONST",
			L"ASTERISK",
			L"ID",
			L"SPACE",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixSubset2TokenCount ? results[index] : nullptr;
	}

	const wchar_t* PrefixSubset2TokenDisplayText(PrefixSubset2Tokens token)
	{
		static const wchar_t* results[] = {
			L"(",
			L")",
			L",",
			L".",
			L"const",
			L"*",
			nullptr,
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixSubset2TokenCount ? results[index] : nullptr;
	}

	const wchar_t* PrefixSubset2TokenRegex(PrefixSubset2Tokens token)
	{
		static const wchar_t* results[] = {
			L"/(",
			L"/)",
			L",",
			L".",
			L"const",
			L"/*",
			L"[a-zA-Z_]/w*",
			L"/s+",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < PrefixSubset2TokenCount ? results[index] : nullptr;
	}

	void PrefixSubset2LexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 286; // 1570 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 30;
		static const vl::vint dataSolidRows = 1;
		static const vl::vint dataRows = 2;
		static const char* compressed[] = {
			"\x22\x06\x00\x00\x16\x01\x00\x00\x0F\x00\x01\x96\x01\x84\x81\x81\x0A\x82\x09\x08\x84\x8A\x0B\x84\x81\x06\x87\x04\xA0\x11\x84\x88\x14\x88\x83\x14\x17\x84\xAA\x1A\x84\x84\x15\x8E\x82\x2E\x20\x84\x90\x14\x81\x1C\x83\x20\x04\xDA\x04\x9F\x2B\x94\x81\x30\x82\x62\x04\xA3\x32\x94\x84\x30\x83\x36\x04\xEE\x39\x84\x8F\x34\x9C\x82\x38\x04\xF2\x04\x93\x33\xA4\x80\x3A\xA3\x04\xF5\x04\x9A\x34\x80\x05\xA7\xA7\x01\xCE\x81\x81\x04\x82\x00\x82\x03\x04\x83\x04\x84\x04\x87\x7E\xAF\x7F\x07\x04\xA1\xA1\x83\xB0\x01\x02\xB1\x68\xE4\xA9\xA0\x05\xB5\xB5\xAF\xAF\x70\xF1\xB2\xB3\xB4\xBD\xBA\xBB\xBB\x78\xF9\xBA\xBB\xBC\xBD\xBE\xBF\xBF\x80\x81\xC2\xC3\xC4\xC5\xC2\xC3\xC3\x7C\x8C\x81\x8A\xC0\x04\xC6\xC7\x86\x8B\x8A\x91\xD3\xCD\xC0\xC8\x00\xC4\x98\x99\xDA\xD6\xBF\xC4\xC9\xCF\xCA\x9E\x96\xDF\xCC\xC0\xBB\x04\x82\xD3\x01\xA8\xC0\x0A\xDB\xCD\xD6\xD7\xBA\xA3\xA2\xD6\xCC\x02\xD9\xD0\xCB\xD7\x71\xB1\xF6\xC0\xDC\xDA\xDD\xDF\xB7\x5E\xAA\xC2\xE7\xD0\xE0\xDE\xE3\xCD\xBE\xC9\xF5\xC0\x0F\x83\xDF\xE2\xAF\xCA\xBB\xD1\xE0\x0E\x06\xCB\xE7\x7F\xD3\xD9\xCB\xE4",
			"\xDF\xAE\x7F\x3E\x80\x05\xE1\xC0\x14\xA1\x86\xA9\x80\xAD\x01\xD8\x81\x87\xB9\xF3\xB6\xF4\x00\xEF\xE5\xAF\xEF\xFC\xA9\x80",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}
